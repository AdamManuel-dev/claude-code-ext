
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Workflow
 * 
 */
export type Workflow = $Result.DefaultSelection<Prisma.$WorkflowPayload>
/**
 * Model Job
 * 
 */
export type Job = $Result.DefaultSelection<Prisma.$JobPayload>
/**
 * Model ExecutionLog
 * 
 */
export type ExecutionLog = $Result.DefaultSelection<Prisma.$ExecutionLogPayload>
/**
 * Model ExecutionScreenshot
 * 
 */
export type ExecutionScreenshot = $Result.DefaultSelection<Prisma.$ExecutionScreenshotPayload>
/**
 * Model Credential
 * 
 */
export type Credential = $Result.DefaultSelection<Prisma.$CredentialPayload>
/**
 * Model CredentialAuditLog
 * 
 */
export type CredentialAuditLog = $Result.DefaultSelection<Prisma.$CredentialAuditLogPayload>
/**
 * Model Webhook
 * 
 */
export type Webhook = $Result.DefaultSelection<Prisma.$WebhookPayload>
/**
 * Model WebhookDelivery
 * 
 */
export type WebhookDelivery = $Result.DefaultSelection<Prisma.$WebhookDeliveryPayload>
/**
 * Model Schedule
 * 
 */
export type Schedule = $Result.DefaultSelection<Prisma.$SchedulePayload>
/**
 * Model ScheduleExecution
 * 
 */
export type ScheduleExecution = $Result.DefaultSelection<Prisma.$ScheduleExecutionPayload>
/**
 * Model ScheduleAuditLog
 * 
 */
export type ScheduleAuditLog = $Result.DefaultSelection<Prisma.$ScheduleAuditLogPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const JobStatus: {
  QUEUED: 'QUEUED',
  RUNNING: 'RUNNING',
  COMPLETED: 'COMPLETED',
  FAILED: 'FAILED',
  CANCELLED: 'CANCELLED',
  RETRYING: 'RETRYING'
};

export type JobStatus = (typeof JobStatus)[keyof typeof JobStatus]


export const LogLevel: {
  DEBUG: 'DEBUG',
  INFO: 'INFO',
  WARN: 'WARN',
  ERROR: 'ERROR'
};

export type LogLevel = (typeof LogLevel)[keyof typeof LogLevel]


export const ScreenshotType: {
  VIEWPORT: 'VIEWPORT',
  ELEMENT: 'ELEMENT'
};

export type ScreenshotType = (typeof ScreenshotType)[keyof typeof ScreenshotType]


export const CredentialType: {
  PASSWORD: 'PASSWORD',
  API_KEY: 'API_KEY',
  TOKEN: 'TOKEN',
  SSH_KEY: 'SSH_KEY',
  CERTIFICATE: 'CERTIFICATE'
};

export type CredentialType = (typeof CredentialType)[keyof typeof CredentialType]


export const CredentialAction: {
  READ: 'READ',
  WRITE: 'WRITE',
  UPDATE: 'UPDATE',
  DELETE: 'DELETE',
  ROTATE: 'ROTATE'
};

export type CredentialAction = (typeof CredentialAction)[keyof typeof CredentialAction]

}

export type JobStatus = $Enums.JobStatus

export const JobStatus: typeof $Enums.JobStatus

export type LogLevel = $Enums.LogLevel

export const LogLevel: typeof $Enums.LogLevel

export type ScreenshotType = $Enums.ScreenshotType

export const ScreenshotType: typeof $Enums.ScreenshotType

export type CredentialType = $Enums.CredentialType

export const CredentialType: typeof $Enums.CredentialType

export type CredentialAction = $Enums.CredentialAction

export const CredentialAction: typeof $Enums.CredentialAction

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Workflows
 * const workflows = await prisma.workflow.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Workflows
   * const workflows = await prisma.workflow.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.workflow`: Exposes CRUD operations for the **Workflow** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Workflows
    * const workflows = await prisma.workflow.findMany()
    * ```
    */
  get workflow(): Prisma.WorkflowDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.job`: Exposes CRUD operations for the **Job** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Jobs
    * const jobs = await prisma.job.findMany()
    * ```
    */
  get job(): Prisma.JobDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.executionLog`: Exposes CRUD operations for the **ExecutionLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ExecutionLogs
    * const executionLogs = await prisma.executionLog.findMany()
    * ```
    */
  get executionLog(): Prisma.ExecutionLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.executionScreenshot`: Exposes CRUD operations for the **ExecutionScreenshot** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ExecutionScreenshots
    * const executionScreenshots = await prisma.executionScreenshot.findMany()
    * ```
    */
  get executionScreenshot(): Prisma.ExecutionScreenshotDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.credential`: Exposes CRUD operations for the **Credential** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Credentials
    * const credentials = await prisma.credential.findMany()
    * ```
    */
  get credential(): Prisma.CredentialDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.credentialAuditLog`: Exposes CRUD operations for the **CredentialAuditLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CredentialAuditLogs
    * const credentialAuditLogs = await prisma.credentialAuditLog.findMany()
    * ```
    */
  get credentialAuditLog(): Prisma.CredentialAuditLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.webhook`: Exposes CRUD operations for the **Webhook** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Webhooks
    * const webhooks = await prisma.webhook.findMany()
    * ```
    */
  get webhook(): Prisma.WebhookDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.webhookDelivery`: Exposes CRUD operations for the **WebhookDelivery** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WebhookDeliveries
    * const webhookDeliveries = await prisma.webhookDelivery.findMany()
    * ```
    */
  get webhookDelivery(): Prisma.WebhookDeliveryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.schedule`: Exposes CRUD operations for the **Schedule** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Schedules
    * const schedules = await prisma.schedule.findMany()
    * ```
    */
  get schedule(): Prisma.ScheduleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.scheduleExecution`: Exposes CRUD operations for the **ScheduleExecution** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ScheduleExecutions
    * const scheduleExecutions = await prisma.scheduleExecution.findMany()
    * ```
    */
  get scheduleExecution(): Prisma.ScheduleExecutionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.scheduleAuditLog`: Exposes CRUD operations for the **ScheduleAuditLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ScheduleAuditLogs
    * const scheduleAuditLogs = await prisma.scheduleAuditLog.findMany()
    * ```
    */
  get scheduleAuditLog(): Prisma.ScheduleAuditLogDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.19.0
   * Query Engine version: 2ba551f319ab1df4bc874a89965d8b3641056773
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import Bytes = runtime.Bytes
  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Workflow: 'Workflow',
    Job: 'Job',
    ExecutionLog: 'ExecutionLog',
    ExecutionScreenshot: 'ExecutionScreenshot',
    Credential: 'Credential',
    CredentialAuditLog: 'CredentialAuditLog',
    Webhook: 'Webhook',
    WebhookDelivery: 'WebhookDelivery',
    Schedule: 'Schedule',
    ScheduleExecution: 'ScheduleExecution',
    ScheduleAuditLog: 'ScheduleAuditLog'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "workflow" | "job" | "executionLog" | "executionScreenshot" | "credential" | "credentialAuditLog" | "webhook" | "webhookDelivery" | "schedule" | "scheduleExecution" | "scheduleAuditLog"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Workflow: {
        payload: Prisma.$WorkflowPayload<ExtArgs>
        fields: Prisma.WorkflowFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WorkflowFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WorkflowFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowPayload>
          }
          findFirst: {
            args: Prisma.WorkflowFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WorkflowFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowPayload>
          }
          findMany: {
            args: Prisma.WorkflowFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowPayload>[]
          }
          create: {
            args: Prisma.WorkflowCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowPayload>
          }
          createMany: {
            args: Prisma.WorkflowCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WorkflowCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowPayload>[]
          }
          delete: {
            args: Prisma.WorkflowDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowPayload>
          }
          update: {
            args: Prisma.WorkflowUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowPayload>
          }
          deleteMany: {
            args: Prisma.WorkflowDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WorkflowUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WorkflowUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowPayload>[]
          }
          upsert: {
            args: Prisma.WorkflowUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowPayload>
          }
          aggregate: {
            args: Prisma.WorkflowAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWorkflow>
          }
          groupBy: {
            args: Prisma.WorkflowGroupByArgs<ExtArgs>
            result: $Utils.Optional<WorkflowGroupByOutputType>[]
          }
          count: {
            args: Prisma.WorkflowCountArgs<ExtArgs>
            result: $Utils.Optional<WorkflowCountAggregateOutputType> | number
          }
        }
      }
      Job: {
        payload: Prisma.$JobPayload<ExtArgs>
        fields: Prisma.JobFieldRefs
        operations: {
          findUnique: {
            args: Prisma.JobFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.JobFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPayload>
          }
          findFirst: {
            args: Prisma.JobFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.JobFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPayload>
          }
          findMany: {
            args: Prisma.JobFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPayload>[]
          }
          create: {
            args: Prisma.JobCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPayload>
          }
          createMany: {
            args: Prisma.JobCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.JobCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPayload>[]
          }
          delete: {
            args: Prisma.JobDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPayload>
          }
          update: {
            args: Prisma.JobUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPayload>
          }
          deleteMany: {
            args: Prisma.JobDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.JobUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.JobUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPayload>[]
          }
          upsert: {
            args: Prisma.JobUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPayload>
          }
          aggregate: {
            args: Prisma.JobAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateJob>
          }
          groupBy: {
            args: Prisma.JobGroupByArgs<ExtArgs>
            result: $Utils.Optional<JobGroupByOutputType>[]
          }
          count: {
            args: Prisma.JobCountArgs<ExtArgs>
            result: $Utils.Optional<JobCountAggregateOutputType> | number
          }
        }
      }
      ExecutionLog: {
        payload: Prisma.$ExecutionLogPayload<ExtArgs>
        fields: Prisma.ExecutionLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ExecutionLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExecutionLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ExecutionLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExecutionLogPayload>
          }
          findFirst: {
            args: Prisma.ExecutionLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExecutionLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ExecutionLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExecutionLogPayload>
          }
          findMany: {
            args: Prisma.ExecutionLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExecutionLogPayload>[]
          }
          create: {
            args: Prisma.ExecutionLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExecutionLogPayload>
          }
          createMany: {
            args: Prisma.ExecutionLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ExecutionLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExecutionLogPayload>[]
          }
          delete: {
            args: Prisma.ExecutionLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExecutionLogPayload>
          }
          update: {
            args: Prisma.ExecutionLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExecutionLogPayload>
          }
          deleteMany: {
            args: Prisma.ExecutionLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ExecutionLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ExecutionLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExecutionLogPayload>[]
          }
          upsert: {
            args: Prisma.ExecutionLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExecutionLogPayload>
          }
          aggregate: {
            args: Prisma.ExecutionLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateExecutionLog>
          }
          groupBy: {
            args: Prisma.ExecutionLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<ExecutionLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.ExecutionLogCountArgs<ExtArgs>
            result: $Utils.Optional<ExecutionLogCountAggregateOutputType> | number
          }
        }
      }
      ExecutionScreenshot: {
        payload: Prisma.$ExecutionScreenshotPayload<ExtArgs>
        fields: Prisma.ExecutionScreenshotFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ExecutionScreenshotFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExecutionScreenshotPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ExecutionScreenshotFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExecutionScreenshotPayload>
          }
          findFirst: {
            args: Prisma.ExecutionScreenshotFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExecutionScreenshotPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ExecutionScreenshotFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExecutionScreenshotPayload>
          }
          findMany: {
            args: Prisma.ExecutionScreenshotFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExecutionScreenshotPayload>[]
          }
          create: {
            args: Prisma.ExecutionScreenshotCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExecutionScreenshotPayload>
          }
          createMany: {
            args: Prisma.ExecutionScreenshotCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ExecutionScreenshotCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExecutionScreenshotPayload>[]
          }
          delete: {
            args: Prisma.ExecutionScreenshotDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExecutionScreenshotPayload>
          }
          update: {
            args: Prisma.ExecutionScreenshotUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExecutionScreenshotPayload>
          }
          deleteMany: {
            args: Prisma.ExecutionScreenshotDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ExecutionScreenshotUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ExecutionScreenshotUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExecutionScreenshotPayload>[]
          }
          upsert: {
            args: Prisma.ExecutionScreenshotUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExecutionScreenshotPayload>
          }
          aggregate: {
            args: Prisma.ExecutionScreenshotAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateExecutionScreenshot>
          }
          groupBy: {
            args: Prisma.ExecutionScreenshotGroupByArgs<ExtArgs>
            result: $Utils.Optional<ExecutionScreenshotGroupByOutputType>[]
          }
          count: {
            args: Prisma.ExecutionScreenshotCountArgs<ExtArgs>
            result: $Utils.Optional<ExecutionScreenshotCountAggregateOutputType> | number
          }
        }
      }
      Credential: {
        payload: Prisma.$CredentialPayload<ExtArgs>
        fields: Prisma.CredentialFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CredentialFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CredentialPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CredentialFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CredentialPayload>
          }
          findFirst: {
            args: Prisma.CredentialFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CredentialPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CredentialFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CredentialPayload>
          }
          findMany: {
            args: Prisma.CredentialFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CredentialPayload>[]
          }
          create: {
            args: Prisma.CredentialCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CredentialPayload>
          }
          createMany: {
            args: Prisma.CredentialCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CredentialCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CredentialPayload>[]
          }
          delete: {
            args: Prisma.CredentialDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CredentialPayload>
          }
          update: {
            args: Prisma.CredentialUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CredentialPayload>
          }
          deleteMany: {
            args: Prisma.CredentialDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CredentialUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CredentialUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CredentialPayload>[]
          }
          upsert: {
            args: Prisma.CredentialUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CredentialPayload>
          }
          aggregate: {
            args: Prisma.CredentialAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCredential>
          }
          groupBy: {
            args: Prisma.CredentialGroupByArgs<ExtArgs>
            result: $Utils.Optional<CredentialGroupByOutputType>[]
          }
          count: {
            args: Prisma.CredentialCountArgs<ExtArgs>
            result: $Utils.Optional<CredentialCountAggregateOutputType> | number
          }
        }
      }
      CredentialAuditLog: {
        payload: Prisma.$CredentialAuditLogPayload<ExtArgs>
        fields: Prisma.CredentialAuditLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CredentialAuditLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CredentialAuditLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CredentialAuditLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CredentialAuditLogPayload>
          }
          findFirst: {
            args: Prisma.CredentialAuditLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CredentialAuditLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CredentialAuditLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CredentialAuditLogPayload>
          }
          findMany: {
            args: Prisma.CredentialAuditLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CredentialAuditLogPayload>[]
          }
          create: {
            args: Prisma.CredentialAuditLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CredentialAuditLogPayload>
          }
          createMany: {
            args: Prisma.CredentialAuditLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CredentialAuditLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CredentialAuditLogPayload>[]
          }
          delete: {
            args: Prisma.CredentialAuditLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CredentialAuditLogPayload>
          }
          update: {
            args: Prisma.CredentialAuditLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CredentialAuditLogPayload>
          }
          deleteMany: {
            args: Prisma.CredentialAuditLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CredentialAuditLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CredentialAuditLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CredentialAuditLogPayload>[]
          }
          upsert: {
            args: Prisma.CredentialAuditLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CredentialAuditLogPayload>
          }
          aggregate: {
            args: Prisma.CredentialAuditLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCredentialAuditLog>
          }
          groupBy: {
            args: Prisma.CredentialAuditLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<CredentialAuditLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.CredentialAuditLogCountArgs<ExtArgs>
            result: $Utils.Optional<CredentialAuditLogCountAggregateOutputType> | number
          }
        }
      }
      Webhook: {
        payload: Prisma.$WebhookPayload<ExtArgs>
        fields: Prisma.WebhookFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WebhookFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WebhookFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookPayload>
          }
          findFirst: {
            args: Prisma.WebhookFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WebhookFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookPayload>
          }
          findMany: {
            args: Prisma.WebhookFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookPayload>[]
          }
          create: {
            args: Prisma.WebhookCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookPayload>
          }
          createMany: {
            args: Prisma.WebhookCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WebhookCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookPayload>[]
          }
          delete: {
            args: Prisma.WebhookDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookPayload>
          }
          update: {
            args: Prisma.WebhookUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookPayload>
          }
          deleteMany: {
            args: Prisma.WebhookDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WebhookUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WebhookUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookPayload>[]
          }
          upsert: {
            args: Prisma.WebhookUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookPayload>
          }
          aggregate: {
            args: Prisma.WebhookAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWebhook>
          }
          groupBy: {
            args: Prisma.WebhookGroupByArgs<ExtArgs>
            result: $Utils.Optional<WebhookGroupByOutputType>[]
          }
          count: {
            args: Prisma.WebhookCountArgs<ExtArgs>
            result: $Utils.Optional<WebhookCountAggregateOutputType> | number
          }
        }
      }
      WebhookDelivery: {
        payload: Prisma.$WebhookDeliveryPayload<ExtArgs>
        fields: Prisma.WebhookDeliveryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WebhookDeliveryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookDeliveryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WebhookDeliveryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookDeliveryPayload>
          }
          findFirst: {
            args: Prisma.WebhookDeliveryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookDeliveryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WebhookDeliveryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookDeliveryPayload>
          }
          findMany: {
            args: Prisma.WebhookDeliveryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookDeliveryPayload>[]
          }
          create: {
            args: Prisma.WebhookDeliveryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookDeliveryPayload>
          }
          createMany: {
            args: Prisma.WebhookDeliveryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WebhookDeliveryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookDeliveryPayload>[]
          }
          delete: {
            args: Prisma.WebhookDeliveryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookDeliveryPayload>
          }
          update: {
            args: Prisma.WebhookDeliveryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookDeliveryPayload>
          }
          deleteMany: {
            args: Prisma.WebhookDeliveryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WebhookDeliveryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WebhookDeliveryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookDeliveryPayload>[]
          }
          upsert: {
            args: Prisma.WebhookDeliveryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookDeliveryPayload>
          }
          aggregate: {
            args: Prisma.WebhookDeliveryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWebhookDelivery>
          }
          groupBy: {
            args: Prisma.WebhookDeliveryGroupByArgs<ExtArgs>
            result: $Utils.Optional<WebhookDeliveryGroupByOutputType>[]
          }
          count: {
            args: Prisma.WebhookDeliveryCountArgs<ExtArgs>
            result: $Utils.Optional<WebhookDeliveryCountAggregateOutputType> | number
          }
        }
      }
      Schedule: {
        payload: Prisma.$SchedulePayload<ExtArgs>
        fields: Prisma.ScheduleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ScheduleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchedulePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ScheduleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchedulePayload>
          }
          findFirst: {
            args: Prisma.ScheduleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchedulePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ScheduleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchedulePayload>
          }
          findMany: {
            args: Prisma.ScheduleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchedulePayload>[]
          }
          create: {
            args: Prisma.ScheduleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchedulePayload>
          }
          createMany: {
            args: Prisma.ScheduleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ScheduleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchedulePayload>[]
          }
          delete: {
            args: Prisma.ScheduleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchedulePayload>
          }
          update: {
            args: Prisma.ScheduleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchedulePayload>
          }
          deleteMany: {
            args: Prisma.ScheduleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ScheduleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ScheduleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchedulePayload>[]
          }
          upsert: {
            args: Prisma.ScheduleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchedulePayload>
          }
          aggregate: {
            args: Prisma.ScheduleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSchedule>
          }
          groupBy: {
            args: Prisma.ScheduleGroupByArgs<ExtArgs>
            result: $Utils.Optional<ScheduleGroupByOutputType>[]
          }
          count: {
            args: Prisma.ScheduleCountArgs<ExtArgs>
            result: $Utils.Optional<ScheduleCountAggregateOutputType> | number
          }
        }
      }
      ScheduleExecution: {
        payload: Prisma.$ScheduleExecutionPayload<ExtArgs>
        fields: Prisma.ScheduleExecutionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ScheduleExecutionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduleExecutionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ScheduleExecutionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduleExecutionPayload>
          }
          findFirst: {
            args: Prisma.ScheduleExecutionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduleExecutionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ScheduleExecutionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduleExecutionPayload>
          }
          findMany: {
            args: Prisma.ScheduleExecutionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduleExecutionPayload>[]
          }
          create: {
            args: Prisma.ScheduleExecutionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduleExecutionPayload>
          }
          createMany: {
            args: Prisma.ScheduleExecutionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ScheduleExecutionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduleExecutionPayload>[]
          }
          delete: {
            args: Prisma.ScheduleExecutionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduleExecutionPayload>
          }
          update: {
            args: Prisma.ScheduleExecutionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduleExecutionPayload>
          }
          deleteMany: {
            args: Prisma.ScheduleExecutionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ScheduleExecutionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ScheduleExecutionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduleExecutionPayload>[]
          }
          upsert: {
            args: Prisma.ScheduleExecutionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduleExecutionPayload>
          }
          aggregate: {
            args: Prisma.ScheduleExecutionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateScheduleExecution>
          }
          groupBy: {
            args: Prisma.ScheduleExecutionGroupByArgs<ExtArgs>
            result: $Utils.Optional<ScheduleExecutionGroupByOutputType>[]
          }
          count: {
            args: Prisma.ScheduleExecutionCountArgs<ExtArgs>
            result: $Utils.Optional<ScheduleExecutionCountAggregateOutputType> | number
          }
        }
      }
      ScheduleAuditLog: {
        payload: Prisma.$ScheduleAuditLogPayload<ExtArgs>
        fields: Prisma.ScheduleAuditLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ScheduleAuditLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduleAuditLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ScheduleAuditLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduleAuditLogPayload>
          }
          findFirst: {
            args: Prisma.ScheduleAuditLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduleAuditLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ScheduleAuditLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduleAuditLogPayload>
          }
          findMany: {
            args: Prisma.ScheduleAuditLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduleAuditLogPayload>[]
          }
          create: {
            args: Prisma.ScheduleAuditLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduleAuditLogPayload>
          }
          createMany: {
            args: Prisma.ScheduleAuditLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ScheduleAuditLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduleAuditLogPayload>[]
          }
          delete: {
            args: Prisma.ScheduleAuditLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduleAuditLogPayload>
          }
          update: {
            args: Prisma.ScheduleAuditLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduleAuditLogPayload>
          }
          deleteMany: {
            args: Prisma.ScheduleAuditLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ScheduleAuditLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ScheduleAuditLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduleAuditLogPayload>[]
          }
          upsert: {
            args: Prisma.ScheduleAuditLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduleAuditLogPayload>
          }
          aggregate: {
            args: Prisma.ScheduleAuditLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateScheduleAuditLog>
          }
          groupBy: {
            args: Prisma.ScheduleAuditLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<ScheduleAuditLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.ScheduleAuditLogCountArgs<ExtArgs>
            result: $Utils.Optional<ScheduleAuditLogCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory | null
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    workflow?: WorkflowOmit
    job?: JobOmit
    executionLog?: ExecutionLogOmit
    executionScreenshot?: ExecutionScreenshotOmit
    credential?: CredentialOmit
    credentialAuditLog?: CredentialAuditLogOmit
    webhook?: WebhookOmit
    webhookDelivery?: WebhookDeliveryOmit
    schedule?: ScheduleOmit
    scheduleExecution?: ScheduleExecutionOmit
    scheduleAuditLog?: ScheduleAuditLogOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type WorkflowCountOutputType
   */

  export type WorkflowCountOutputType = {
    jobs: number
    schedules: number
  }

  export type WorkflowCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    jobs?: boolean | WorkflowCountOutputTypeCountJobsArgs
    schedules?: boolean | WorkflowCountOutputTypeCountSchedulesArgs
  }

  // Custom InputTypes
  /**
   * WorkflowCountOutputType without action
   */
  export type WorkflowCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowCountOutputType
     */
    select?: WorkflowCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * WorkflowCountOutputType without action
   */
  export type WorkflowCountOutputTypeCountJobsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JobWhereInput
  }

  /**
   * WorkflowCountOutputType without action
   */
  export type WorkflowCountOutputTypeCountSchedulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ScheduleWhereInput
  }


  /**
   * Count Type JobCountOutputType
   */

  export type JobCountOutputType = {
    executionLogs: number
    screenshots: number
  }

  export type JobCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    executionLogs?: boolean | JobCountOutputTypeCountExecutionLogsArgs
    screenshots?: boolean | JobCountOutputTypeCountScreenshotsArgs
  }

  // Custom InputTypes
  /**
   * JobCountOutputType without action
   */
  export type JobCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobCountOutputType
     */
    select?: JobCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * JobCountOutputType without action
   */
  export type JobCountOutputTypeCountExecutionLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExecutionLogWhereInput
  }

  /**
   * JobCountOutputType without action
   */
  export type JobCountOutputTypeCountScreenshotsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExecutionScreenshotWhereInput
  }


  /**
   * Count Type CredentialCountOutputType
   */

  export type CredentialCountOutputType = {
    auditLogs: number
  }

  export type CredentialCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    auditLogs?: boolean | CredentialCountOutputTypeCountAuditLogsArgs
  }

  // Custom InputTypes
  /**
   * CredentialCountOutputType without action
   */
  export type CredentialCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CredentialCountOutputType
     */
    select?: CredentialCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CredentialCountOutputType without action
   */
  export type CredentialCountOutputTypeCountAuditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CredentialAuditLogWhereInput
  }


  /**
   * Count Type WebhookCountOutputType
   */

  export type WebhookCountOutputType = {
    deliveries: number
  }

  export type WebhookCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    deliveries?: boolean | WebhookCountOutputTypeCountDeliveriesArgs
  }

  // Custom InputTypes
  /**
   * WebhookCountOutputType without action
   */
  export type WebhookCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookCountOutputType
     */
    select?: WebhookCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * WebhookCountOutputType without action
   */
  export type WebhookCountOutputTypeCountDeliveriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WebhookDeliveryWhereInput
  }


  /**
   * Count Type ScheduleCountOutputType
   */

  export type ScheduleCountOutputType = {
    executions: number
    auditLogs: number
  }

  export type ScheduleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    executions?: boolean | ScheduleCountOutputTypeCountExecutionsArgs
    auditLogs?: boolean | ScheduleCountOutputTypeCountAuditLogsArgs
  }

  // Custom InputTypes
  /**
   * ScheduleCountOutputType without action
   */
  export type ScheduleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduleCountOutputType
     */
    select?: ScheduleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ScheduleCountOutputType without action
   */
  export type ScheduleCountOutputTypeCountExecutionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ScheduleExecutionWhereInput
  }

  /**
   * ScheduleCountOutputType without action
   */
  export type ScheduleCountOutputTypeCountAuditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ScheduleAuditLogWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Workflow
   */

  export type AggregateWorkflow = {
    _count: WorkflowCountAggregateOutputType | null
    _avg: WorkflowAvgAggregateOutputType | null
    _sum: WorkflowSumAggregateOutputType | null
    _min: WorkflowMinAggregateOutputType | null
    _max: WorkflowMaxAggregateOutputType | null
  }

  export type WorkflowAvgAggregateOutputType = {
    version: number | null
    eventsCount: number | null
    estimatedDuration: number | null
  }

  export type WorkflowSumAggregateOutputType = {
    version: number | null
    eventsCount: number | null
    estimatedDuration: number | null
  }

  export type WorkflowMinAggregateOutputType = {
    id: string | null
    organizationId: string | null
    name: string | null
    description: string | null
    version: number | null
    isActive: boolean | null
    eventsCount: number | null
    estimatedDuration: number | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type WorkflowMaxAggregateOutputType = {
    id: string | null
    organizationId: string | null
    name: string | null
    description: string | null
    version: number | null
    isActive: boolean | null
    eventsCount: number | null
    estimatedDuration: number | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type WorkflowCountAggregateOutputType = {
    id: number
    organizationId: number
    name: number
    description: number
    version: number
    isActive: number
    definition: number
    eventsCount: number
    estimatedDuration: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type WorkflowAvgAggregateInputType = {
    version?: true
    eventsCount?: true
    estimatedDuration?: true
  }

  export type WorkflowSumAggregateInputType = {
    version?: true
    eventsCount?: true
    estimatedDuration?: true
  }

  export type WorkflowMinAggregateInputType = {
    id?: true
    organizationId?: true
    name?: true
    description?: true
    version?: true
    isActive?: true
    eventsCount?: true
    estimatedDuration?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type WorkflowMaxAggregateInputType = {
    id?: true
    organizationId?: true
    name?: true
    description?: true
    version?: true
    isActive?: true
    eventsCount?: true
    estimatedDuration?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type WorkflowCountAggregateInputType = {
    id?: true
    organizationId?: true
    name?: true
    description?: true
    version?: true
    isActive?: true
    definition?: true
    eventsCount?: true
    estimatedDuration?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type WorkflowAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Workflow to aggregate.
     */
    where?: WorkflowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Workflows to fetch.
     */
    orderBy?: WorkflowOrderByWithRelationInput | WorkflowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WorkflowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Workflows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Workflows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Workflows
    **/
    _count?: true | WorkflowCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WorkflowAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WorkflowSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WorkflowMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WorkflowMaxAggregateInputType
  }

  export type GetWorkflowAggregateType<T extends WorkflowAggregateArgs> = {
        [P in keyof T & keyof AggregateWorkflow]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWorkflow[P]>
      : GetScalarType<T[P], AggregateWorkflow[P]>
  }




  export type WorkflowGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkflowWhereInput
    orderBy?: WorkflowOrderByWithAggregationInput | WorkflowOrderByWithAggregationInput[]
    by: WorkflowScalarFieldEnum[] | WorkflowScalarFieldEnum
    having?: WorkflowScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WorkflowCountAggregateInputType | true
    _avg?: WorkflowAvgAggregateInputType
    _sum?: WorkflowSumAggregateInputType
    _min?: WorkflowMinAggregateInputType
    _max?: WorkflowMaxAggregateInputType
  }

  export type WorkflowGroupByOutputType = {
    id: string
    organizationId: string
    name: string
    description: string | null
    version: number
    isActive: boolean
    definition: JsonValue
    eventsCount: number
    estimatedDuration: number | null
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: WorkflowCountAggregateOutputType | null
    _avg: WorkflowAvgAggregateOutputType | null
    _sum: WorkflowSumAggregateOutputType | null
    _min: WorkflowMinAggregateOutputType | null
    _max: WorkflowMaxAggregateOutputType | null
  }

  type GetWorkflowGroupByPayload<T extends WorkflowGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WorkflowGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WorkflowGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WorkflowGroupByOutputType[P]>
            : GetScalarType<T[P], WorkflowGroupByOutputType[P]>
        }
      >
    >


  export type WorkflowSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organizationId?: boolean
    name?: boolean
    description?: boolean
    version?: boolean
    isActive?: boolean
    definition?: boolean
    eventsCount?: boolean
    estimatedDuration?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    jobs?: boolean | Workflow$jobsArgs<ExtArgs>
    schedules?: boolean | Workflow$schedulesArgs<ExtArgs>
    _count?: boolean | WorkflowCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workflow"]>

  export type WorkflowSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organizationId?: boolean
    name?: boolean
    description?: boolean
    version?: boolean
    isActive?: boolean
    definition?: boolean
    eventsCount?: boolean
    estimatedDuration?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }, ExtArgs["result"]["workflow"]>

  export type WorkflowSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organizationId?: boolean
    name?: boolean
    description?: boolean
    version?: boolean
    isActive?: boolean
    definition?: boolean
    eventsCount?: boolean
    estimatedDuration?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }, ExtArgs["result"]["workflow"]>

  export type WorkflowSelectScalar = {
    id?: boolean
    organizationId?: boolean
    name?: boolean
    description?: boolean
    version?: boolean
    isActive?: boolean
    definition?: boolean
    eventsCount?: boolean
    estimatedDuration?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type WorkflowOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "organizationId" | "name" | "description" | "version" | "isActive" | "definition" | "eventsCount" | "estimatedDuration" | "createdAt" | "updatedAt" | "deletedAt", ExtArgs["result"]["workflow"]>
  export type WorkflowInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    jobs?: boolean | Workflow$jobsArgs<ExtArgs>
    schedules?: boolean | Workflow$schedulesArgs<ExtArgs>
    _count?: boolean | WorkflowCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type WorkflowIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type WorkflowIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $WorkflowPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Workflow"
    objects: {
      jobs: Prisma.$JobPayload<ExtArgs>[]
      schedules: Prisma.$SchedulePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      organizationId: string
      name: string
      description: string | null
      version: number
      isActive: boolean
      definition: Prisma.JsonValue
      eventsCount: number
      estimatedDuration: number | null
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["workflow"]>
    composites: {}
  }

  type WorkflowGetPayload<S extends boolean | null | undefined | WorkflowDefaultArgs> = $Result.GetResult<Prisma.$WorkflowPayload, S>

  type WorkflowCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WorkflowFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WorkflowCountAggregateInputType | true
    }

  export interface WorkflowDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Workflow'], meta: { name: 'Workflow' } }
    /**
     * Find zero or one Workflow that matches the filter.
     * @param {WorkflowFindUniqueArgs} args - Arguments to find a Workflow
     * @example
     * // Get one Workflow
     * const workflow = await prisma.workflow.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WorkflowFindUniqueArgs>(args: SelectSubset<T, WorkflowFindUniqueArgs<ExtArgs>>): Prisma__WorkflowClient<$Result.GetResult<Prisma.$WorkflowPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Workflow that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WorkflowFindUniqueOrThrowArgs} args - Arguments to find a Workflow
     * @example
     * // Get one Workflow
     * const workflow = await prisma.workflow.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WorkflowFindUniqueOrThrowArgs>(args: SelectSubset<T, WorkflowFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WorkflowClient<$Result.GetResult<Prisma.$WorkflowPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Workflow that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowFindFirstArgs} args - Arguments to find a Workflow
     * @example
     * // Get one Workflow
     * const workflow = await prisma.workflow.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WorkflowFindFirstArgs>(args?: SelectSubset<T, WorkflowFindFirstArgs<ExtArgs>>): Prisma__WorkflowClient<$Result.GetResult<Prisma.$WorkflowPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Workflow that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowFindFirstOrThrowArgs} args - Arguments to find a Workflow
     * @example
     * // Get one Workflow
     * const workflow = await prisma.workflow.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WorkflowFindFirstOrThrowArgs>(args?: SelectSubset<T, WorkflowFindFirstOrThrowArgs<ExtArgs>>): Prisma__WorkflowClient<$Result.GetResult<Prisma.$WorkflowPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Workflows that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Workflows
     * const workflows = await prisma.workflow.findMany()
     * 
     * // Get first 10 Workflows
     * const workflows = await prisma.workflow.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const workflowWithIdOnly = await prisma.workflow.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WorkflowFindManyArgs>(args?: SelectSubset<T, WorkflowFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkflowPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Workflow.
     * @param {WorkflowCreateArgs} args - Arguments to create a Workflow.
     * @example
     * // Create one Workflow
     * const Workflow = await prisma.workflow.create({
     *   data: {
     *     // ... data to create a Workflow
     *   }
     * })
     * 
     */
    create<T extends WorkflowCreateArgs>(args: SelectSubset<T, WorkflowCreateArgs<ExtArgs>>): Prisma__WorkflowClient<$Result.GetResult<Prisma.$WorkflowPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Workflows.
     * @param {WorkflowCreateManyArgs} args - Arguments to create many Workflows.
     * @example
     * // Create many Workflows
     * const workflow = await prisma.workflow.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WorkflowCreateManyArgs>(args?: SelectSubset<T, WorkflowCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Workflows and returns the data saved in the database.
     * @param {WorkflowCreateManyAndReturnArgs} args - Arguments to create many Workflows.
     * @example
     * // Create many Workflows
     * const workflow = await prisma.workflow.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Workflows and only return the `id`
     * const workflowWithIdOnly = await prisma.workflow.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WorkflowCreateManyAndReturnArgs>(args?: SelectSubset<T, WorkflowCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkflowPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Workflow.
     * @param {WorkflowDeleteArgs} args - Arguments to delete one Workflow.
     * @example
     * // Delete one Workflow
     * const Workflow = await prisma.workflow.delete({
     *   where: {
     *     // ... filter to delete one Workflow
     *   }
     * })
     * 
     */
    delete<T extends WorkflowDeleteArgs>(args: SelectSubset<T, WorkflowDeleteArgs<ExtArgs>>): Prisma__WorkflowClient<$Result.GetResult<Prisma.$WorkflowPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Workflow.
     * @param {WorkflowUpdateArgs} args - Arguments to update one Workflow.
     * @example
     * // Update one Workflow
     * const workflow = await prisma.workflow.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WorkflowUpdateArgs>(args: SelectSubset<T, WorkflowUpdateArgs<ExtArgs>>): Prisma__WorkflowClient<$Result.GetResult<Prisma.$WorkflowPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Workflows.
     * @param {WorkflowDeleteManyArgs} args - Arguments to filter Workflows to delete.
     * @example
     * // Delete a few Workflows
     * const { count } = await prisma.workflow.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WorkflowDeleteManyArgs>(args?: SelectSubset<T, WorkflowDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Workflows.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Workflows
     * const workflow = await prisma.workflow.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WorkflowUpdateManyArgs>(args: SelectSubset<T, WorkflowUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Workflows and returns the data updated in the database.
     * @param {WorkflowUpdateManyAndReturnArgs} args - Arguments to update many Workflows.
     * @example
     * // Update many Workflows
     * const workflow = await prisma.workflow.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Workflows and only return the `id`
     * const workflowWithIdOnly = await prisma.workflow.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WorkflowUpdateManyAndReturnArgs>(args: SelectSubset<T, WorkflowUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkflowPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Workflow.
     * @param {WorkflowUpsertArgs} args - Arguments to update or create a Workflow.
     * @example
     * // Update or create a Workflow
     * const workflow = await prisma.workflow.upsert({
     *   create: {
     *     // ... data to create a Workflow
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Workflow we want to update
     *   }
     * })
     */
    upsert<T extends WorkflowUpsertArgs>(args: SelectSubset<T, WorkflowUpsertArgs<ExtArgs>>): Prisma__WorkflowClient<$Result.GetResult<Prisma.$WorkflowPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Workflows.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowCountArgs} args - Arguments to filter Workflows to count.
     * @example
     * // Count the number of Workflows
     * const count = await prisma.workflow.count({
     *   where: {
     *     // ... the filter for the Workflows we want to count
     *   }
     * })
    **/
    count<T extends WorkflowCountArgs>(
      args?: Subset<T, WorkflowCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WorkflowCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Workflow.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WorkflowAggregateArgs>(args: Subset<T, WorkflowAggregateArgs>): Prisma.PrismaPromise<GetWorkflowAggregateType<T>>

    /**
     * Group by Workflow.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WorkflowGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WorkflowGroupByArgs['orderBy'] }
        : { orderBy?: WorkflowGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WorkflowGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWorkflowGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Workflow model
   */
  readonly fields: WorkflowFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Workflow.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WorkflowClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    jobs<T extends Workflow$jobsArgs<ExtArgs> = {}>(args?: Subset<T, Workflow$jobsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    schedules<T extends Workflow$schedulesArgs<ExtArgs> = {}>(args?: Subset<T, Workflow$schedulesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SchedulePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Workflow model
   */
  interface WorkflowFieldRefs {
    readonly id: FieldRef<"Workflow", 'String'>
    readonly organizationId: FieldRef<"Workflow", 'String'>
    readonly name: FieldRef<"Workflow", 'String'>
    readonly description: FieldRef<"Workflow", 'String'>
    readonly version: FieldRef<"Workflow", 'Int'>
    readonly isActive: FieldRef<"Workflow", 'Boolean'>
    readonly definition: FieldRef<"Workflow", 'Json'>
    readonly eventsCount: FieldRef<"Workflow", 'Int'>
    readonly estimatedDuration: FieldRef<"Workflow", 'Int'>
    readonly createdAt: FieldRef<"Workflow", 'DateTime'>
    readonly updatedAt: FieldRef<"Workflow", 'DateTime'>
    readonly deletedAt: FieldRef<"Workflow", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Workflow findUnique
   */
  export type WorkflowFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workflow
     */
    select?: WorkflowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Workflow
     */
    omit?: WorkflowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowInclude<ExtArgs> | null
    /**
     * Filter, which Workflow to fetch.
     */
    where: WorkflowWhereUniqueInput
  }

  /**
   * Workflow findUniqueOrThrow
   */
  export type WorkflowFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workflow
     */
    select?: WorkflowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Workflow
     */
    omit?: WorkflowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowInclude<ExtArgs> | null
    /**
     * Filter, which Workflow to fetch.
     */
    where: WorkflowWhereUniqueInput
  }

  /**
   * Workflow findFirst
   */
  export type WorkflowFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workflow
     */
    select?: WorkflowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Workflow
     */
    omit?: WorkflowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowInclude<ExtArgs> | null
    /**
     * Filter, which Workflow to fetch.
     */
    where?: WorkflowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Workflows to fetch.
     */
    orderBy?: WorkflowOrderByWithRelationInput | WorkflowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Workflows.
     */
    cursor?: WorkflowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Workflows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Workflows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Workflows.
     */
    distinct?: WorkflowScalarFieldEnum | WorkflowScalarFieldEnum[]
  }

  /**
   * Workflow findFirstOrThrow
   */
  export type WorkflowFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workflow
     */
    select?: WorkflowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Workflow
     */
    omit?: WorkflowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowInclude<ExtArgs> | null
    /**
     * Filter, which Workflow to fetch.
     */
    where?: WorkflowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Workflows to fetch.
     */
    orderBy?: WorkflowOrderByWithRelationInput | WorkflowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Workflows.
     */
    cursor?: WorkflowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Workflows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Workflows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Workflows.
     */
    distinct?: WorkflowScalarFieldEnum | WorkflowScalarFieldEnum[]
  }

  /**
   * Workflow findMany
   */
  export type WorkflowFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workflow
     */
    select?: WorkflowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Workflow
     */
    omit?: WorkflowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowInclude<ExtArgs> | null
    /**
     * Filter, which Workflows to fetch.
     */
    where?: WorkflowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Workflows to fetch.
     */
    orderBy?: WorkflowOrderByWithRelationInput | WorkflowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Workflows.
     */
    cursor?: WorkflowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Workflows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Workflows.
     */
    skip?: number
    distinct?: WorkflowScalarFieldEnum | WorkflowScalarFieldEnum[]
  }

  /**
   * Workflow create
   */
  export type WorkflowCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workflow
     */
    select?: WorkflowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Workflow
     */
    omit?: WorkflowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowInclude<ExtArgs> | null
    /**
     * The data needed to create a Workflow.
     */
    data: XOR<WorkflowCreateInput, WorkflowUncheckedCreateInput>
  }

  /**
   * Workflow createMany
   */
  export type WorkflowCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Workflows.
     */
    data: WorkflowCreateManyInput | WorkflowCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Workflow createManyAndReturn
   */
  export type WorkflowCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workflow
     */
    select?: WorkflowSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Workflow
     */
    omit?: WorkflowOmit<ExtArgs> | null
    /**
     * The data used to create many Workflows.
     */
    data: WorkflowCreateManyInput | WorkflowCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Workflow update
   */
  export type WorkflowUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workflow
     */
    select?: WorkflowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Workflow
     */
    omit?: WorkflowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowInclude<ExtArgs> | null
    /**
     * The data needed to update a Workflow.
     */
    data: XOR<WorkflowUpdateInput, WorkflowUncheckedUpdateInput>
    /**
     * Choose, which Workflow to update.
     */
    where: WorkflowWhereUniqueInput
  }

  /**
   * Workflow updateMany
   */
  export type WorkflowUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Workflows.
     */
    data: XOR<WorkflowUpdateManyMutationInput, WorkflowUncheckedUpdateManyInput>
    /**
     * Filter which Workflows to update
     */
    where?: WorkflowWhereInput
    /**
     * Limit how many Workflows to update.
     */
    limit?: number
  }

  /**
   * Workflow updateManyAndReturn
   */
  export type WorkflowUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workflow
     */
    select?: WorkflowSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Workflow
     */
    omit?: WorkflowOmit<ExtArgs> | null
    /**
     * The data used to update Workflows.
     */
    data: XOR<WorkflowUpdateManyMutationInput, WorkflowUncheckedUpdateManyInput>
    /**
     * Filter which Workflows to update
     */
    where?: WorkflowWhereInput
    /**
     * Limit how many Workflows to update.
     */
    limit?: number
  }

  /**
   * Workflow upsert
   */
  export type WorkflowUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workflow
     */
    select?: WorkflowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Workflow
     */
    omit?: WorkflowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowInclude<ExtArgs> | null
    /**
     * The filter to search for the Workflow to update in case it exists.
     */
    where: WorkflowWhereUniqueInput
    /**
     * In case the Workflow found by the `where` argument doesn't exist, create a new Workflow with this data.
     */
    create: XOR<WorkflowCreateInput, WorkflowUncheckedCreateInput>
    /**
     * In case the Workflow was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WorkflowUpdateInput, WorkflowUncheckedUpdateInput>
  }

  /**
   * Workflow delete
   */
  export type WorkflowDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workflow
     */
    select?: WorkflowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Workflow
     */
    omit?: WorkflowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowInclude<ExtArgs> | null
    /**
     * Filter which Workflow to delete.
     */
    where: WorkflowWhereUniqueInput
  }

  /**
   * Workflow deleteMany
   */
  export type WorkflowDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Workflows to delete
     */
    where?: WorkflowWhereInput
    /**
     * Limit how many Workflows to delete.
     */
    limit?: number
  }

  /**
   * Workflow.jobs
   */
  export type Workflow$jobsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Job
     */
    select?: JobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Job
     */
    omit?: JobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobInclude<ExtArgs> | null
    where?: JobWhereInput
    orderBy?: JobOrderByWithRelationInput | JobOrderByWithRelationInput[]
    cursor?: JobWhereUniqueInput
    take?: number
    skip?: number
    distinct?: JobScalarFieldEnum | JobScalarFieldEnum[]
  }

  /**
   * Workflow.schedules
   */
  export type Workflow$schedulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Schedule
     */
    omit?: ScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleInclude<ExtArgs> | null
    where?: ScheduleWhereInput
    orderBy?: ScheduleOrderByWithRelationInput | ScheduleOrderByWithRelationInput[]
    cursor?: ScheduleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ScheduleScalarFieldEnum | ScheduleScalarFieldEnum[]
  }

  /**
   * Workflow without action
   */
  export type WorkflowDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workflow
     */
    select?: WorkflowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Workflow
     */
    omit?: WorkflowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowInclude<ExtArgs> | null
  }


  /**
   * Model Job
   */

  export type AggregateJob = {
    _count: JobCountAggregateOutputType | null
    _avg: JobAvgAggregateOutputType | null
    _sum: JobSumAggregateOutputType | null
    _min: JobMinAggregateOutputType | null
    _max: JobMaxAggregateOutputType | null
  }

  export type JobAvgAggregateOutputType = {
    priority: number | null
    currentStep: number | null
    totalSteps: number | null
    progressPercent: number | null
    estimatedTimeRemaining: number | null
    retryCount: number | null
    maxRetries: number | null
  }

  export type JobSumAggregateOutputType = {
    priority: number | null
    currentStep: number | null
    totalSteps: number | null
    progressPercent: number | null
    estimatedTimeRemaining: number | null
    retryCount: number | null
    maxRetries: number | null
  }

  export type JobMinAggregateOutputType = {
    id: string | null
    workflowId: string | null
    userId: string | null
    priority: number | null
    status: $Enums.JobStatus | null
    currentStep: number | null
    totalSteps: number | null
    progressPercent: number | null
    estimatedTimeRemaining: number | null
    startedAt: Date | null
    completedAt: Date | null
    failedAt: Date | null
    errorCode: string | null
    errorMessage: string | null
    isRecoverable: boolean | null
    retryCount: number | null
    maxRetries: number | null
    lastRetryAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type JobMaxAggregateOutputType = {
    id: string | null
    workflowId: string | null
    userId: string | null
    priority: number | null
    status: $Enums.JobStatus | null
    currentStep: number | null
    totalSteps: number | null
    progressPercent: number | null
    estimatedTimeRemaining: number | null
    startedAt: Date | null
    completedAt: Date | null
    failedAt: Date | null
    errorCode: string | null
    errorMessage: string | null
    isRecoverable: boolean | null
    retryCount: number | null
    maxRetries: number | null
    lastRetryAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type JobCountAggregateOutputType = {
    id: number
    workflowId: number
    userId: number
    priority: number
    status: number
    currentStep: number
    totalSteps: number
    progressPercent: number
    estimatedTimeRemaining: number
    startedAt: number
    completedAt: number
    failedAt: number
    errorCode: number
    errorMessage: number
    isRecoverable: number
    retryCount: number
    maxRetries: number
    lastRetryAt: number
    result: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type JobAvgAggregateInputType = {
    priority?: true
    currentStep?: true
    totalSteps?: true
    progressPercent?: true
    estimatedTimeRemaining?: true
    retryCount?: true
    maxRetries?: true
  }

  export type JobSumAggregateInputType = {
    priority?: true
    currentStep?: true
    totalSteps?: true
    progressPercent?: true
    estimatedTimeRemaining?: true
    retryCount?: true
    maxRetries?: true
  }

  export type JobMinAggregateInputType = {
    id?: true
    workflowId?: true
    userId?: true
    priority?: true
    status?: true
    currentStep?: true
    totalSteps?: true
    progressPercent?: true
    estimatedTimeRemaining?: true
    startedAt?: true
    completedAt?: true
    failedAt?: true
    errorCode?: true
    errorMessage?: true
    isRecoverable?: true
    retryCount?: true
    maxRetries?: true
    lastRetryAt?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type JobMaxAggregateInputType = {
    id?: true
    workflowId?: true
    userId?: true
    priority?: true
    status?: true
    currentStep?: true
    totalSteps?: true
    progressPercent?: true
    estimatedTimeRemaining?: true
    startedAt?: true
    completedAt?: true
    failedAt?: true
    errorCode?: true
    errorMessage?: true
    isRecoverable?: true
    retryCount?: true
    maxRetries?: true
    lastRetryAt?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type JobCountAggregateInputType = {
    id?: true
    workflowId?: true
    userId?: true
    priority?: true
    status?: true
    currentStep?: true
    totalSteps?: true
    progressPercent?: true
    estimatedTimeRemaining?: true
    startedAt?: true
    completedAt?: true
    failedAt?: true
    errorCode?: true
    errorMessage?: true
    isRecoverable?: true
    retryCount?: true
    maxRetries?: true
    lastRetryAt?: true
    result?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type JobAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Job to aggregate.
     */
    where?: JobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Jobs to fetch.
     */
    orderBy?: JobOrderByWithRelationInput | JobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: JobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Jobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Jobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Jobs
    **/
    _count?: true | JobCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: JobAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: JobSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: JobMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: JobMaxAggregateInputType
  }

  export type GetJobAggregateType<T extends JobAggregateArgs> = {
        [P in keyof T & keyof AggregateJob]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateJob[P]>
      : GetScalarType<T[P], AggregateJob[P]>
  }




  export type JobGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JobWhereInput
    orderBy?: JobOrderByWithAggregationInput | JobOrderByWithAggregationInput[]
    by: JobScalarFieldEnum[] | JobScalarFieldEnum
    having?: JobScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: JobCountAggregateInputType | true
    _avg?: JobAvgAggregateInputType
    _sum?: JobSumAggregateInputType
    _min?: JobMinAggregateInputType
    _max?: JobMaxAggregateInputType
  }

  export type JobGroupByOutputType = {
    id: string
    workflowId: string
    userId: string
    priority: number
    status: $Enums.JobStatus
    currentStep: number
    totalSteps: number
    progressPercent: number
    estimatedTimeRemaining: number | null
    startedAt: Date | null
    completedAt: Date | null
    failedAt: Date | null
    errorCode: string | null
    errorMessage: string | null
    isRecoverable: boolean
    retryCount: number
    maxRetries: number
    lastRetryAt: Date | null
    result: JsonValue | null
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: JobCountAggregateOutputType | null
    _avg: JobAvgAggregateOutputType | null
    _sum: JobSumAggregateOutputType | null
    _min: JobMinAggregateOutputType | null
    _max: JobMaxAggregateOutputType | null
  }

  type GetJobGroupByPayload<T extends JobGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<JobGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof JobGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], JobGroupByOutputType[P]>
            : GetScalarType<T[P], JobGroupByOutputType[P]>
        }
      >
    >


  export type JobSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workflowId?: boolean
    userId?: boolean
    priority?: boolean
    status?: boolean
    currentStep?: boolean
    totalSteps?: boolean
    progressPercent?: boolean
    estimatedTimeRemaining?: boolean
    startedAt?: boolean
    completedAt?: boolean
    failedAt?: boolean
    errorCode?: boolean
    errorMessage?: boolean
    isRecoverable?: boolean
    retryCount?: boolean
    maxRetries?: boolean
    lastRetryAt?: boolean
    result?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    workflow?: boolean | WorkflowDefaultArgs<ExtArgs>
    executionLogs?: boolean | Job$executionLogsArgs<ExtArgs>
    screenshots?: boolean | Job$screenshotsArgs<ExtArgs>
    scheduleExecution?: boolean | Job$scheduleExecutionArgs<ExtArgs>
    _count?: boolean | JobCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["job"]>

  export type JobSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workflowId?: boolean
    userId?: boolean
    priority?: boolean
    status?: boolean
    currentStep?: boolean
    totalSteps?: boolean
    progressPercent?: boolean
    estimatedTimeRemaining?: boolean
    startedAt?: boolean
    completedAt?: boolean
    failedAt?: boolean
    errorCode?: boolean
    errorMessage?: boolean
    isRecoverable?: boolean
    retryCount?: boolean
    maxRetries?: boolean
    lastRetryAt?: boolean
    result?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    workflow?: boolean | WorkflowDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["job"]>

  export type JobSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workflowId?: boolean
    userId?: boolean
    priority?: boolean
    status?: boolean
    currentStep?: boolean
    totalSteps?: boolean
    progressPercent?: boolean
    estimatedTimeRemaining?: boolean
    startedAt?: boolean
    completedAt?: boolean
    failedAt?: boolean
    errorCode?: boolean
    errorMessage?: boolean
    isRecoverable?: boolean
    retryCount?: boolean
    maxRetries?: boolean
    lastRetryAt?: boolean
    result?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    workflow?: boolean | WorkflowDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["job"]>

  export type JobSelectScalar = {
    id?: boolean
    workflowId?: boolean
    userId?: boolean
    priority?: boolean
    status?: boolean
    currentStep?: boolean
    totalSteps?: boolean
    progressPercent?: boolean
    estimatedTimeRemaining?: boolean
    startedAt?: boolean
    completedAt?: boolean
    failedAt?: boolean
    errorCode?: boolean
    errorMessage?: boolean
    isRecoverable?: boolean
    retryCount?: boolean
    maxRetries?: boolean
    lastRetryAt?: boolean
    result?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type JobOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "workflowId" | "userId" | "priority" | "status" | "currentStep" | "totalSteps" | "progressPercent" | "estimatedTimeRemaining" | "startedAt" | "completedAt" | "failedAt" | "errorCode" | "errorMessage" | "isRecoverable" | "retryCount" | "maxRetries" | "lastRetryAt" | "result" | "createdAt" | "updatedAt" | "deletedAt", ExtArgs["result"]["job"]>
  export type JobInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workflow?: boolean | WorkflowDefaultArgs<ExtArgs>
    executionLogs?: boolean | Job$executionLogsArgs<ExtArgs>
    screenshots?: boolean | Job$screenshotsArgs<ExtArgs>
    scheduleExecution?: boolean | Job$scheduleExecutionArgs<ExtArgs>
    _count?: boolean | JobCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type JobIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workflow?: boolean | WorkflowDefaultArgs<ExtArgs>
  }
  export type JobIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workflow?: boolean | WorkflowDefaultArgs<ExtArgs>
  }

  export type $JobPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Job"
    objects: {
      workflow: Prisma.$WorkflowPayload<ExtArgs>
      executionLogs: Prisma.$ExecutionLogPayload<ExtArgs>[]
      screenshots: Prisma.$ExecutionScreenshotPayload<ExtArgs>[]
      scheduleExecution: Prisma.$ScheduleExecutionPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      workflowId: string
      userId: string
      priority: number
      status: $Enums.JobStatus
      currentStep: number
      totalSteps: number
      progressPercent: number
      estimatedTimeRemaining: number | null
      startedAt: Date | null
      completedAt: Date | null
      failedAt: Date | null
      errorCode: string | null
      errorMessage: string | null
      isRecoverable: boolean
      retryCount: number
      maxRetries: number
      lastRetryAt: Date | null
      result: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["job"]>
    composites: {}
  }

  type JobGetPayload<S extends boolean | null | undefined | JobDefaultArgs> = $Result.GetResult<Prisma.$JobPayload, S>

  type JobCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<JobFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: JobCountAggregateInputType | true
    }

  export interface JobDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Job'], meta: { name: 'Job' } }
    /**
     * Find zero or one Job that matches the filter.
     * @param {JobFindUniqueArgs} args - Arguments to find a Job
     * @example
     * // Get one Job
     * const job = await prisma.job.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends JobFindUniqueArgs>(args: SelectSubset<T, JobFindUniqueArgs<ExtArgs>>): Prisma__JobClient<$Result.GetResult<Prisma.$JobPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Job that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {JobFindUniqueOrThrowArgs} args - Arguments to find a Job
     * @example
     * // Get one Job
     * const job = await prisma.job.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends JobFindUniqueOrThrowArgs>(args: SelectSubset<T, JobFindUniqueOrThrowArgs<ExtArgs>>): Prisma__JobClient<$Result.GetResult<Prisma.$JobPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Job that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobFindFirstArgs} args - Arguments to find a Job
     * @example
     * // Get one Job
     * const job = await prisma.job.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends JobFindFirstArgs>(args?: SelectSubset<T, JobFindFirstArgs<ExtArgs>>): Prisma__JobClient<$Result.GetResult<Prisma.$JobPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Job that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobFindFirstOrThrowArgs} args - Arguments to find a Job
     * @example
     * // Get one Job
     * const job = await prisma.job.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends JobFindFirstOrThrowArgs>(args?: SelectSubset<T, JobFindFirstOrThrowArgs<ExtArgs>>): Prisma__JobClient<$Result.GetResult<Prisma.$JobPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Jobs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Jobs
     * const jobs = await prisma.job.findMany()
     * 
     * // Get first 10 Jobs
     * const jobs = await prisma.job.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const jobWithIdOnly = await prisma.job.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends JobFindManyArgs>(args?: SelectSubset<T, JobFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Job.
     * @param {JobCreateArgs} args - Arguments to create a Job.
     * @example
     * // Create one Job
     * const Job = await prisma.job.create({
     *   data: {
     *     // ... data to create a Job
     *   }
     * })
     * 
     */
    create<T extends JobCreateArgs>(args: SelectSubset<T, JobCreateArgs<ExtArgs>>): Prisma__JobClient<$Result.GetResult<Prisma.$JobPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Jobs.
     * @param {JobCreateManyArgs} args - Arguments to create many Jobs.
     * @example
     * // Create many Jobs
     * const job = await prisma.job.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends JobCreateManyArgs>(args?: SelectSubset<T, JobCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Jobs and returns the data saved in the database.
     * @param {JobCreateManyAndReturnArgs} args - Arguments to create many Jobs.
     * @example
     * // Create many Jobs
     * const job = await prisma.job.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Jobs and only return the `id`
     * const jobWithIdOnly = await prisma.job.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends JobCreateManyAndReturnArgs>(args?: SelectSubset<T, JobCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Job.
     * @param {JobDeleteArgs} args - Arguments to delete one Job.
     * @example
     * // Delete one Job
     * const Job = await prisma.job.delete({
     *   where: {
     *     // ... filter to delete one Job
     *   }
     * })
     * 
     */
    delete<T extends JobDeleteArgs>(args: SelectSubset<T, JobDeleteArgs<ExtArgs>>): Prisma__JobClient<$Result.GetResult<Prisma.$JobPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Job.
     * @param {JobUpdateArgs} args - Arguments to update one Job.
     * @example
     * // Update one Job
     * const job = await prisma.job.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends JobUpdateArgs>(args: SelectSubset<T, JobUpdateArgs<ExtArgs>>): Prisma__JobClient<$Result.GetResult<Prisma.$JobPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Jobs.
     * @param {JobDeleteManyArgs} args - Arguments to filter Jobs to delete.
     * @example
     * // Delete a few Jobs
     * const { count } = await prisma.job.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends JobDeleteManyArgs>(args?: SelectSubset<T, JobDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Jobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Jobs
     * const job = await prisma.job.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends JobUpdateManyArgs>(args: SelectSubset<T, JobUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Jobs and returns the data updated in the database.
     * @param {JobUpdateManyAndReturnArgs} args - Arguments to update many Jobs.
     * @example
     * // Update many Jobs
     * const job = await prisma.job.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Jobs and only return the `id`
     * const jobWithIdOnly = await prisma.job.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends JobUpdateManyAndReturnArgs>(args: SelectSubset<T, JobUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Job.
     * @param {JobUpsertArgs} args - Arguments to update or create a Job.
     * @example
     * // Update or create a Job
     * const job = await prisma.job.upsert({
     *   create: {
     *     // ... data to create a Job
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Job we want to update
     *   }
     * })
     */
    upsert<T extends JobUpsertArgs>(args: SelectSubset<T, JobUpsertArgs<ExtArgs>>): Prisma__JobClient<$Result.GetResult<Prisma.$JobPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Jobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobCountArgs} args - Arguments to filter Jobs to count.
     * @example
     * // Count the number of Jobs
     * const count = await prisma.job.count({
     *   where: {
     *     // ... the filter for the Jobs we want to count
     *   }
     * })
    **/
    count<T extends JobCountArgs>(
      args?: Subset<T, JobCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], JobCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Job.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends JobAggregateArgs>(args: Subset<T, JobAggregateArgs>): Prisma.PrismaPromise<GetJobAggregateType<T>>

    /**
     * Group by Job.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends JobGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: JobGroupByArgs['orderBy'] }
        : { orderBy?: JobGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, JobGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetJobGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Job model
   */
  readonly fields: JobFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Job.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__JobClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    workflow<T extends WorkflowDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkflowDefaultArgs<ExtArgs>>): Prisma__WorkflowClient<$Result.GetResult<Prisma.$WorkflowPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    executionLogs<T extends Job$executionLogsArgs<ExtArgs> = {}>(args?: Subset<T, Job$executionLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExecutionLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    screenshots<T extends Job$screenshotsArgs<ExtArgs> = {}>(args?: Subset<T, Job$screenshotsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExecutionScreenshotPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    scheduleExecution<T extends Job$scheduleExecutionArgs<ExtArgs> = {}>(args?: Subset<T, Job$scheduleExecutionArgs<ExtArgs>>): Prisma__ScheduleExecutionClient<$Result.GetResult<Prisma.$ScheduleExecutionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Job model
   */
  interface JobFieldRefs {
    readonly id: FieldRef<"Job", 'String'>
    readonly workflowId: FieldRef<"Job", 'String'>
    readonly userId: FieldRef<"Job", 'String'>
    readonly priority: FieldRef<"Job", 'Int'>
    readonly status: FieldRef<"Job", 'JobStatus'>
    readonly currentStep: FieldRef<"Job", 'Int'>
    readonly totalSteps: FieldRef<"Job", 'Int'>
    readonly progressPercent: FieldRef<"Job", 'Float'>
    readonly estimatedTimeRemaining: FieldRef<"Job", 'Int'>
    readonly startedAt: FieldRef<"Job", 'DateTime'>
    readonly completedAt: FieldRef<"Job", 'DateTime'>
    readonly failedAt: FieldRef<"Job", 'DateTime'>
    readonly errorCode: FieldRef<"Job", 'String'>
    readonly errorMessage: FieldRef<"Job", 'String'>
    readonly isRecoverable: FieldRef<"Job", 'Boolean'>
    readonly retryCount: FieldRef<"Job", 'Int'>
    readonly maxRetries: FieldRef<"Job", 'Int'>
    readonly lastRetryAt: FieldRef<"Job", 'DateTime'>
    readonly result: FieldRef<"Job", 'Json'>
    readonly createdAt: FieldRef<"Job", 'DateTime'>
    readonly updatedAt: FieldRef<"Job", 'DateTime'>
    readonly deletedAt: FieldRef<"Job", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Job findUnique
   */
  export type JobFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Job
     */
    select?: JobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Job
     */
    omit?: JobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobInclude<ExtArgs> | null
    /**
     * Filter, which Job to fetch.
     */
    where: JobWhereUniqueInput
  }

  /**
   * Job findUniqueOrThrow
   */
  export type JobFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Job
     */
    select?: JobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Job
     */
    omit?: JobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobInclude<ExtArgs> | null
    /**
     * Filter, which Job to fetch.
     */
    where: JobWhereUniqueInput
  }

  /**
   * Job findFirst
   */
  export type JobFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Job
     */
    select?: JobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Job
     */
    omit?: JobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobInclude<ExtArgs> | null
    /**
     * Filter, which Job to fetch.
     */
    where?: JobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Jobs to fetch.
     */
    orderBy?: JobOrderByWithRelationInput | JobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Jobs.
     */
    cursor?: JobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Jobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Jobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Jobs.
     */
    distinct?: JobScalarFieldEnum | JobScalarFieldEnum[]
  }

  /**
   * Job findFirstOrThrow
   */
  export type JobFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Job
     */
    select?: JobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Job
     */
    omit?: JobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobInclude<ExtArgs> | null
    /**
     * Filter, which Job to fetch.
     */
    where?: JobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Jobs to fetch.
     */
    orderBy?: JobOrderByWithRelationInput | JobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Jobs.
     */
    cursor?: JobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Jobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Jobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Jobs.
     */
    distinct?: JobScalarFieldEnum | JobScalarFieldEnum[]
  }

  /**
   * Job findMany
   */
  export type JobFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Job
     */
    select?: JobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Job
     */
    omit?: JobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobInclude<ExtArgs> | null
    /**
     * Filter, which Jobs to fetch.
     */
    where?: JobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Jobs to fetch.
     */
    orderBy?: JobOrderByWithRelationInput | JobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Jobs.
     */
    cursor?: JobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Jobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Jobs.
     */
    skip?: number
    distinct?: JobScalarFieldEnum | JobScalarFieldEnum[]
  }

  /**
   * Job create
   */
  export type JobCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Job
     */
    select?: JobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Job
     */
    omit?: JobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobInclude<ExtArgs> | null
    /**
     * The data needed to create a Job.
     */
    data: XOR<JobCreateInput, JobUncheckedCreateInput>
  }

  /**
   * Job createMany
   */
  export type JobCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Jobs.
     */
    data: JobCreateManyInput | JobCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Job createManyAndReturn
   */
  export type JobCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Job
     */
    select?: JobSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Job
     */
    omit?: JobOmit<ExtArgs> | null
    /**
     * The data used to create many Jobs.
     */
    data: JobCreateManyInput | JobCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Job update
   */
  export type JobUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Job
     */
    select?: JobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Job
     */
    omit?: JobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobInclude<ExtArgs> | null
    /**
     * The data needed to update a Job.
     */
    data: XOR<JobUpdateInput, JobUncheckedUpdateInput>
    /**
     * Choose, which Job to update.
     */
    where: JobWhereUniqueInput
  }

  /**
   * Job updateMany
   */
  export type JobUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Jobs.
     */
    data: XOR<JobUpdateManyMutationInput, JobUncheckedUpdateManyInput>
    /**
     * Filter which Jobs to update
     */
    where?: JobWhereInput
    /**
     * Limit how many Jobs to update.
     */
    limit?: number
  }

  /**
   * Job updateManyAndReturn
   */
  export type JobUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Job
     */
    select?: JobSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Job
     */
    omit?: JobOmit<ExtArgs> | null
    /**
     * The data used to update Jobs.
     */
    data: XOR<JobUpdateManyMutationInput, JobUncheckedUpdateManyInput>
    /**
     * Filter which Jobs to update
     */
    where?: JobWhereInput
    /**
     * Limit how many Jobs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Job upsert
   */
  export type JobUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Job
     */
    select?: JobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Job
     */
    omit?: JobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobInclude<ExtArgs> | null
    /**
     * The filter to search for the Job to update in case it exists.
     */
    where: JobWhereUniqueInput
    /**
     * In case the Job found by the `where` argument doesn't exist, create a new Job with this data.
     */
    create: XOR<JobCreateInput, JobUncheckedCreateInput>
    /**
     * In case the Job was found with the provided `where` argument, update it with this data.
     */
    update: XOR<JobUpdateInput, JobUncheckedUpdateInput>
  }

  /**
   * Job delete
   */
  export type JobDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Job
     */
    select?: JobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Job
     */
    omit?: JobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobInclude<ExtArgs> | null
    /**
     * Filter which Job to delete.
     */
    where: JobWhereUniqueInput
  }

  /**
   * Job deleteMany
   */
  export type JobDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Jobs to delete
     */
    where?: JobWhereInput
    /**
     * Limit how many Jobs to delete.
     */
    limit?: number
  }

  /**
   * Job.executionLogs
   */
  export type Job$executionLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExecutionLog
     */
    select?: ExecutionLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExecutionLog
     */
    omit?: ExecutionLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExecutionLogInclude<ExtArgs> | null
    where?: ExecutionLogWhereInput
    orderBy?: ExecutionLogOrderByWithRelationInput | ExecutionLogOrderByWithRelationInput[]
    cursor?: ExecutionLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExecutionLogScalarFieldEnum | ExecutionLogScalarFieldEnum[]
  }

  /**
   * Job.screenshots
   */
  export type Job$screenshotsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExecutionScreenshot
     */
    select?: ExecutionScreenshotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExecutionScreenshot
     */
    omit?: ExecutionScreenshotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExecutionScreenshotInclude<ExtArgs> | null
    where?: ExecutionScreenshotWhereInput
    orderBy?: ExecutionScreenshotOrderByWithRelationInput | ExecutionScreenshotOrderByWithRelationInput[]
    cursor?: ExecutionScreenshotWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExecutionScreenshotScalarFieldEnum | ExecutionScreenshotScalarFieldEnum[]
  }

  /**
   * Job.scheduleExecution
   */
  export type Job$scheduleExecutionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduleExecution
     */
    select?: ScheduleExecutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduleExecution
     */
    omit?: ScheduleExecutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleExecutionInclude<ExtArgs> | null
    where?: ScheduleExecutionWhereInput
  }

  /**
   * Job without action
   */
  export type JobDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Job
     */
    select?: JobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Job
     */
    omit?: JobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobInclude<ExtArgs> | null
  }


  /**
   * Model ExecutionLog
   */

  export type AggregateExecutionLog = {
    _count: ExecutionLogCountAggregateOutputType | null
    _avg: ExecutionLogAvgAggregateOutputType | null
    _sum: ExecutionLogSumAggregateOutputType | null
    _min: ExecutionLogMinAggregateOutputType | null
    _max: ExecutionLogMaxAggregateOutputType | null
  }

  export type ExecutionLogAvgAggregateOutputType = {
    stepIndex: number | null
    duration: number | null
  }

  export type ExecutionLogSumAggregateOutputType = {
    stepIndex: number | null
    duration: number | null
  }

  export type ExecutionLogMinAggregateOutputType = {
    id: string | null
    jobId: string | null
    stepIndex: number | null
    stepName: string | null
    level: $Enums.LogLevel | null
    message: string | null
    timestamp: Date | null
    duration: number | null
  }

  export type ExecutionLogMaxAggregateOutputType = {
    id: string | null
    jobId: string | null
    stepIndex: number | null
    stepName: string | null
    level: $Enums.LogLevel | null
    message: string | null
    timestamp: Date | null
    duration: number | null
  }

  export type ExecutionLogCountAggregateOutputType = {
    id: number
    jobId: number
    stepIndex: number
    stepName: number
    level: number
    message: number
    metadata: number
    timestamp: number
    duration: number
    _all: number
  }


  export type ExecutionLogAvgAggregateInputType = {
    stepIndex?: true
    duration?: true
  }

  export type ExecutionLogSumAggregateInputType = {
    stepIndex?: true
    duration?: true
  }

  export type ExecutionLogMinAggregateInputType = {
    id?: true
    jobId?: true
    stepIndex?: true
    stepName?: true
    level?: true
    message?: true
    timestamp?: true
    duration?: true
  }

  export type ExecutionLogMaxAggregateInputType = {
    id?: true
    jobId?: true
    stepIndex?: true
    stepName?: true
    level?: true
    message?: true
    timestamp?: true
    duration?: true
  }

  export type ExecutionLogCountAggregateInputType = {
    id?: true
    jobId?: true
    stepIndex?: true
    stepName?: true
    level?: true
    message?: true
    metadata?: true
    timestamp?: true
    duration?: true
    _all?: true
  }

  export type ExecutionLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExecutionLog to aggregate.
     */
    where?: ExecutionLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExecutionLogs to fetch.
     */
    orderBy?: ExecutionLogOrderByWithRelationInput | ExecutionLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ExecutionLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExecutionLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExecutionLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ExecutionLogs
    **/
    _count?: true | ExecutionLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ExecutionLogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ExecutionLogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExecutionLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExecutionLogMaxAggregateInputType
  }

  export type GetExecutionLogAggregateType<T extends ExecutionLogAggregateArgs> = {
        [P in keyof T & keyof AggregateExecutionLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExecutionLog[P]>
      : GetScalarType<T[P], AggregateExecutionLog[P]>
  }




  export type ExecutionLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExecutionLogWhereInput
    orderBy?: ExecutionLogOrderByWithAggregationInput | ExecutionLogOrderByWithAggregationInput[]
    by: ExecutionLogScalarFieldEnum[] | ExecutionLogScalarFieldEnum
    having?: ExecutionLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExecutionLogCountAggregateInputType | true
    _avg?: ExecutionLogAvgAggregateInputType
    _sum?: ExecutionLogSumAggregateInputType
    _min?: ExecutionLogMinAggregateInputType
    _max?: ExecutionLogMaxAggregateInputType
  }

  export type ExecutionLogGroupByOutputType = {
    id: string
    jobId: string
    stepIndex: number
    stepName: string | null
    level: $Enums.LogLevel
    message: string
    metadata: JsonValue | null
    timestamp: Date
    duration: number | null
    _count: ExecutionLogCountAggregateOutputType | null
    _avg: ExecutionLogAvgAggregateOutputType | null
    _sum: ExecutionLogSumAggregateOutputType | null
    _min: ExecutionLogMinAggregateOutputType | null
    _max: ExecutionLogMaxAggregateOutputType | null
  }

  type GetExecutionLogGroupByPayload<T extends ExecutionLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ExecutionLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExecutionLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExecutionLogGroupByOutputType[P]>
            : GetScalarType<T[P], ExecutionLogGroupByOutputType[P]>
        }
      >
    >


  export type ExecutionLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    jobId?: boolean
    stepIndex?: boolean
    stepName?: boolean
    level?: boolean
    message?: boolean
    metadata?: boolean
    timestamp?: boolean
    duration?: boolean
    job?: boolean | JobDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["executionLog"]>

  export type ExecutionLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    jobId?: boolean
    stepIndex?: boolean
    stepName?: boolean
    level?: boolean
    message?: boolean
    metadata?: boolean
    timestamp?: boolean
    duration?: boolean
    job?: boolean | JobDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["executionLog"]>

  export type ExecutionLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    jobId?: boolean
    stepIndex?: boolean
    stepName?: boolean
    level?: boolean
    message?: boolean
    metadata?: boolean
    timestamp?: boolean
    duration?: boolean
    job?: boolean | JobDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["executionLog"]>

  export type ExecutionLogSelectScalar = {
    id?: boolean
    jobId?: boolean
    stepIndex?: boolean
    stepName?: boolean
    level?: boolean
    message?: boolean
    metadata?: boolean
    timestamp?: boolean
    duration?: boolean
  }

  export type ExecutionLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "jobId" | "stepIndex" | "stepName" | "level" | "message" | "metadata" | "timestamp" | "duration", ExtArgs["result"]["executionLog"]>
  export type ExecutionLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    job?: boolean | JobDefaultArgs<ExtArgs>
  }
  export type ExecutionLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    job?: boolean | JobDefaultArgs<ExtArgs>
  }
  export type ExecutionLogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    job?: boolean | JobDefaultArgs<ExtArgs>
  }

  export type $ExecutionLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ExecutionLog"
    objects: {
      job: Prisma.$JobPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      jobId: string
      stepIndex: number
      stepName: string | null
      level: $Enums.LogLevel
      message: string
      metadata: Prisma.JsonValue | null
      timestamp: Date
      duration: number | null
    }, ExtArgs["result"]["executionLog"]>
    composites: {}
  }

  type ExecutionLogGetPayload<S extends boolean | null | undefined | ExecutionLogDefaultArgs> = $Result.GetResult<Prisma.$ExecutionLogPayload, S>

  type ExecutionLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ExecutionLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ExecutionLogCountAggregateInputType | true
    }

  export interface ExecutionLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ExecutionLog'], meta: { name: 'ExecutionLog' } }
    /**
     * Find zero or one ExecutionLog that matches the filter.
     * @param {ExecutionLogFindUniqueArgs} args - Arguments to find a ExecutionLog
     * @example
     * // Get one ExecutionLog
     * const executionLog = await prisma.executionLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ExecutionLogFindUniqueArgs>(args: SelectSubset<T, ExecutionLogFindUniqueArgs<ExtArgs>>): Prisma__ExecutionLogClient<$Result.GetResult<Prisma.$ExecutionLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ExecutionLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ExecutionLogFindUniqueOrThrowArgs} args - Arguments to find a ExecutionLog
     * @example
     * // Get one ExecutionLog
     * const executionLog = await prisma.executionLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ExecutionLogFindUniqueOrThrowArgs>(args: SelectSubset<T, ExecutionLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ExecutionLogClient<$Result.GetResult<Prisma.$ExecutionLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ExecutionLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExecutionLogFindFirstArgs} args - Arguments to find a ExecutionLog
     * @example
     * // Get one ExecutionLog
     * const executionLog = await prisma.executionLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ExecutionLogFindFirstArgs>(args?: SelectSubset<T, ExecutionLogFindFirstArgs<ExtArgs>>): Prisma__ExecutionLogClient<$Result.GetResult<Prisma.$ExecutionLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ExecutionLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExecutionLogFindFirstOrThrowArgs} args - Arguments to find a ExecutionLog
     * @example
     * // Get one ExecutionLog
     * const executionLog = await prisma.executionLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ExecutionLogFindFirstOrThrowArgs>(args?: SelectSubset<T, ExecutionLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__ExecutionLogClient<$Result.GetResult<Prisma.$ExecutionLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ExecutionLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExecutionLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ExecutionLogs
     * const executionLogs = await prisma.executionLog.findMany()
     * 
     * // Get first 10 ExecutionLogs
     * const executionLogs = await prisma.executionLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const executionLogWithIdOnly = await prisma.executionLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ExecutionLogFindManyArgs>(args?: SelectSubset<T, ExecutionLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExecutionLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ExecutionLog.
     * @param {ExecutionLogCreateArgs} args - Arguments to create a ExecutionLog.
     * @example
     * // Create one ExecutionLog
     * const ExecutionLog = await prisma.executionLog.create({
     *   data: {
     *     // ... data to create a ExecutionLog
     *   }
     * })
     * 
     */
    create<T extends ExecutionLogCreateArgs>(args: SelectSubset<T, ExecutionLogCreateArgs<ExtArgs>>): Prisma__ExecutionLogClient<$Result.GetResult<Prisma.$ExecutionLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ExecutionLogs.
     * @param {ExecutionLogCreateManyArgs} args - Arguments to create many ExecutionLogs.
     * @example
     * // Create many ExecutionLogs
     * const executionLog = await prisma.executionLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ExecutionLogCreateManyArgs>(args?: SelectSubset<T, ExecutionLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ExecutionLogs and returns the data saved in the database.
     * @param {ExecutionLogCreateManyAndReturnArgs} args - Arguments to create many ExecutionLogs.
     * @example
     * // Create many ExecutionLogs
     * const executionLog = await prisma.executionLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ExecutionLogs and only return the `id`
     * const executionLogWithIdOnly = await prisma.executionLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ExecutionLogCreateManyAndReturnArgs>(args?: SelectSubset<T, ExecutionLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExecutionLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ExecutionLog.
     * @param {ExecutionLogDeleteArgs} args - Arguments to delete one ExecutionLog.
     * @example
     * // Delete one ExecutionLog
     * const ExecutionLog = await prisma.executionLog.delete({
     *   where: {
     *     // ... filter to delete one ExecutionLog
     *   }
     * })
     * 
     */
    delete<T extends ExecutionLogDeleteArgs>(args: SelectSubset<T, ExecutionLogDeleteArgs<ExtArgs>>): Prisma__ExecutionLogClient<$Result.GetResult<Prisma.$ExecutionLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ExecutionLog.
     * @param {ExecutionLogUpdateArgs} args - Arguments to update one ExecutionLog.
     * @example
     * // Update one ExecutionLog
     * const executionLog = await prisma.executionLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ExecutionLogUpdateArgs>(args: SelectSubset<T, ExecutionLogUpdateArgs<ExtArgs>>): Prisma__ExecutionLogClient<$Result.GetResult<Prisma.$ExecutionLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ExecutionLogs.
     * @param {ExecutionLogDeleteManyArgs} args - Arguments to filter ExecutionLogs to delete.
     * @example
     * // Delete a few ExecutionLogs
     * const { count } = await prisma.executionLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ExecutionLogDeleteManyArgs>(args?: SelectSubset<T, ExecutionLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ExecutionLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExecutionLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ExecutionLogs
     * const executionLog = await prisma.executionLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ExecutionLogUpdateManyArgs>(args: SelectSubset<T, ExecutionLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ExecutionLogs and returns the data updated in the database.
     * @param {ExecutionLogUpdateManyAndReturnArgs} args - Arguments to update many ExecutionLogs.
     * @example
     * // Update many ExecutionLogs
     * const executionLog = await prisma.executionLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ExecutionLogs and only return the `id`
     * const executionLogWithIdOnly = await prisma.executionLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ExecutionLogUpdateManyAndReturnArgs>(args: SelectSubset<T, ExecutionLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExecutionLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ExecutionLog.
     * @param {ExecutionLogUpsertArgs} args - Arguments to update or create a ExecutionLog.
     * @example
     * // Update or create a ExecutionLog
     * const executionLog = await prisma.executionLog.upsert({
     *   create: {
     *     // ... data to create a ExecutionLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ExecutionLog we want to update
     *   }
     * })
     */
    upsert<T extends ExecutionLogUpsertArgs>(args: SelectSubset<T, ExecutionLogUpsertArgs<ExtArgs>>): Prisma__ExecutionLogClient<$Result.GetResult<Prisma.$ExecutionLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ExecutionLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExecutionLogCountArgs} args - Arguments to filter ExecutionLogs to count.
     * @example
     * // Count the number of ExecutionLogs
     * const count = await prisma.executionLog.count({
     *   where: {
     *     // ... the filter for the ExecutionLogs we want to count
     *   }
     * })
    **/
    count<T extends ExecutionLogCountArgs>(
      args?: Subset<T, ExecutionLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExecutionLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ExecutionLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExecutionLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExecutionLogAggregateArgs>(args: Subset<T, ExecutionLogAggregateArgs>): Prisma.PrismaPromise<GetExecutionLogAggregateType<T>>

    /**
     * Group by ExecutionLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExecutionLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ExecutionLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExecutionLogGroupByArgs['orderBy'] }
        : { orderBy?: ExecutionLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ExecutionLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExecutionLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ExecutionLog model
   */
  readonly fields: ExecutionLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ExecutionLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ExecutionLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    job<T extends JobDefaultArgs<ExtArgs> = {}>(args?: Subset<T, JobDefaultArgs<ExtArgs>>): Prisma__JobClient<$Result.GetResult<Prisma.$JobPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ExecutionLog model
   */
  interface ExecutionLogFieldRefs {
    readonly id: FieldRef<"ExecutionLog", 'String'>
    readonly jobId: FieldRef<"ExecutionLog", 'String'>
    readonly stepIndex: FieldRef<"ExecutionLog", 'Int'>
    readonly stepName: FieldRef<"ExecutionLog", 'String'>
    readonly level: FieldRef<"ExecutionLog", 'LogLevel'>
    readonly message: FieldRef<"ExecutionLog", 'String'>
    readonly metadata: FieldRef<"ExecutionLog", 'Json'>
    readonly timestamp: FieldRef<"ExecutionLog", 'DateTime'>
    readonly duration: FieldRef<"ExecutionLog", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * ExecutionLog findUnique
   */
  export type ExecutionLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExecutionLog
     */
    select?: ExecutionLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExecutionLog
     */
    omit?: ExecutionLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExecutionLogInclude<ExtArgs> | null
    /**
     * Filter, which ExecutionLog to fetch.
     */
    where: ExecutionLogWhereUniqueInput
  }

  /**
   * ExecutionLog findUniqueOrThrow
   */
  export type ExecutionLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExecutionLog
     */
    select?: ExecutionLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExecutionLog
     */
    omit?: ExecutionLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExecutionLogInclude<ExtArgs> | null
    /**
     * Filter, which ExecutionLog to fetch.
     */
    where: ExecutionLogWhereUniqueInput
  }

  /**
   * ExecutionLog findFirst
   */
  export type ExecutionLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExecutionLog
     */
    select?: ExecutionLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExecutionLog
     */
    omit?: ExecutionLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExecutionLogInclude<ExtArgs> | null
    /**
     * Filter, which ExecutionLog to fetch.
     */
    where?: ExecutionLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExecutionLogs to fetch.
     */
    orderBy?: ExecutionLogOrderByWithRelationInput | ExecutionLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExecutionLogs.
     */
    cursor?: ExecutionLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExecutionLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExecutionLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExecutionLogs.
     */
    distinct?: ExecutionLogScalarFieldEnum | ExecutionLogScalarFieldEnum[]
  }

  /**
   * ExecutionLog findFirstOrThrow
   */
  export type ExecutionLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExecutionLog
     */
    select?: ExecutionLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExecutionLog
     */
    omit?: ExecutionLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExecutionLogInclude<ExtArgs> | null
    /**
     * Filter, which ExecutionLog to fetch.
     */
    where?: ExecutionLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExecutionLogs to fetch.
     */
    orderBy?: ExecutionLogOrderByWithRelationInput | ExecutionLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExecutionLogs.
     */
    cursor?: ExecutionLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExecutionLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExecutionLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExecutionLogs.
     */
    distinct?: ExecutionLogScalarFieldEnum | ExecutionLogScalarFieldEnum[]
  }

  /**
   * ExecutionLog findMany
   */
  export type ExecutionLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExecutionLog
     */
    select?: ExecutionLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExecutionLog
     */
    omit?: ExecutionLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExecutionLogInclude<ExtArgs> | null
    /**
     * Filter, which ExecutionLogs to fetch.
     */
    where?: ExecutionLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExecutionLogs to fetch.
     */
    orderBy?: ExecutionLogOrderByWithRelationInput | ExecutionLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ExecutionLogs.
     */
    cursor?: ExecutionLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExecutionLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExecutionLogs.
     */
    skip?: number
    distinct?: ExecutionLogScalarFieldEnum | ExecutionLogScalarFieldEnum[]
  }

  /**
   * ExecutionLog create
   */
  export type ExecutionLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExecutionLog
     */
    select?: ExecutionLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExecutionLog
     */
    omit?: ExecutionLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExecutionLogInclude<ExtArgs> | null
    /**
     * The data needed to create a ExecutionLog.
     */
    data: XOR<ExecutionLogCreateInput, ExecutionLogUncheckedCreateInput>
  }

  /**
   * ExecutionLog createMany
   */
  export type ExecutionLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ExecutionLogs.
     */
    data: ExecutionLogCreateManyInput | ExecutionLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ExecutionLog createManyAndReturn
   */
  export type ExecutionLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExecutionLog
     */
    select?: ExecutionLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ExecutionLog
     */
    omit?: ExecutionLogOmit<ExtArgs> | null
    /**
     * The data used to create many ExecutionLogs.
     */
    data: ExecutionLogCreateManyInput | ExecutionLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExecutionLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ExecutionLog update
   */
  export type ExecutionLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExecutionLog
     */
    select?: ExecutionLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExecutionLog
     */
    omit?: ExecutionLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExecutionLogInclude<ExtArgs> | null
    /**
     * The data needed to update a ExecutionLog.
     */
    data: XOR<ExecutionLogUpdateInput, ExecutionLogUncheckedUpdateInput>
    /**
     * Choose, which ExecutionLog to update.
     */
    where: ExecutionLogWhereUniqueInput
  }

  /**
   * ExecutionLog updateMany
   */
  export type ExecutionLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ExecutionLogs.
     */
    data: XOR<ExecutionLogUpdateManyMutationInput, ExecutionLogUncheckedUpdateManyInput>
    /**
     * Filter which ExecutionLogs to update
     */
    where?: ExecutionLogWhereInput
    /**
     * Limit how many ExecutionLogs to update.
     */
    limit?: number
  }

  /**
   * ExecutionLog updateManyAndReturn
   */
  export type ExecutionLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExecutionLog
     */
    select?: ExecutionLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ExecutionLog
     */
    omit?: ExecutionLogOmit<ExtArgs> | null
    /**
     * The data used to update ExecutionLogs.
     */
    data: XOR<ExecutionLogUpdateManyMutationInput, ExecutionLogUncheckedUpdateManyInput>
    /**
     * Filter which ExecutionLogs to update
     */
    where?: ExecutionLogWhereInput
    /**
     * Limit how many ExecutionLogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExecutionLogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ExecutionLog upsert
   */
  export type ExecutionLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExecutionLog
     */
    select?: ExecutionLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExecutionLog
     */
    omit?: ExecutionLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExecutionLogInclude<ExtArgs> | null
    /**
     * The filter to search for the ExecutionLog to update in case it exists.
     */
    where: ExecutionLogWhereUniqueInput
    /**
     * In case the ExecutionLog found by the `where` argument doesn't exist, create a new ExecutionLog with this data.
     */
    create: XOR<ExecutionLogCreateInput, ExecutionLogUncheckedCreateInput>
    /**
     * In case the ExecutionLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ExecutionLogUpdateInput, ExecutionLogUncheckedUpdateInput>
  }

  /**
   * ExecutionLog delete
   */
  export type ExecutionLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExecutionLog
     */
    select?: ExecutionLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExecutionLog
     */
    omit?: ExecutionLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExecutionLogInclude<ExtArgs> | null
    /**
     * Filter which ExecutionLog to delete.
     */
    where: ExecutionLogWhereUniqueInput
  }

  /**
   * ExecutionLog deleteMany
   */
  export type ExecutionLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExecutionLogs to delete
     */
    where?: ExecutionLogWhereInput
    /**
     * Limit how many ExecutionLogs to delete.
     */
    limit?: number
  }

  /**
   * ExecutionLog without action
   */
  export type ExecutionLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExecutionLog
     */
    select?: ExecutionLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExecutionLog
     */
    omit?: ExecutionLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExecutionLogInclude<ExtArgs> | null
  }


  /**
   * Model ExecutionScreenshot
   */

  export type AggregateExecutionScreenshot = {
    _count: ExecutionScreenshotCountAggregateOutputType | null
    _avg: ExecutionScreenshotAvgAggregateOutputType | null
    _sum: ExecutionScreenshotSumAggregateOutputType | null
    _min: ExecutionScreenshotMinAggregateOutputType | null
    _max: ExecutionScreenshotMaxAggregateOutputType | null
  }

  export type ExecutionScreenshotAvgAggregateOutputType = {
    stepIndex: number | null
    size: number | null
    width: number | null
    height: number | null
    originalSize: number | null
    compressionRatio: number | null
  }

  export type ExecutionScreenshotSumAggregateOutputType = {
    stepIndex: number | null
    size: number | null
    width: number | null
    height: number | null
    originalSize: number | null
    compressionRatio: number | null
  }

  export type ExecutionScreenshotMinAggregateOutputType = {
    id: string | null
    jobId: string | null
    stepIndex: number | null
    stepName: string | null
    screenshotType: $Enums.ScreenshotType | null
    blobUrl: string | null
    signedUrl: string | null
    size: number | null
    width: number | null
    height: number | null
    format: string | null
    isCompressed: boolean | null
    originalSize: number | null
    compressionRatio: number | null
    capturedAt: Date | null
    expiresAt: Date | null
  }

  export type ExecutionScreenshotMaxAggregateOutputType = {
    id: string | null
    jobId: string | null
    stepIndex: number | null
    stepName: string | null
    screenshotType: $Enums.ScreenshotType | null
    blobUrl: string | null
    signedUrl: string | null
    size: number | null
    width: number | null
    height: number | null
    format: string | null
    isCompressed: boolean | null
    originalSize: number | null
    compressionRatio: number | null
    capturedAt: Date | null
    expiresAt: Date | null
  }

  export type ExecutionScreenshotCountAggregateOutputType = {
    id: number
    jobId: number
    stepIndex: number
    stepName: number
    screenshotType: number
    blobUrl: number
    signedUrl: number
    size: number
    width: number
    height: number
    format: number
    isCompressed: number
    originalSize: number
    compressionRatio: number
    metadata: number
    capturedAt: number
    expiresAt: number
    _all: number
  }


  export type ExecutionScreenshotAvgAggregateInputType = {
    stepIndex?: true
    size?: true
    width?: true
    height?: true
    originalSize?: true
    compressionRatio?: true
  }

  export type ExecutionScreenshotSumAggregateInputType = {
    stepIndex?: true
    size?: true
    width?: true
    height?: true
    originalSize?: true
    compressionRatio?: true
  }

  export type ExecutionScreenshotMinAggregateInputType = {
    id?: true
    jobId?: true
    stepIndex?: true
    stepName?: true
    screenshotType?: true
    blobUrl?: true
    signedUrl?: true
    size?: true
    width?: true
    height?: true
    format?: true
    isCompressed?: true
    originalSize?: true
    compressionRatio?: true
    capturedAt?: true
    expiresAt?: true
  }

  export type ExecutionScreenshotMaxAggregateInputType = {
    id?: true
    jobId?: true
    stepIndex?: true
    stepName?: true
    screenshotType?: true
    blobUrl?: true
    signedUrl?: true
    size?: true
    width?: true
    height?: true
    format?: true
    isCompressed?: true
    originalSize?: true
    compressionRatio?: true
    capturedAt?: true
    expiresAt?: true
  }

  export type ExecutionScreenshotCountAggregateInputType = {
    id?: true
    jobId?: true
    stepIndex?: true
    stepName?: true
    screenshotType?: true
    blobUrl?: true
    signedUrl?: true
    size?: true
    width?: true
    height?: true
    format?: true
    isCompressed?: true
    originalSize?: true
    compressionRatio?: true
    metadata?: true
    capturedAt?: true
    expiresAt?: true
    _all?: true
  }

  export type ExecutionScreenshotAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExecutionScreenshot to aggregate.
     */
    where?: ExecutionScreenshotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExecutionScreenshots to fetch.
     */
    orderBy?: ExecutionScreenshotOrderByWithRelationInput | ExecutionScreenshotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ExecutionScreenshotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExecutionScreenshots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExecutionScreenshots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ExecutionScreenshots
    **/
    _count?: true | ExecutionScreenshotCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ExecutionScreenshotAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ExecutionScreenshotSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExecutionScreenshotMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExecutionScreenshotMaxAggregateInputType
  }

  export type GetExecutionScreenshotAggregateType<T extends ExecutionScreenshotAggregateArgs> = {
        [P in keyof T & keyof AggregateExecutionScreenshot]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExecutionScreenshot[P]>
      : GetScalarType<T[P], AggregateExecutionScreenshot[P]>
  }




  export type ExecutionScreenshotGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExecutionScreenshotWhereInput
    orderBy?: ExecutionScreenshotOrderByWithAggregationInput | ExecutionScreenshotOrderByWithAggregationInput[]
    by: ExecutionScreenshotScalarFieldEnum[] | ExecutionScreenshotScalarFieldEnum
    having?: ExecutionScreenshotScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExecutionScreenshotCountAggregateInputType | true
    _avg?: ExecutionScreenshotAvgAggregateInputType
    _sum?: ExecutionScreenshotSumAggregateInputType
    _min?: ExecutionScreenshotMinAggregateInputType
    _max?: ExecutionScreenshotMaxAggregateInputType
  }

  export type ExecutionScreenshotGroupByOutputType = {
    id: string
    jobId: string
    stepIndex: number
    stepName: string | null
    screenshotType: $Enums.ScreenshotType
    blobUrl: string
    signedUrl: string | null
    size: number
    width: number
    height: number
    format: string
    isCompressed: boolean
    originalSize: number | null
    compressionRatio: number | null
    metadata: JsonValue | null
    capturedAt: Date
    expiresAt: Date | null
    _count: ExecutionScreenshotCountAggregateOutputType | null
    _avg: ExecutionScreenshotAvgAggregateOutputType | null
    _sum: ExecutionScreenshotSumAggregateOutputType | null
    _min: ExecutionScreenshotMinAggregateOutputType | null
    _max: ExecutionScreenshotMaxAggregateOutputType | null
  }

  type GetExecutionScreenshotGroupByPayload<T extends ExecutionScreenshotGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ExecutionScreenshotGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExecutionScreenshotGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExecutionScreenshotGroupByOutputType[P]>
            : GetScalarType<T[P], ExecutionScreenshotGroupByOutputType[P]>
        }
      >
    >


  export type ExecutionScreenshotSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    jobId?: boolean
    stepIndex?: boolean
    stepName?: boolean
    screenshotType?: boolean
    blobUrl?: boolean
    signedUrl?: boolean
    size?: boolean
    width?: boolean
    height?: boolean
    format?: boolean
    isCompressed?: boolean
    originalSize?: boolean
    compressionRatio?: boolean
    metadata?: boolean
    capturedAt?: boolean
    expiresAt?: boolean
    job?: boolean | JobDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["executionScreenshot"]>

  export type ExecutionScreenshotSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    jobId?: boolean
    stepIndex?: boolean
    stepName?: boolean
    screenshotType?: boolean
    blobUrl?: boolean
    signedUrl?: boolean
    size?: boolean
    width?: boolean
    height?: boolean
    format?: boolean
    isCompressed?: boolean
    originalSize?: boolean
    compressionRatio?: boolean
    metadata?: boolean
    capturedAt?: boolean
    expiresAt?: boolean
    job?: boolean | JobDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["executionScreenshot"]>

  export type ExecutionScreenshotSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    jobId?: boolean
    stepIndex?: boolean
    stepName?: boolean
    screenshotType?: boolean
    blobUrl?: boolean
    signedUrl?: boolean
    size?: boolean
    width?: boolean
    height?: boolean
    format?: boolean
    isCompressed?: boolean
    originalSize?: boolean
    compressionRatio?: boolean
    metadata?: boolean
    capturedAt?: boolean
    expiresAt?: boolean
    job?: boolean | JobDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["executionScreenshot"]>

  export type ExecutionScreenshotSelectScalar = {
    id?: boolean
    jobId?: boolean
    stepIndex?: boolean
    stepName?: boolean
    screenshotType?: boolean
    blobUrl?: boolean
    signedUrl?: boolean
    size?: boolean
    width?: boolean
    height?: boolean
    format?: boolean
    isCompressed?: boolean
    originalSize?: boolean
    compressionRatio?: boolean
    metadata?: boolean
    capturedAt?: boolean
    expiresAt?: boolean
  }

  export type ExecutionScreenshotOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "jobId" | "stepIndex" | "stepName" | "screenshotType" | "blobUrl" | "signedUrl" | "size" | "width" | "height" | "format" | "isCompressed" | "originalSize" | "compressionRatio" | "metadata" | "capturedAt" | "expiresAt", ExtArgs["result"]["executionScreenshot"]>
  export type ExecutionScreenshotInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    job?: boolean | JobDefaultArgs<ExtArgs>
  }
  export type ExecutionScreenshotIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    job?: boolean | JobDefaultArgs<ExtArgs>
  }
  export type ExecutionScreenshotIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    job?: boolean | JobDefaultArgs<ExtArgs>
  }

  export type $ExecutionScreenshotPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ExecutionScreenshot"
    objects: {
      job: Prisma.$JobPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      jobId: string
      stepIndex: number
      stepName: string | null
      screenshotType: $Enums.ScreenshotType
      blobUrl: string
      signedUrl: string | null
      size: number
      width: number
      height: number
      format: string
      isCompressed: boolean
      originalSize: number | null
      compressionRatio: number | null
      metadata: Prisma.JsonValue | null
      capturedAt: Date
      expiresAt: Date | null
    }, ExtArgs["result"]["executionScreenshot"]>
    composites: {}
  }

  type ExecutionScreenshotGetPayload<S extends boolean | null | undefined | ExecutionScreenshotDefaultArgs> = $Result.GetResult<Prisma.$ExecutionScreenshotPayload, S>

  type ExecutionScreenshotCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ExecutionScreenshotFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ExecutionScreenshotCountAggregateInputType | true
    }

  export interface ExecutionScreenshotDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ExecutionScreenshot'], meta: { name: 'ExecutionScreenshot' } }
    /**
     * Find zero or one ExecutionScreenshot that matches the filter.
     * @param {ExecutionScreenshotFindUniqueArgs} args - Arguments to find a ExecutionScreenshot
     * @example
     * // Get one ExecutionScreenshot
     * const executionScreenshot = await prisma.executionScreenshot.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ExecutionScreenshotFindUniqueArgs>(args: SelectSubset<T, ExecutionScreenshotFindUniqueArgs<ExtArgs>>): Prisma__ExecutionScreenshotClient<$Result.GetResult<Prisma.$ExecutionScreenshotPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ExecutionScreenshot that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ExecutionScreenshotFindUniqueOrThrowArgs} args - Arguments to find a ExecutionScreenshot
     * @example
     * // Get one ExecutionScreenshot
     * const executionScreenshot = await prisma.executionScreenshot.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ExecutionScreenshotFindUniqueOrThrowArgs>(args: SelectSubset<T, ExecutionScreenshotFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ExecutionScreenshotClient<$Result.GetResult<Prisma.$ExecutionScreenshotPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ExecutionScreenshot that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExecutionScreenshotFindFirstArgs} args - Arguments to find a ExecutionScreenshot
     * @example
     * // Get one ExecutionScreenshot
     * const executionScreenshot = await prisma.executionScreenshot.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ExecutionScreenshotFindFirstArgs>(args?: SelectSubset<T, ExecutionScreenshotFindFirstArgs<ExtArgs>>): Prisma__ExecutionScreenshotClient<$Result.GetResult<Prisma.$ExecutionScreenshotPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ExecutionScreenshot that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExecutionScreenshotFindFirstOrThrowArgs} args - Arguments to find a ExecutionScreenshot
     * @example
     * // Get one ExecutionScreenshot
     * const executionScreenshot = await prisma.executionScreenshot.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ExecutionScreenshotFindFirstOrThrowArgs>(args?: SelectSubset<T, ExecutionScreenshotFindFirstOrThrowArgs<ExtArgs>>): Prisma__ExecutionScreenshotClient<$Result.GetResult<Prisma.$ExecutionScreenshotPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ExecutionScreenshots that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExecutionScreenshotFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ExecutionScreenshots
     * const executionScreenshots = await prisma.executionScreenshot.findMany()
     * 
     * // Get first 10 ExecutionScreenshots
     * const executionScreenshots = await prisma.executionScreenshot.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const executionScreenshotWithIdOnly = await prisma.executionScreenshot.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ExecutionScreenshotFindManyArgs>(args?: SelectSubset<T, ExecutionScreenshotFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExecutionScreenshotPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ExecutionScreenshot.
     * @param {ExecutionScreenshotCreateArgs} args - Arguments to create a ExecutionScreenshot.
     * @example
     * // Create one ExecutionScreenshot
     * const ExecutionScreenshot = await prisma.executionScreenshot.create({
     *   data: {
     *     // ... data to create a ExecutionScreenshot
     *   }
     * })
     * 
     */
    create<T extends ExecutionScreenshotCreateArgs>(args: SelectSubset<T, ExecutionScreenshotCreateArgs<ExtArgs>>): Prisma__ExecutionScreenshotClient<$Result.GetResult<Prisma.$ExecutionScreenshotPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ExecutionScreenshots.
     * @param {ExecutionScreenshotCreateManyArgs} args - Arguments to create many ExecutionScreenshots.
     * @example
     * // Create many ExecutionScreenshots
     * const executionScreenshot = await prisma.executionScreenshot.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ExecutionScreenshotCreateManyArgs>(args?: SelectSubset<T, ExecutionScreenshotCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ExecutionScreenshots and returns the data saved in the database.
     * @param {ExecutionScreenshotCreateManyAndReturnArgs} args - Arguments to create many ExecutionScreenshots.
     * @example
     * // Create many ExecutionScreenshots
     * const executionScreenshot = await prisma.executionScreenshot.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ExecutionScreenshots and only return the `id`
     * const executionScreenshotWithIdOnly = await prisma.executionScreenshot.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ExecutionScreenshotCreateManyAndReturnArgs>(args?: SelectSubset<T, ExecutionScreenshotCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExecutionScreenshotPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ExecutionScreenshot.
     * @param {ExecutionScreenshotDeleteArgs} args - Arguments to delete one ExecutionScreenshot.
     * @example
     * // Delete one ExecutionScreenshot
     * const ExecutionScreenshot = await prisma.executionScreenshot.delete({
     *   where: {
     *     // ... filter to delete one ExecutionScreenshot
     *   }
     * })
     * 
     */
    delete<T extends ExecutionScreenshotDeleteArgs>(args: SelectSubset<T, ExecutionScreenshotDeleteArgs<ExtArgs>>): Prisma__ExecutionScreenshotClient<$Result.GetResult<Prisma.$ExecutionScreenshotPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ExecutionScreenshot.
     * @param {ExecutionScreenshotUpdateArgs} args - Arguments to update one ExecutionScreenshot.
     * @example
     * // Update one ExecutionScreenshot
     * const executionScreenshot = await prisma.executionScreenshot.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ExecutionScreenshotUpdateArgs>(args: SelectSubset<T, ExecutionScreenshotUpdateArgs<ExtArgs>>): Prisma__ExecutionScreenshotClient<$Result.GetResult<Prisma.$ExecutionScreenshotPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ExecutionScreenshots.
     * @param {ExecutionScreenshotDeleteManyArgs} args - Arguments to filter ExecutionScreenshots to delete.
     * @example
     * // Delete a few ExecutionScreenshots
     * const { count } = await prisma.executionScreenshot.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ExecutionScreenshotDeleteManyArgs>(args?: SelectSubset<T, ExecutionScreenshotDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ExecutionScreenshots.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExecutionScreenshotUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ExecutionScreenshots
     * const executionScreenshot = await prisma.executionScreenshot.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ExecutionScreenshotUpdateManyArgs>(args: SelectSubset<T, ExecutionScreenshotUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ExecutionScreenshots and returns the data updated in the database.
     * @param {ExecutionScreenshotUpdateManyAndReturnArgs} args - Arguments to update many ExecutionScreenshots.
     * @example
     * // Update many ExecutionScreenshots
     * const executionScreenshot = await prisma.executionScreenshot.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ExecutionScreenshots and only return the `id`
     * const executionScreenshotWithIdOnly = await prisma.executionScreenshot.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ExecutionScreenshotUpdateManyAndReturnArgs>(args: SelectSubset<T, ExecutionScreenshotUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExecutionScreenshotPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ExecutionScreenshot.
     * @param {ExecutionScreenshotUpsertArgs} args - Arguments to update or create a ExecutionScreenshot.
     * @example
     * // Update or create a ExecutionScreenshot
     * const executionScreenshot = await prisma.executionScreenshot.upsert({
     *   create: {
     *     // ... data to create a ExecutionScreenshot
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ExecutionScreenshot we want to update
     *   }
     * })
     */
    upsert<T extends ExecutionScreenshotUpsertArgs>(args: SelectSubset<T, ExecutionScreenshotUpsertArgs<ExtArgs>>): Prisma__ExecutionScreenshotClient<$Result.GetResult<Prisma.$ExecutionScreenshotPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ExecutionScreenshots.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExecutionScreenshotCountArgs} args - Arguments to filter ExecutionScreenshots to count.
     * @example
     * // Count the number of ExecutionScreenshots
     * const count = await prisma.executionScreenshot.count({
     *   where: {
     *     // ... the filter for the ExecutionScreenshots we want to count
     *   }
     * })
    **/
    count<T extends ExecutionScreenshotCountArgs>(
      args?: Subset<T, ExecutionScreenshotCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExecutionScreenshotCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ExecutionScreenshot.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExecutionScreenshotAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExecutionScreenshotAggregateArgs>(args: Subset<T, ExecutionScreenshotAggregateArgs>): Prisma.PrismaPromise<GetExecutionScreenshotAggregateType<T>>

    /**
     * Group by ExecutionScreenshot.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExecutionScreenshotGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ExecutionScreenshotGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExecutionScreenshotGroupByArgs['orderBy'] }
        : { orderBy?: ExecutionScreenshotGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ExecutionScreenshotGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExecutionScreenshotGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ExecutionScreenshot model
   */
  readonly fields: ExecutionScreenshotFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ExecutionScreenshot.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ExecutionScreenshotClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    job<T extends JobDefaultArgs<ExtArgs> = {}>(args?: Subset<T, JobDefaultArgs<ExtArgs>>): Prisma__JobClient<$Result.GetResult<Prisma.$JobPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ExecutionScreenshot model
   */
  interface ExecutionScreenshotFieldRefs {
    readonly id: FieldRef<"ExecutionScreenshot", 'String'>
    readonly jobId: FieldRef<"ExecutionScreenshot", 'String'>
    readonly stepIndex: FieldRef<"ExecutionScreenshot", 'Int'>
    readonly stepName: FieldRef<"ExecutionScreenshot", 'String'>
    readonly screenshotType: FieldRef<"ExecutionScreenshot", 'ScreenshotType'>
    readonly blobUrl: FieldRef<"ExecutionScreenshot", 'String'>
    readonly signedUrl: FieldRef<"ExecutionScreenshot", 'String'>
    readonly size: FieldRef<"ExecutionScreenshot", 'Int'>
    readonly width: FieldRef<"ExecutionScreenshot", 'Int'>
    readonly height: FieldRef<"ExecutionScreenshot", 'Int'>
    readonly format: FieldRef<"ExecutionScreenshot", 'String'>
    readonly isCompressed: FieldRef<"ExecutionScreenshot", 'Boolean'>
    readonly originalSize: FieldRef<"ExecutionScreenshot", 'Int'>
    readonly compressionRatio: FieldRef<"ExecutionScreenshot", 'Float'>
    readonly metadata: FieldRef<"ExecutionScreenshot", 'Json'>
    readonly capturedAt: FieldRef<"ExecutionScreenshot", 'DateTime'>
    readonly expiresAt: FieldRef<"ExecutionScreenshot", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ExecutionScreenshot findUnique
   */
  export type ExecutionScreenshotFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExecutionScreenshot
     */
    select?: ExecutionScreenshotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExecutionScreenshot
     */
    omit?: ExecutionScreenshotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExecutionScreenshotInclude<ExtArgs> | null
    /**
     * Filter, which ExecutionScreenshot to fetch.
     */
    where: ExecutionScreenshotWhereUniqueInput
  }

  /**
   * ExecutionScreenshot findUniqueOrThrow
   */
  export type ExecutionScreenshotFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExecutionScreenshot
     */
    select?: ExecutionScreenshotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExecutionScreenshot
     */
    omit?: ExecutionScreenshotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExecutionScreenshotInclude<ExtArgs> | null
    /**
     * Filter, which ExecutionScreenshot to fetch.
     */
    where: ExecutionScreenshotWhereUniqueInput
  }

  /**
   * ExecutionScreenshot findFirst
   */
  export type ExecutionScreenshotFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExecutionScreenshot
     */
    select?: ExecutionScreenshotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExecutionScreenshot
     */
    omit?: ExecutionScreenshotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExecutionScreenshotInclude<ExtArgs> | null
    /**
     * Filter, which ExecutionScreenshot to fetch.
     */
    where?: ExecutionScreenshotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExecutionScreenshots to fetch.
     */
    orderBy?: ExecutionScreenshotOrderByWithRelationInput | ExecutionScreenshotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExecutionScreenshots.
     */
    cursor?: ExecutionScreenshotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExecutionScreenshots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExecutionScreenshots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExecutionScreenshots.
     */
    distinct?: ExecutionScreenshotScalarFieldEnum | ExecutionScreenshotScalarFieldEnum[]
  }

  /**
   * ExecutionScreenshot findFirstOrThrow
   */
  export type ExecutionScreenshotFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExecutionScreenshot
     */
    select?: ExecutionScreenshotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExecutionScreenshot
     */
    omit?: ExecutionScreenshotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExecutionScreenshotInclude<ExtArgs> | null
    /**
     * Filter, which ExecutionScreenshot to fetch.
     */
    where?: ExecutionScreenshotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExecutionScreenshots to fetch.
     */
    orderBy?: ExecutionScreenshotOrderByWithRelationInput | ExecutionScreenshotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExecutionScreenshots.
     */
    cursor?: ExecutionScreenshotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExecutionScreenshots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExecutionScreenshots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExecutionScreenshots.
     */
    distinct?: ExecutionScreenshotScalarFieldEnum | ExecutionScreenshotScalarFieldEnum[]
  }

  /**
   * ExecutionScreenshot findMany
   */
  export type ExecutionScreenshotFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExecutionScreenshot
     */
    select?: ExecutionScreenshotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExecutionScreenshot
     */
    omit?: ExecutionScreenshotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExecutionScreenshotInclude<ExtArgs> | null
    /**
     * Filter, which ExecutionScreenshots to fetch.
     */
    where?: ExecutionScreenshotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExecutionScreenshots to fetch.
     */
    orderBy?: ExecutionScreenshotOrderByWithRelationInput | ExecutionScreenshotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ExecutionScreenshots.
     */
    cursor?: ExecutionScreenshotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExecutionScreenshots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExecutionScreenshots.
     */
    skip?: number
    distinct?: ExecutionScreenshotScalarFieldEnum | ExecutionScreenshotScalarFieldEnum[]
  }

  /**
   * ExecutionScreenshot create
   */
  export type ExecutionScreenshotCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExecutionScreenshot
     */
    select?: ExecutionScreenshotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExecutionScreenshot
     */
    omit?: ExecutionScreenshotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExecutionScreenshotInclude<ExtArgs> | null
    /**
     * The data needed to create a ExecutionScreenshot.
     */
    data: XOR<ExecutionScreenshotCreateInput, ExecutionScreenshotUncheckedCreateInput>
  }

  /**
   * ExecutionScreenshot createMany
   */
  export type ExecutionScreenshotCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ExecutionScreenshots.
     */
    data: ExecutionScreenshotCreateManyInput | ExecutionScreenshotCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ExecutionScreenshot createManyAndReturn
   */
  export type ExecutionScreenshotCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExecutionScreenshot
     */
    select?: ExecutionScreenshotSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ExecutionScreenshot
     */
    omit?: ExecutionScreenshotOmit<ExtArgs> | null
    /**
     * The data used to create many ExecutionScreenshots.
     */
    data: ExecutionScreenshotCreateManyInput | ExecutionScreenshotCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExecutionScreenshotIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ExecutionScreenshot update
   */
  export type ExecutionScreenshotUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExecutionScreenshot
     */
    select?: ExecutionScreenshotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExecutionScreenshot
     */
    omit?: ExecutionScreenshotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExecutionScreenshotInclude<ExtArgs> | null
    /**
     * The data needed to update a ExecutionScreenshot.
     */
    data: XOR<ExecutionScreenshotUpdateInput, ExecutionScreenshotUncheckedUpdateInput>
    /**
     * Choose, which ExecutionScreenshot to update.
     */
    where: ExecutionScreenshotWhereUniqueInput
  }

  /**
   * ExecutionScreenshot updateMany
   */
  export type ExecutionScreenshotUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ExecutionScreenshots.
     */
    data: XOR<ExecutionScreenshotUpdateManyMutationInput, ExecutionScreenshotUncheckedUpdateManyInput>
    /**
     * Filter which ExecutionScreenshots to update
     */
    where?: ExecutionScreenshotWhereInput
    /**
     * Limit how many ExecutionScreenshots to update.
     */
    limit?: number
  }

  /**
   * ExecutionScreenshot updateManyAndReturn
   */
  export type ExecutionScreenshotUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExecutionScreenshot
     */
    select?: ExecutionScreenshotSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ExecutionScreenshot
     */
    omit?: ExecutionScreenshotOmit<ExtArgs> | null
    /**
     * The data used to update ExecutionScreenshots.
     */
    data: XOR<ExecutionScreenshotUpdateManyMutationInput, ExecutionScreenshotUncheckedUpdateManyInput>
    /**
     * Filter which ExecutionScreenshots to update
     */
    where?: ExecutionScreenshotWhereInput
    /**
     * Limit how many ExecutionScreenshots to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExecutionScreenshotIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ExecutionScreenshot upsert
   */
  export type ExecutionScreenshotUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExecutionScreenshot
     */
    select?: ExecutionScreenshotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExecutionScreenshot
     */
    omit?: ExecutionScreenshotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExecutionScreenshotInclude<ExtArgs> | null
    /**
     * The filter to search for the ExecutionScreenshot to update in case it exists.
     */
    where: ExecutionScreenshotWhereUniqueInput
    /**
     * In case the ExecutionScreenshot found by the `where` argument doesn't exist, create a new ExecutionScreenshot with this data.
     */
    create: XOR<ExecutionScreenshotCreateInput, ExecutionScreenshotUncheckedCreateInput>
    /**
     * In case the ExecutionScreenshot was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ExecutionScreenshotUpdateInput, ExecutionScreenshotUncheckedUpdateInput>
  }

  /**
   * ExecutionScreenshot delete
   */
  export type ExecutionScreenshotDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExecutionScreenshot
     */
    select?: ExecutionScreenshotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExecutionScreenshot
     */
    omit?: ExecutionScreenshotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExecutionScreenshotInclude<ExtArgs> | null
    /**
     * Filter which ExecutionScreenshot to delete.
     */
    where: ExecutionScreenshotWhereUniqueInput
  }

  /**
   * ExecutionScreenshot deleteMany
   */
  export type ExecutionScreenshotDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExecutionScreenshots to delete
     */
    where?: ExecutionScreenshotWhereInput
    /**
     * Limit how many ExecutionScreenshots to delete.
     */
    limit?: number
  }

  /**
   * ExecutionScreenshot without action
   */
  export type ExecutionScreenshotDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExecutionScreenshot
     */
    select?: ExecutionScreenshotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExecutionScreenshot
     */
    omit?: ExecutionScreenshotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExecutionScreenshotInclude<ExtArgs> | null
  }


  /**
   * Model Credential
   */

  export type AggregateCredential = {
    _count: CredentialCountAggregateOutputType | null
    _avg: CredentialAvgAggregateOutputType | null
    _sum: CredentialSumAggregateOutputType | null
    _min: CredentialMinAggregateOutputType | null
    _max: CredentialMaxAggregateOutputType | null
  }

  export type CredentialAvgAggregateOutputType = {
    keyVersion: number | null
    rotationDays: number | null
    accessCount: number | null
  }

  export type CredentialSumAggregateOutputType = {
    keyVersion: number | null
    rotationDays: number | null
    accessCount: number | null
  }

  export type CredentialMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    type: $Enums.CredentialType | null
    encryptedValue: string | null
    iv: string | null
    authTag: string | null
    keyVaultId: string | null
    keyVersion: number | null
    rotationDays: number | null
    lastRotatedAt: Date | null
    nextRotationAt: Date | null
    lastAccessedAt: Date | null
    accessCount: number | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type CredentialMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    type: $Enums.CredentialType | null
    encryptedValue: string | null
    iv: string | null
    authTag: string | null
    keyVaultId: string | null
    keyVersion: number | null
    rotationDays: number | null
    lastRotatedAt: Date | null
    nextRotationAt: Date | null
    lastAccessedAt: Date | null
    accessCount: number | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type CredentialCountAggregateOutputType = {
    id: number
    name: number
    description: number
    type: number
    encryptedValue: number
    iv: number
    authTag: number
    keyVaultId: number
    keyVersion: number
    rotationDays: number
    lastRotatedAt: number
    nextRotationAt: number
    lastAccessedAt: number
    accessCount: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type CredentialAvgAggregateInputType = {
    keyVersion?: true
    rotationDays?: true
    accessCount?: true
  }

  export type CredentialSumAggregateInputType = {
    keyVersion?: true
    rotationDays?: true
    accessCount?: true
  }

  export type CredentialMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    type?: true
    encryptedValue?: true
    iv?: true
    authTag?: true
    keyVaultId?: true
    keyVersion?: true
    rotationDays?: true
    lastRotatedAt?: true
    nextRotationAt?: true
    lastAccessedAt?: true
    accessCount?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type CredentialMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    type?: true
    encryptedValue?: true
    iv?: true
    authTag?: true
    keyVaultId?: true
    keyVersion?: true
    rotationDays?: true
    lastRotatedAt?: true
    nextRotationAt?: true
    lastAccessedAt?: true
    accessCount?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type CredentialCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    type?: true
    encryptedValue?: true
    iv?: true
    authTag?: true
    keyVaultId?: true
    keyVersion?: true
    rotationDays?: true
    lastRotatedAt?: true
    nextRotationAt?: true
    lastAccessedAt?: true
    accessCount?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type CredentialAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Credential to aggregate.
     */
    where?: CredentialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Credentials to fetch.
     */
    orderBy?: CredentialOrderByWithRelationInput | CredentialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CredentialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Credentials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Credentials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Credentials
    **/
    _count?: true | CredentialCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CredentialAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CredentialSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CredentialMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CredentialMaxAggregateInputType
  }

  export type GetCredentialAggregateType<T extends CredentialAggregateArgs> = {
        [P in keyof T & keyof AggregateCredential]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCredential[P]>
      : GetScalarType<T[P], AggregateCredential[P]>
  }




  export type CredentialGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CredentialWhereInput
    orderBy?: CredentialOrderByWithAggregationInput | CredentialOrderByWithAggregationInput[]
    by: CredentialScalarFieldEnum[] | CredentialScalarFieldEnum
    having?: CredentialScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CredentialCountAggregateInputType | true
    _avg?: CredentialAvgAggregateInputType
    _sum?: CredentialSumAggregateInputType
    _min?: CredentialMinAggregateInputType
    _max?: CredentialMaxAggregateInputType
  }

  export type CredentialGroupByOutputType = {
    id: string
    name: string
    description: string | null
    type: $Enums.CredentialType
    encryptedValue: string
    iv: string
    authTag: string
    keyVaultId: string | null
    keyVersion: number
    rotationDays: number
    lastRotatedAt: Date
    nextRotationAt: Date
    lastAccessedAt: Date | null
    accessCount: number
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: CredentialCountAggregateOutputType | null
    _avg: CredentialAvgAggregateOutputType | null
    _sum: CredentialSumAggregateOutputType | null
    _min: CredentialMinAggregateOutputType | null
    _max: CredentialMaxAggregateOutputType | null
  }

  type GetCredentialGroupByPayload<T extends CredentialGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CredentialGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CredentialGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CredentialGroupByOutputType[P]>
            : GetScalarType<T[P], CredentialGroupByOutputType[P]>
        }
      >
    >


  export type CredentialSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    encryptedValue?: boolean
    iv?: boolean
    authTag?: boolean
    keyVaultId?: boolean
    keyVersion?: boolean
    rotationDays?: boolean
    lastRotatedAt?: boolean
    nextRotationAt?: boolean
    lastAccessedAt?: boolean
    accessCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    auditLogs?: boolean | Credential$auditLogsArgs<ExtArgs>
    _count?: boolean | CredentialCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["credential"]>

  export type CredentialSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    encryptedValue?: boolean
    iv?: boolean
    authTag?: boolean
    keyVaultId?: boolean
    keyVersion?: boolean
    rotationDays?: boolean
    lastRotatedAt?: boolean
    nextRotationAt?: boolean
    lastAccessedAt?: boolean
    accessCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }, ExtArgs["result"]["credential"]>

  export type CredentialSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    encryptedValue?: boolean
    iv?: boolean
    authTag?: boolean
    keyVaultId?: boolean
    keyVersion?: boolean
    rotationDays?: boolean
    lastRotatedAt?: boolean
    nextRotationAt?: boolean
    lastAccessedAt?: boolean
    accessCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }, ExtArgs["result"]["credential"]>

  export type CredentialSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    encryptedValue?: boolean
    iv?: boolean
    authTag?: boolean
    keyVaultId?: boolean
    keyVersion?: boolean
    rotationDays?: boolean
    lastRotatedAt?: boolean
    nextRotationAt?: boolean
    lastAccessedAt?: boolean
    accessCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type CredentialOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "type" | "encryptedValue" | "iv" | "authTag" | "keyVaultId" | "keyVersion" | "rotationDays" | "lastRotatedAt" | "nextRotationAt" | "lastAccessedAt" | "accessCount" | "createdAt" | "updatedAt" | "deletedAt", ExtArgs["result"]["credential"]>
  export type CredentialInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    auditLogs?: boolean | Credential$auditLogsArgs<ExtArgs>
    _count?: boolean | CredentialCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CredentialIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type CredentialIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CredentialPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Credential"
    objects: {
      auditLogs: Prisma.$CredentialAuditLogPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      type: $Enums.CredentialType
      encryptedValue: string
      iv: string
      authTag: string
      keyVaultId: string | null
      keyVersion: number
      rotationDays: number
      lastRotatedAt: Date
      nextRotationAt: Date
      lastAccessedAt: Date | null
      accessCount: number
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["credential"]>
    composites: {}
  }

  type CredentialGetPayload<S extends boolean | null | undefined | CredentialDefaultArgs> = $Result.GetResult<Prisma.$CredentialPayload, S>

  type CredentialCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CredentialFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CredentialCountAggregateInputType | true
    }

  export interface CredentialDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Credential'], meta: { name: 'Credential' } }
    /**
     * Find zero or one Credential that matches the filter.
     * @param {CredentialFindUniqueArgs} args - Arguments to find a Credential
     * @example
     * // Get one Credential
     * const credential = await prisma.credential.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CredentialFindUniqueArgs>(args: SelectSubset<T, CredentialFindUniqueArgs<ExtArgs>>): Prisma__CredentialClient<$Result.GetResult<Prisma.$CredentialPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Credential that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CredentialFindUniqueOrThrowArgs} args - Arguments to find a Credential
     * @example
     * // Get one Credential
     * const credential = await prisma.credential.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CredentialFindUniqueOrThrowArgs>(args: SelectSubset<T, CredentialFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CredentialClient<$Result.GetResult<Prisma.$CredentialPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Credential that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CredentialFindFirstArgs} args - Arguments to find a Credential
     * @example
     * // Get one Credential
     * const credential = await prisma.credential.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CredentialFindFirstArgs>(args?: SelectSubset<T, CredentialFindFirstArgs<ExtArgs>>): Prisma__CredentialClient<$Result.GetResult<Prisma.$CredentialPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Credential that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CredentialFindFirstOrThrowArgs} args - Arguments to find a Credential
     * @example
     * // Get one Credential
     * const credential = await prisma.credential.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CredentialFindFirstOrThrowArgs>(args?: SelectSubset<T, CredentialFindFirstOrThrowArgs<ExtArgs>>): Prisma__CredentialClient<$Result.GetResult<Prisma.$CredentialPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Credentials that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CredentialFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Credentials
     * const credentials = await prisma.credential.findMany()
     * 
     * // Get first 10 Credentials
     * const credentials = await prisma.credential.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const credentialWithIdOnly = await prisma.credential.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CredentialFindManyArgs>(args?: SelectSubset<T, CredentialFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CredentialPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Credential.
     * @param {CredentialCreateArgs} args - Arguments to create a Credential.
     * @example
     * // Create one Credential
     * const Credential = await prisma.credential.create({
     *   data: {
     *     // ... data to create a Credential
     *   }
     * })
     * 
     */
    create<T extends CredentialCreateArgs>(args: SelectSubset<T, CredentialCreateArgs<ExtArgs>>): Prisma__CredentialClient<$Result.GetResult<Prisma.$CredentialPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Credentials.
     * @param {CredentialCreateManyArgs} args - Arguments to create many Credentials.
     * @example
     * // Create many Credentials
     * const credential = await prisma.credential.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CredentialCreateManyArgs>(args?: SelectSubset<T, CredentialCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Credentials and returns the data saved in the database.
     * @param {CredentialCreateManyAndReturnArgs} args - Arguments to create many Credentials.
     * @example
     * // Create many Credentials
     * const credential = await prisma.credential.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Credentials and only return the `id`
     * const credentialWithIdOnly = await prisma.credential.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CredentialCreateManyAndReturnArgs>(args?: SelectSubset<T, CredentialCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CredentialPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Credential.
     * @param {CredentialDeleteArgs} args - Arguments to delete one Credential.
     * @example
     * // Delete one Credential
     * const Credential = await prisma.credential.delete({
     *   where: {
     *     // ... filter to delete one Credential
     *   }
     * })
     * 
     */
    delete<T extends CredentialDeleteArgs>(args: SelectSubset<T, CredentialDeleteArgs<ExtArgs>>): Prisma__CredentialClient<$Result.GetResult<Prisma.$CredentialPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Credential.
     * @param {CredentialUpdateArgs} args - Arguments to update one Credential.
     * @example
     * // Update one Credential
     * const credential = await prisma.credential.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CredentialUpdateArgs>(args: SelectSubset<T, CredentialUpdateArgs<ExtArgs>>): Prisma__CredentialClient<$Result.GetResult<Prisma.$CredentialPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Credentials.
     * @param {CredentialDeleteManyArgs} args - Arguments to filter Credentials to delete.
     * @example
     * // Delete a few Credentials
     * const { count } = await prisma.credential.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CredentialDeleteManyArgs>(args?: SelectSubset<T, CredentialDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Credentials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CredentialUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Credentials
     * const credential = await prisma.credential.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CredentialUpdateManyArgs>(args: SelectSubset<T, CredentialUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Credentials and returns the data updated in the database.
     * @param {CredentialUpdateManyAndReturnArgs} args - Arguments to update many Credentials.
     * @example
     * // Update many Credentials
     * const credential = await prisma.credential.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Credentials and only return the `id`
     * const credentialWithIdOnly = await prisma.credential.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CredentialUpdateManyAndReturnArgs>(args: SelectSubset<T, CredentialUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CredentialPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Credential.
     * @param {CredentialUpsertArgs} args - Arguments to update or create a Credential.
     * @example
     * // Update or create a Credential
     * const credential = await prisma.credential.upsert({
     *   create: {
     *     // ... data to create a Credential
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Credential we want to update
     *   }
     * })
     */
    upsert<T extends CredentialUpsertArgs>(args: SelectSubset<T, CredentialUpsertArgs<ExtArgs>>): Prisma__CredentialClient<$Result.GetResult<Prisma.$CredentialPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Credentials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CredentialCountArgs} args - Arguments to filter Credentials to count.
     * @example
     * // Count the number of Credentials
     * const count = await prisma.credential.count({
     *   where: {
     *     // ... the filter for the Credentials we want to count
     *   }
     * })
    **/
    count<T extends CredentialCountArgs>(
      args?: Subset<T, CredentialCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CredentialCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Credential.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CredentialAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CredentialAggregateArgs>(args: Subset<T, CredentialAggregateArgs>): Prisma.PrismaPromise<GetCredentialAggregateType<T>>

    /**
     * Group by Credential.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CredentialGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CredentialGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CredentialGroupByArgs['orderBy'] }
        : { orderBy?: CredentialGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CredentialGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCredentialGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Credential model
   */
  readonly fields: CredentialFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Credential.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CredentialClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    auditLogs<T extends Credential$auditLogsArgs<ExtArgs> = {}>(args?: Subset<T, Credential$auditLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CredentialAuditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Credential model
   */
  interface CredentialFieldRefs {
    readonly id: FieldRef<"Credential", 'String'>
    readonly name: FieldRef<"Credential", 'String'>
    readonly description: FieldRef<"Credential", 'String'>
    readonly type: FieldRef<"Credential", 'CredentialType'>
    readonly encryptedValue: FieldRef<"Credential", 'String'>
    readonly iv: FieldRef<"Credential", 'String'>
    readonly authTag: FieldRef<"Credential", 'String'>
    readonly keyVaultId: FieldRef<"Credential", 'String'>
    readonly keyVersion: FieldRef<"Credential", 'Int'>
    readonly rotationDays: FieldRef<"Credential", 'Int'>
    readonly lastRotatedAt: FieldRef<"Credential", 'DateTime'>
    readonly nextRotationAt: FieldRef<"Credential", 'DateTime'>
    readonly lastAccessedAt: FieldRef<"Credential", 'DateTime'>
    readonly accessCount: FieldRef<"Credential", 'Int'>
    readonly createdAt: FieldRef<"Credential", 'DateTime'>
    readonly updatedAt: FieldRef<"Credential", 'DateTime'>
    readonly deletedAt: FieldRef<"Credential", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Credential findUnique
   */
  export type CredentialFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Credential
     */
    select?: CredentialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Credential
     */
    omit?: CredentialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CredentialInclude<ExtArgs> | null
    /**
     * Filter, which Credential to fetch.
     */
    where: CredentialWhereUniqueInput
  }

  /**
   * Credential findUniqueOrThrow
   */
  export type CredentialFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Credential
     */
    select?: CredentialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Credential
     */
    omit?: CredentialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CredentialInclude<ExtArgs> | null
    /**
     * Filter, which Credential to fetch.
     */
    where: CredentialWhereUniqueInput
  }

  /**
   * Credential findFirst
   */
  export type CredentialFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Credential
     */
    select?: CredentialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Credential
     */
    omit?: CredentialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CredentialInclude<ExtArgs> | null
    /**
     * Filter, which Credential to fetch.
     */
    where?: CredentialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Credentials to fetch.
     */
    orderBy?: CredentialOrderByWithRelationInput | CredentialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Credentials.
     */
    cursor?: CredentialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Credentials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Credentials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Credentials.
     */
    distinct?: CredentialScalarFieldEnum | CredentialScalarFieldEnum[]
  }

  /**
   * Credential findFirstOrThrow
   */
  export type CredentialFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Credential
     */
    select?: CredentialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Credential
     */
    omit?: CredentialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CredentialInclude<ExtArgs> | null
    /**
     * Filter, which Credential to fetch.
     */
    where?: CredentialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Credentials to fetch.
     */
    orderBy?: CredentialOrderByWithRelationInput | CredentialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Credentials.
     */
    cursor?: CredentialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Credentials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Credentials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Credentials.
     */
    distinct?: CredentialScalarFieldEnum | CredentialScalarFieldEnum[]
  }

  /**
   * Credential findMany
   */
  export type CredentialFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Credential
     */
    select?: CredentialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Credential
     */
    omit?: CredentialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CredentialInclude<ExtArgs> | null
    /**
     * Filter, which Credentials to fetch.
     */
    where?: CredentialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Credentials to fetch.
     */
    orderBy?: CredentialOrderByWithRelationInput | CredentialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Credentials.
     */
    cursor?: CredentialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Credentials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Credentials.
     */
    skip?: number
    distinct?: CredentialScalarFieldEnum | CredentialScalarFieldEnum[]
  }

  /**
   * Credential create
   */
  export type CredentialCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Credential
     */
    select?: CredentialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Credential
     */
    omit?: CredentialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CredentialInclude<ExtArgs> | null
    /**
     * The data needed to create a Credential.
     */
    data: XOR<CredentialCreateInput, CredentialUncheckedCreateInput>
  }

  /**
   * Credential createMany
   */
  export type CredentialCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Credentials.
     */
    data: CredentialCreateManyInput | CredentialCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Credential createManyAndReturn
   */
  export type CredentialCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Credential
     */
    select?: CredentialSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Credential
     */
    omit?: CredentialOmit<ExtArgs> | null
    /**
     * The data used to create many Credentials.
     */
    data: CredentialCreateManyInput | CredentialCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Credential update
   */
  export type CredentialUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Credential
     */
    select?: CredentialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Credential
     */
    omit?: CredentialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CredentialInclude<ExtArgs> | null
    /**
     * The data needed to update a Credential.
     */
    data: XOR<CredentialUpdateInput, CredentialUncheckedUpdateInput>
    /**
     * Choose, which Credential to update.
     */
    where: CredentialWhereUniqueInput
  }

  /**
   * Credential updateMany
   */
  export type CredentialUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Credentials.
     */
    data: XOR<CredentialUpdateManyMutationInput, CredentialUncheckedUpdateManyInput>
    /**
     * Filter which Credentials to update
     */
    where?: CredentialWhereInput
    /**
     * Limit how many Credentials to update.
     */
    limit?: number
  }

  /**
   * Credential updateManyAndReturn
   */
  export type CredentialUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Credential
     */
    select?: CredentialSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Credential
     */
    omit?: CredentialOmit<ExtArgs> | null
    /**
     * The data used to update Credentials.
     */
    data: XOR<CredentialUpdateManyMutationInput, CredentialUncheckedUpdateManyInput>
    /**
     * Filter which Credentials to update
     */
    where?: CredentialWhereInput
    /**
     * Limit how many Credentials to update.
     */
    limit?: number
  }

  /**
   * Credential upsert
   */
  export type CredentialUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Credential
     */
    select?: CredentialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Credential
     */
    omit?: CredentialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CredentialInclude<ExtArgs> | null
    /**
     * The filter to search for the Credential to update in case it exists.
     */
    where: CredentialWhereUniqueInput
    /**
     * In case the Credential found by the `where` argument doesn't exist, create a new Credential with this data.
     */
    create: XOR<CredentialCreateInput, CredentialUncheckedCreateInput>
    /**
     * In case the Credential was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CredentialUpdateInput, CredentialUncheckedUpdateInput>
  }

  /**
   * Credential delete
   */
  export type CredentialDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Credential
     */
    select?: CredentialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Credential
     */
    omit?: CredentialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CredentialInclude<ExtArgs> | null
    /**
     * Filter which Credential to delete.
     */
    where: CredentialWhereUniqueInput
  }

  /**
   * Credential deleteMany
   */
  export type CredentialDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Credentials to delete
     */
    where?: CredentialWhereInput
    /**
     * Limit how many Credentials to delete.
     */
    limit?: number
  }

  /**
   * Credential.auditLogs
   */
  export type Credential$auditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CredentialAuditLog
     */
    select?: CredentialAuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CredentialAuditLog
     */
    omit?: CredentialAuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CredentialAuditLogInclude<ExtArgs> | null
    where?: CredentialAuditLogWhereInput
    orderBy?: CredentialAuditLogOrderByWithRelationInput | CredentialAuditLogOrderByWithRelationInput[]
    cursor?: CredentialAuditLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CredentialAuditLogScalarFieldEnum | CredentialAuditLogScalarFieldEnum[]
  }

  /**
   * Credential without action
   */
  export type CredentialDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Credential
     */
    select?: CredentialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Credential
     */
    omit?: CredentialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CredentialInclude<ExtArgs> | null
  }


  /**
   * Model CredentialAuditLog
   */

  export type AggregateCredentialAuditLog = {
    _count: CredentialAuditLogCountAggregateOutputType | null
    _min: CredentialAuditLogMinAggregateOutputType | null
    _max: CredentialAuditLogMaxAggregateOutputType | null
  }

  export type CredentialAuditLogMinAggregateOutputType = {
    id: string | null
    credentialId: string | null
    action: $Enums.CredentialAction | null
    userId: string | null
    jobId: string | null
    ipAddress: string | null
    userAgent: string | null
    success: boolean | null
    errorMessage: string | null
    timestamp: Date | null
  }

  export type CredentialAuditLogMaxAggregateOutputType = {
    id: string | null
    credentialId: string | null
    action: $Enums.CredentialAction | null
    userId: string | null
    jobId: string | null
    ipAddress: string | null
    userAgent: string | null
    success: boolean | null
    errorMessage: string | null
    timestamp: Date | null
  }

  export type CredentialAuditLogCountAggregateOutputType = {
    id: number
    credentialId: number
    action: number
    userId: number
    jobId: number
    ipAddress: number
    userAgent: number
    success: number
    errorMessage: number
    timestamp: number
    _all: number
  }


  export type CredentialAuditLogMinAggregateInputType = {
    id?: true
    credentialId?: true
    action?: true
    userId?: true
    jobId?: true
    ipAddress?: true
    userAgent?: true
    success?: true
    errorMessage?: true
    timestamp?: true
  }

  export type CredentialAuditLogMaxAggregateInputType = {
    id?: true
    credentialId?: true
    action?: true
    userId?: true
    jobId?: true
    ipAddress?: true
    userAgent?: true
    success?: true
    errorMessage?: true
    timestamp?: true
  }

  export type CredentialAuditLogCountAggregateInputType = {
    id?: true
    credentialId?: true
    action?: true
    userId?: true
    jobId?: true
    ipAddress?: true
    userAgent?: true
    success?: true
    errorMessage?: true
    timestamp?: true
    _all?: true
  }

  export type CredentialAuditLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CredentialAuditLog to aggregate.
     */
    where?: CredentialAuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CredentialAuditLogs to fetch.
     */
    orderBy?: CredentialAuditLogOrderByWithRelationInput | CredentialAuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CredentialAuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CredentialAuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CredentialAuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CredentialAuditLogs
    **/
    _count?: true | CredentialAuditLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CredentialAuditLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CredentialAuditLogMaxAggregateInputType
  }

  export type GetCredentialAuditLogAggregateType<T extends CredentialAuditLogAggregateArgs> = {
        [P in keyof T & keyof AggregateCredentialAuditLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCredentialAuditLog[P]>
      : GetScalarType<T[P], AggregateCredentialAuditLog[P]>
  }




  export type CredentialAuditLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CredentialAuditLogWhereInput
    orderBy?: CredentialAuditLogOrderByWithAggregationInput | CredentialAuditLogOrderByWithAggregationInput[]
    by: CredentialAuditLogScalarFieldEnum[] | CredentialAuditLogScalarFieldEnum
    having?: CredentialAuditLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CredentialAuditLogCountAggregateInputType | true
    _min?: CredentialAuditLogMinAggregateInputType
    _max?: CredentialAuditLogMaxAggregateInputType
  }

  export type CredentialAuditLogGroupByOutputType = {
    id: string
    credentialId: string
    action: $Enums.CredentialAction
    userId: string | null
    jobId: string | null
    ipAddress: string | null
    userAgent: string | null
    success: boolean
    errorMessage: string | null
    timestamp: Date
    _count: CredentialAuditLogCountAggregateOutputType | null
    _min: CredentialAuditLogMinAggregateOutputType | null
    _max: CredentialAuditLogMaxAggregateOutputType | null
  }

  type GetCredentialAuditLogGroupByPayload<T extends CredentialAuditLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CredentialAuditLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CredentialAuditLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CredentialAuditLogGroupByOutputType[P]>
            : GetScalarType<T[P], CredentialAuditLogGroupByOutputType[P]>
        }
      >
    >


  export type CredentialAuditLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    credentialId?: boolean
    action?: boolean
    userId?: boolean
    jobId?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    success?: boolean
    errorMessage?: boolean
    timestamp?: boolean
    credential?: boolean | CredentialDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["credentialAuditLog"]>

  export type CredentialAuditLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    credentialId?: boolean
    action?: boolean
    userId?: boolean
    jobId?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    success?: boolean
    errorMessage?: boolean
    timestamp?: boolean
    credential?: boolean | CredentialDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["credentialAuditLog"]>

  export type CredentialAuditLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    credentialId?: boolean
    action?: boolean
    userId?: boolean
    jobId?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    success?: boolean
    errorMessage?: boolean
    timestamp?: boolean
    credential?: boolean | CredentialDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["credentialAuditLog"]>

  export type CredentialAuditLogSelectScalar = {
    id?: boolean
    credentialId?: boolean
    action?: boolean
    userId?: boolean
    jobId?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    success?: boolean
    errorMessage?: boolean
    timestamp?: boolean
  }

  export type CredentialAuditLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "credentialId" | "action" | "userId" | "jobId" | "ipAddress" | "userAgent" | "success" | "errorMessage" | "timestamp", ExtArgs["result"]["credentialAuditLog"]>
  export type CredentialAuditLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    credential?: boolean | CredentialDefaultArgs<ExtArgs>
  }
  export type CredentialAuditLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    credential?: boolean | CredentialDefaultArgs<ExtArgs>
  }
  export type CredentialAuditLogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    credential?: boolean | CredentialDefaultArgs<ExtArgs>
  }

  export type $CredentialAuditLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CredentialAuditLog"
    objects: {
      credential: Prisma.$CredentialPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      credentialId: string
      action: $Enums.CredentialAction
      userId: string | null
      jobId: string | null
      ipAddress: string | null
      userAgent: string | null
      success: boolean
      errorMessage: string | null
      timestamp: Date
    }, ExtArgs["result"]["credentialAuditLog"]>
    composites: {}
  }

  type CredentialAuditLogGetPayload<S extends boolean | null | undefined | CredentialAuditLogDefaultArgs> = $Result.GetResult<Prisma.$CredentialAuditLogPayload, S>

  type CredentialAuditLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CredentialAuditLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CredentialAuditLogCountAggregateInputType | true
    }

  export interface CredentialAuditLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CredentialAuditLog'], meta: { name: 'CredentialAuditLog' } }
    /**
     * Find zero or one CredentialAuditLog that matches the filter.
     * @param {CredentialAuditLogFindUniqueArgs} args - Arguments to find a CredentialAuditLog
     * @example
     * // Get one CredentialAuditLog
     * const credentialAuditLog = await prisma.credentialAuditLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CredentialAuditLogFindUniqueArgs>(args: SelectSubset<T, CredentialAuditLogFindUniqueArgs<ExtArgs>>): Prisma__CredentialAuditLogClient<$Result.GetResult<Prisma.$CredentialAuditLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CredentialAuditLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CredentialAuditLogFindUniqueOrThrowArgs} args - Arguments to find a CredentialAuditLog
     * @example
     * // Get one CredentialAuditLog
     * const credentialAuditLog = await prisma.credentialAuditLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CredentialAuditLogFindUniqueOrThrowArgs>(args: SelectSubset<T, CredentialAuditLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CredentialAuditLogClient<$Result.GetResult<Prisma.$CredentialAuditLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CredentialAuditLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CredentialAuditLogFindFirstArgs} args - Arguments to find a CredentialAuditLog
     * @example
     * // Get one CredentialAuditLog
     * const credentialAuditLog = await prisma.credentialAuditLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CredentialAuditLogFindFirstArgs>(args?: SelectSubset<T, CredentialAuditLogFindFirstArgs<ExtArgs>>): Prisma__CredentialAuditLogClient<$Result.GetResult<Prisma.$CredentialAuditLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CredentialAuditLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CredentialAuditLogFindFirstOrThrowArgs} args - Arguments to find a CredentialAuditLog
     * @example
     * // Get one CredentialAuditLog
     * const credentialAuditLog = await prisma.credentialAuditLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CredentialAuditLogFindFirstOrThrowArgs>(args?: SelectSubset<T, CredentialAuditLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__CredentialAuditLogClient<$Result.GetResult<Prisma.$CredentialAuditLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CredentialAuditLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CredentialAuditLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CredentialAuditLogs
     * const credentialAuditLogs = await prisma.credentialAuditLog.findMany()
     * 
     * // Get first 10 CredentialAuditLogs
     * const credentialAuditLogs = await prisma.credentialAuditLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const credentialAuditLogWithIdOnly = await prisma.credentialAuditLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CredentialAuditLogFindManyArgs>(args?: SelectSubset<T, CredentialAuditLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CredentialAuditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CredentialAuditLog.
     * @param {CredentialAuditLogCreateArgs} args - Arguments to create a CredentialAuditLog.
     * @example
     * // Create one CredentialAuditLog
     * const CredentialAuditLog = await prisma.credentialAuditLog.create({
     *   data: {
     *     // ... data to create a CredentialAuditLog
     *   }
     * })
     * 
     */
    create<T extends CredentialAuditLogCreateArgs>(args: SelectSubset<T, CredentialAuditLogCreateArgs<ExtArgs>>): Prisma__CredentialAuditLogClient<$Result.GetResult<Prisma.$CredentialAuditLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CredentialAuditLogs.
     * @param {CredentialAuditLogCreateManyArgs} args - Arguments to create many CredentialAuditLogs.
     * @example
     * // Create many CredentialAuditLogs
     * const credentialAuditLog = await prisma.credentialAuditLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CredentialAuditLogCreateManyArgs>(args?: SelectSubset<T, CredentialAuditLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CredentialAuditLogs and returns the data saved in the database.
     * @param {CredentialAuditLogCreateManyAndReturnArgs} args - Arguments to create many CredentialAuditLogs.
     * @example
     * // Create many CredentialAuditLogs
     * const credentialAuditLog = await prisma.credentialAuditLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CredentialAuditLogs and only return the `id`
     * const credentialAuditLogWithIdOnly = await prisma.credentialAuditLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CredentialAuditLogCreateManyAndReturnArgs>(args?: SelectSubset<T, CredentialAuditLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CredentialAuditLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CredentialAuditLog.
     * @param {CredentialAuditLogDeleteArgs} args - Arguments to delete one CredentialAuditLog.
     * @example
     * // Delete one CredentialAuditLog
     * const CredentialAuditLog = await prisma.credentialAuditLog.delete({
     *   where: {
     *     // ... filter to delete one CredentialAuditLog
     *   }
     * })
     * 
     */
    delete<T extends CredentialAuditLogDeleteArgs>(args: SelectSubset<T, CredentialAuditLogDeleteArgs<ExtArgs>>): Prisma__CredentialAuditLogClient<$Result.GetResult<Prisma.$CredentialAuditLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CredentialAuditLog.
     * @param {CredentialAuditLogUpdateArgs} args - Arguments to update one CredentialAuditLog.
     * @example
     * // Update one CredentialAuditLog
     * const credentialAuditLog = await prisma.credentialAuditLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CredentialAuditLogUpdateArgs>(args: SelectSubset<T, CredentialAuditLogUpdateArgs<ExtArgs>>): Prisma__CredentialAuditLogClient<$Result.GetResult<Prisma.$CredentialAuditLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CredentialAuditLogs.
     * @param {CredentialAuditLogDeleteManyArgs} args - Arguments to filter CredentialAuditLogs to delete.
     * @example
     * // Delete a few CredentialAuditLogs
     * const { count } = await prisma.credentialAuditLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CredentialAuditLogDeleteManyArgs>(args?: SelectSubset<T, CredentialAuditLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CredentialAuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CredentialAuditLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CredentialAuditLogs
     * const credentialAuditLog = await prisma.credentialAuditLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CredentialAuditLogUpdateManyArgs>(args: SelectSubset<T, CredentialAuditLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CredentialAuditLogs and returns the data updated in the database.
     * @param {CredentialAuditLogUpdateManyAndReturnArgs} args - Arguments to update many CredentialAuditLogs.
     * @example
     * // Update many CredentialAuditLogs
     * const credentialAuditLog = await prisma.credentialAuditLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CredentialAuditLogs and only return the `id`
     * const credentialAuditLogWithIdOnly = await prisma.credentialAuditLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CredentialAuditLogUpdateManyAndReturnArgs>(args: SelectSubset<T, CredentialAuditLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CredentialAuditLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CredentialAuditLog.
     * @param {CredentialAuditLogUpsertArgs} args - Arguments to update or create a CredentialAuditLog.
     * @example
     * // Update or create a CredentialAuditLog
     * const credentialAuditLog = await prisma.credentialAuditLog.upsert({
     *   create: {
     *     // ... data to create a CredentialAuditLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CredentialAuditLog we want to update
     *   }
     * })
     */
    upsert<T extends CredentialAuditLogUpsertArgs>(args: SelectSubset<T, CredentialAuditLogUpsertArgs<ExtArgs>>): Prisma__CredentialAuditLogClient<$Result.GetResult<Prisma.$CredentialAuditLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CredentialAuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CredentialAuditLogCountArgs} args - Arguments to filter CredentialAuditLogs to count.
     * @example
     * // Count the number of CredentialAuditLogs
     * const count = await prisma.credentialAuditLog.count({
     *   where: {
     *     // ... the filter for the CredentialAuditLogs we want to count
     *   }
     * })
    **/
    count<T extends CredentialAuditLogCountArgs>(
      args?: Subset<T, CredentialAuditLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CredentialAuditLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CredentialAuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CredentialAuditLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CredentialAuditLogAggregateArgs>(args: Subset<T, CredentialAuditLogAggregateArgs>): Prisma.PrismaPromise<GetCredentialAuditLogAggregateType<T>>

    /**
     * Group by CredentialAuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CredentialAuditLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CredentialAuditLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CredentialAuditLogGroupByArgs['orderBy'] }
        : { orderBy?: CredentialAuditLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CredentialAuditLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCredentialAuditLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CredentialAuditLog model
   */
  readonly fields: CredentialAuditLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CredentialAuditLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CredentialAuditLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    credential<T extends CredentialDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CredentialDefaultArgs<ExtArgs>>): Prisma__CredentialClient<$Result.GetResult<Prisma.$CredentialPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CredentialAuditLog model
   */
  interface CredentialAuditLogFieldRefs {
    readonly id: FieldRef<"CredentialAuditLog", 'String'>
    readonly credentialId: FieldRef<"CredentialAuditLog", 'String'>
    readonly action: FieldRef<"CredentialAuditLog", 'CredentialAction'>
    readonly userId: FieldRef<"CredentialAuditLog", 'String'>
    readonly jobId: FieldRef<"CredentialAuditLog", 'String'>
    readonly ipAddress: FieldRef<"CredentialAuditLog", 'String'>
    readonly userAgent: FieldRef<"CredentialAuditLog", 'String'>
    readonly success: FieldRef<"CredentialAuditLog", 'Boolean'>
    readonly errorMessage: FieldRef<"CredentialAuditLog", 'String'>
    readonly timestamp: FieldRef<"CredentialAuditLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CredentialAuditLog findUnique
   */
  export type CredentialAuditLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CredentialAuditLog
     */
    select?: CredentialAuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CredentialAuditLog
     */
    omit?: CredentialAuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CredentialAuditLogInclude<ExtArgs> | null
    /**
     * Filter, which CredentialAuditLog to fetch.
     */
    where: CredentialAuditLogWhereUniqueInput
  }

  /**
   * CredentialAuditLog findUniqueOrThrow
   */
  export type CredentialAuditLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CredentialAuditLog
     */
    select?: CredentialAuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CredentialAuditLog
     */
    omit?: CredentialAuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CredentialAuditLogInclude<ExtArgs> | null
    /**
     * Filter, which CredentialAuditLog to fetch.
     */
    where: CredentialAuditLogWhereUniqueInput
  }

  /**
   * CredentialAuditLog findFirst
   */
  export type CredentialAuditLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CredentialAuditLog
     */
    select?: CredentialAuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CredentialAuditLog
     */
    omit?: CredentialAuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CredentialAuditLogInclude<ExtArgs> | null
    /**
     * Filter, which CredentialAuditLog to fetch.
     */
    where?: CredentialAuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CredentialAuditLogs to fetch.
     */
    orderBy?: CredentialAuditLogOrderByWithRelationInput | CredentialAuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CredentialAuditLogs.
     */
    cursor?: CredentialAuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CredentialAuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CredentialAuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CredentialAuditLogs.
     */
    distinct?: CredentialAuditLogScalarFieldEnum | CredentialAuditLogScalarFieldEnum[]
  }

  /**
   * CredentialAuditLog findFirstOrThrow
   */
  export type CredentialAuditLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CredentialAuditLog
     */
    select?: CredentialAuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CredentialAuditLog
     */
    omit?: CredentialAuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CredentialAuditLogInclude<ExtArgs> | null
    /**
     * Filter, which CredentialAuditLog to fetch.
     */
    where?: CredentialAuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CredentialAuditLogs to fetch.
     */
    orderBy?: CredentialAuditLogOrderByWithRelationInput | CredentialAuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CredentialAuditLogs.
     */
    cursor?: CredentialAuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CredentialAuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CredentialAuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CredentialAuditLogs.
     */
    distinct?: CredentialAuditLogScalarFieldEnum | CredentialAuditLogScalarFieldEnum[]
  }

  /**
   * CredentialAuditLog findMany
   */
  export type CredentialAuditLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CredentialAuditLog
     */
    select?: CredentialAuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CredentialAuditLog
     */
    omit?: CredentialAuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CredentialAuditLogInclude<ExtArgs> | null
    /**
     * Filter, which CredentialAuditLogs to fetch.
     */
    where?: CredentialAuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CredentialAuditLogs to fetch.
     */
    orderBy?: CredentialAuditLogOrderByWithRelationInput | CredentialAuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CredentialAuditLogs.
     */
    cursor?: CredentialAuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CredentialAuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CredentialAuditLogs.
     */
    skip?: number
    distinct?: CredentialAuditLogScalarFieldEnum | CredentialAuditLogScalarFieldEnum[]
  }

  /**
   * CredentialAuditLog create
   */
  export type CredentialAuditLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CredentialAuditLog
     */
    select?: CredentialAuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CredentialAuditLog
     */
    omit?: CredentialAuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CredentialAuditLogInclude<ExtArgs> | null
    /**
     * The data needed to create a CredentialAuditLog.
     */
    data: XOR<CredentialAuditLogCreateInput, CredentialAuditLogUncheckedCreateInput>
  }

  /**
   * CredentialAuditLog createMany
   */
  export type CredentialAuditLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CredentialAuditLogs.
     */
    data: CredentialAuditLogCreateManyInput | CredentialAuditLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CredentialAuditLog createManyAndReturn
   */
  export type CredentialAuditLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CredentialAuditLog
     */
    select?: CredentialAuditLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CredentialAuditLog
     */
    omit?: CredentialAuditLogOmit<ExtArgs> | null
    /**
     * The data used to create many CredentialAuditLogs.
     */
    data: CredentialAuditLogCreateManyInput | CredentialAuditLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CredentialAuditLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CredentialAuditLog update
   */
  export type CredentialAuditLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CredentialAuditLog
     */
    select?: CredentialAuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CredentialAuditLog
     */
    omit?: CredentialAuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CredentialAuditLogInclude<ExtArgs> | null
    /**
     * The data needed to update a CredentialAuditLog.
     */
    data: XOR<CredentialAuditLogUpdateInput, CredentialAuditLogUncheckedUpdateInput>
    /**
     * Choose, which CredentialAuditLog to update.
     */
    where: CredentialAuditLogWhereUniqueInput
  }

  /**
   * CredentialAuditLog updateMany
   */
  export type CredentialAuditLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CredentialAuditLogs.
     */
    data: XOR<CredentialAuditLogUpdateManyMutationInput, CredentialAuditLogUncheckedUpdateManyInput>
    /**
     * Filter which CredentialAuditLogs to update
     */
    where?: CredentialAuditLogWhereInput
    /**
     * Limit how many CredentialAuditLogs to update.
     */
    limit?: number
  }

  /**
   * CredentialAuditLog updateManyAndReturn
   */
  export type CredentialAuditLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CredentialAuditLog
     */
    select?: CredentialAuditLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CredentialAuditLog
     */
    omit?: CredentialAuditLogOmit<ExtArgs> | null
    /**
     * The data used to update CredentialAuditLogs.
     */
    data: XOR<CredentialAuditLogUpdateManyMutationInput, CredentialAuditLogUncheckedUpdateManyInput>
    /**
     * Filter which CredentialAuditLogs to update
     */
    where?: CredentialAuditLogWhereInput
    /**
     * Limit how many CredentialAuditLogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CredentialAuditLogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CredentialAuditLog upsert
   */
  export type CredentialAuditLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CredentialAuditLog
     */
    select?: CredentialAuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CredentialAuditLog
     */
    omit?: CredentialAuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CredentialAuditLogInclude<ExtArgs> | null
    /**
     * The filter to search for the CredentialAuditLog to update in case it exists.
     */
    where: CredentialAuditLogWhereUniqueInput
    /**
     * In case the CredentialAuditLog found by the `where` argument doesn't exist, create a new CredentialAuditLog with this data.
     */
    create: XOR<CredentialAuditLogCreateInput, CredentialAuditLogUncheckedCreateInput>
    /**
     * In case the CredentialAuditLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CredentialAuditLogUpdateInput, CredentialAuditLogUncheckedUpdateInput>
  }

  /**
   * CredentialAuditLog delete
   */
  export type CredentialAuditLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CredentialAuditLog
     */
    select?: CredentialAuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CredentialAuditLog
     */
    omit?: CredentialAuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CredentialAuditLogInclude<ExtArgs> | null
    /**
     * Filter which CredentialAuditLog to delete.
     */
    where: CredentialAuditLogWhereUniqueInput
  }

  /**
   * CredentialAuditLog deleteMany
   */
  export type CredentialAuditLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CredentialAuditLogs to delete
     */
    where?: CredentialAuditLogWhereInput
    /**
     * Limit how many CredentialAuditLogs to delete.
     */
    limit?: number
  }

  /**
   * CredentialAuditLog without action
   */
  export type CredentialAuditLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CredentialAuditLog
     */
    select?: CredentialAuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CredentialAuditLog
     */
    omit?: CredentialAuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CredentialAuditLogInclude<ExtArgs> | null
  }


  /**
   * Model Webhook
   */

  export type AggregateWebhook = {
    _count: WebhookCountAggregateOutputType | null
    _avg: WebhookAvgAggregateOutputType | null
    _sum: WebhookSumAggregateOutputType | null
    _min: WebhookMinAggregateOutputType | null
    _max: WebhookMaxAggregateOutputType | null
  }

  export type WebhookAvgAggregateOutputType = {
    maxRetries: number | null
    retryDelay: number | null
  }

  export type WebhookSumAggregateOutputType = {
    maxRetries: number | null
    retryDelay: number | null
  }

  export type WebhookMinAggregateOutputType = {
    id: string | null
    url: string | null
    secret: string | null
    isActive: boolean | null
    maxRetries: number | null
    retryDelay: number | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type WebhookMaxAggregateOutputType = {
    id: string | null
    url: string | null
    secret: string | null
    isActive: boolean | null
    maxRetries: number | null
    retryDelay: number | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type WebhookCountAggregateOutputType = {
    id: number
    url: number
    secret: number
    events: number
    isActive: number
    maxRetries: number
    retryDelay: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type WebhookAvgAggregateInputType = {
    maxRetries?: true
    retryDelay?: true
  }

  export type WebhookSumAggregateInputType = {
    maxRetries?: true
    retryDelay?: true
  }

  export type WebhookMinAggregateInputType = {
    id?: true
    url?: true
    secret?: true
    isActive?: true
    maxRetries?: true
    retryDelay?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type WebhookMaxAggregateInputType = {
    id?: true
    url?: true
    secret?: true
    isActive?: true
    maxRetries?: true
    retryDelay?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type WebhookCountAggregateInputType = {
    id?: true
    url?: true
    secret?: true
    events?: true
    isActive?: true
    maxRetries?: true
    retryDelay?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type WebhookAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Webhook to aggregate.
     */
    where?: WebhookWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Webhooks to fetch.
     */
    orderBy?: WebhookOrderByWithRelationInput | WebhookOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WebhookWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Webhooks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Webhooks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Webhooks
    **/
    _count?: true | WebhookCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WebhookAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WebhookSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WebhookMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WebhookMaxAggregateInputType
  }

  export type GetWebhookAggregateType<T extends WebhookAggregateArgs> = {
        [P in keyof T & keyof AggregateWebhook]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWebhook[P]>
      : GetScalarType<T[P], AggregateWebhook[P]>
  }




  export type WebhookGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WebhookWhereInput
    orderBy?: WebhookOrderByWithAggregationInput | WebhookOrderByWithAggregationInput[]
    by: WebhookScalarFieldEnum[] | WebhookScalarFieldEnum
    having?: WebhookScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WebhookCountAggregateInputType | true
    _avg?: WebhookAvgAggregateInputType
    _sum?: WebhookSumAggregateInputType
    _min?: WebhookMinAggregateInputType
    _max?: WebhookMaxAggregateInputType
  }

  export type WebhookGroupByOutputType = {
    id: string
    url: string
    secret: string
    events: string[]
    isActive: boolean
    maxRetries: number
    retryDelay: number
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: WebhookCountAggregateOutputType | null
    _avg: WebhookAvgAggregateOutputType | null
    _sum: WebhookSumAggregateOutputType | null
    _min: WebhookMinAggregateOutputType | null
    _max: WebhookMaxAggregateOutputType | null
  }

  type GetWebhookGroupByPayload<T extends WebhookGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WebhookGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WebhookGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WebhookGroupByOutputType[P]>
            : GetScalarType<T[P], WebhookGroupByOutputType[P]>
        }
      >
    >


  export type WebhookSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    url?: boolean
    secret?: boolean
    events?: boolean
    isActive?: boolean
    maxRetries?: boolean
    retryDelay?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    deliveries?: boolean | Webhook$deliveriesArgs<ExtArgs>
    _count?: boolean | WebhookCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["webhook"]>

  export type WebhookSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    url?: boolean
    secret?: boolean
    events?: boolean
    isActive?: boolean
    maxRetries?: boolean
    retryDelay?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }, ExtArgs["result"]["webhook"]>

  export type WebhookSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    url?: boolean
    secret?: boolean
    events?: boolean
    isActive?: boolean
    maxRetries?: boolean
    retryDelay?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }, ExtArgs["result"]["webhook"]>

  export type WebhookSelectScalar = {
    id?: boolean
    url?: boolean
    secret?: boolean
    events?: boolean
    isActive?: boolean
    maxRetries?: boolean
    retryDelay?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type WebhookOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "url" | "secret" | "events" | "isActive" | "maxRetries" | "retryDelay" | "createdAt" | "updatedAt" | "deletedAt", ExtArgs["result"]["webhook"]>
  export type WebhookInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    deliveries?: boolean | Webhook$deliveriesArgs<ExtArgs>
    _count?: boolean | WebhookCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type WebhookIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type WebhookIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $WebhookPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Webhook"
    objects: {
      deliveries: Prisma.$WebhookDeliveryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      url: string
      secret: string
      events: string[]
      isActive: boolean
      maxRetries: number
      retryDelay: number
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["webhook"]>
    composites: {}
  }

  type WebhookGetPayload<S extends boolean | null | undefined | WebhookDefaultArgs> = $Result.GetResult<Prisma.$WebhookPayload, S>

  type WebhookCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WebhookFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WebhookCountAggregateInputType | true
    }

  export interface WebhookDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Webhook'], meta: { name: 'Webhook' } }
    /**
     * Find zero or one Webhook that matches the filter.
     * @param {WebhookFindUniqueArgs} args - Arguments to find a Webhook
     * @example
     * // Get one Webhook
     * const webhook = await prisma.webhook.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WebhookFindUniqueArgs>(args: SelectSubset<T, WebhookFindUniqueArgs<ExtArgs>>): Prisma__WebhookClient<$Result.GetResult<Prisma.$WebhookPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Webhook that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WebhookFindUniqueOrThrowArgs} args - Arguments to find a Webhook
     * @example
     * // Get one Webhook
     * const webhook = await prisma.webhook.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WebhookFindUniqueOrThrowArgs>(args: SelectSubset<T, WebhookFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WebhookClient<$Result.GetResult<Prisma.$WebhookPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Webhook that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookFindFirstArgs} args - Arguments to find a Webhook
     * @example
     * // Get one Webhook
     * const webhook = await prisma.webhook.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WebhookFindFirstArgs>(args?: SelectSubset<T, WebhookFindFirstArgs<ExtArgs>>): Prisma__WebhookClient<$Result.GetResult<Prisma.$WebhookPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Webhook that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookFindFirstOrThrowArgs} args - Arguments to find a Webhook
     * @example
     * // Get one Webhook
     * const webhook = await prisma.webhook.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WebhookFindFirstOrThrowArgs>(args?: SelectSubset<T, WebhookFindFirstOrThrowArgs<ExtArgs>>): Prisma__WebhookClient<$Result.GetResult<Prisma.$WebhookPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Webhooks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Webhooks
     * const webhooks = await prisma.webhook.findMany()
     * 
     * // Get first 10 Webhooks
     * const webhooks = await prisma.webhook.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const webhookWithIdOnly = await prisma.webhook.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WebhookFindManyArgs>(args?: SelectSubset<T, WebhookFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WebhookPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Webhook.
     * @param {WebhookCreateArgs} args - Arguments to create a Webhook.
     * @example
     * // Create one Webhook
     * const Webhook = await prisma.webhook.create({
     *   data: {
     *     // ... data to create a Webhook
     *   }
     * })
     * 
     */
    create<T extends WebhookCreateArgs>(args: SelectSubset<T, WebhookCreateArgs<ExtArgs>>): Prisma__WebhookClient<$Result.GetResult<Prisma.$WebhookPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Webhooks.
     * @param {WebhookCreateManyArgs} args - Arguments to create many Webhooks.
     * @example
     * // Create many Webhooks
     * const webhook = await prisma.webhook.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WebhookCreateManyArgs>(args?: SelectSubset<T, WebhookCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Webhooks and returns the data saved in the database.
     * @param {WebhookCreateManyAndReturnArgs} args - Arguments to create many Webhooks.
     * @example
     * // Create many Webhooks
     * const webhook = await prisma.webhook.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Webhooks and only return the `id`
     * const webhookWithIdOnly = await prisma.webhook.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WebhookCreateManyAndReturnArgs>(args?: SelectSubset<T, WebhookCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WebhookPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Webhook.
     * @param {WebhookDeleteArgs} args - Arguments to delete one Webhook.
     * @example
     * // Delete one Webhook
     * const Webhook = await prisma.webhook.delete({
     *   where: {
     *     // ... filter to delete one Webhook
     *   }
     * })
     * 
     */
    delete<T extends WebhookDeleteArgs>(args: SelectSubset<T, WebhookDeleteArgs<ExtArgs>>): Prisma__WebhookClient<$Result.GetResult<Prisma.$WebhookPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Webhook.
     * @param {WebhookUpdateArgs} args - Arguments to update one Webhook.
     * @example
     * // Update one Webhook
     * const webhook = await prisma.webhook.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WebhookUpdateArgs>(args: SelectSubset<T, WebhookUpdateArgs<ExtArgs>>): Prisma__WebhookClient<$Result.GetResult<Prisma.$WebhookPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Webhooks.
     * @param {WebhookDeleteManyArgs} args - Arguments to filter Webhooks to delete.
     * @example
     * // Delete a few Webhooks
     * const { count } = await prisma.webhook.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WebhookDeleteManyArgs>(args?: SelectSubset<T, WebhookDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Webhooks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Webhooks
     * const webhook = await prisma.webhook.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WebhookUpdateManyArgs>(args: SelectSubset<T, WebhookUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Webhooks and returns the data updated in the database.
     * @param {WebhookUpdateManyAndReturnArgs} args - Arguments to update many Webhooks.
     * @example
     * // Update many Webhooks
     * const webhook = await prisma.webhook.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Webhooks and only return the `id`
     * const webhookWithIdOnly = await prisma.webhook.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WebhookUpdateManyAndReturnArgs>(args: SelectSubset<T, WebhookUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WebhookPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Webhook.
     * @param {WebhookUpsertArgs} args - Arguments to update or create a Webhook.
     * @example
     * // Update or create a Webhook
     * const webhook = await prisma.webhook.upsert({
     *   create: {
     *     // ... data to create a Webhook
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Webhook we want to update
     *   }
     * })
     */
    upsert<T extends WebhookUpsertArgs>(args: SelectSubset<T, WebhookUpsertArgs<ExtArgs>>): Prisma__WebhookClient<$Result.GetResult<Prisma.$WebhookPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Webhooks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookCountArgs} args - Arguments to filter Webhooks to count.
     * @example
     * // Count the number of Webhooks
     * const count = await prisma.webhook.count({
     *   where: {
     *     // ... the filter for the Webhooks we want to count
     *   }
     * })
    **/
    count<T extends WebhookCountArgs>(
      args?: Subset<T, WebhookCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WebhookCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Webhook.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WebhookAggregateArgs>(args: Subset<T, WebhookAggregateArgs>): Prisma.PrismaPromise<GetWebhookAggregateType<T>>

    /**
     * Group by Webhook.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WebhookGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WebhookGroupByArgs['orderBy'] }
        : { orderBy?: WebhookGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WebhookGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWebhookGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Webhook model
   */
  readonly fields: WebhookFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Webhook.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WebhookClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    deliveries<T extends Webhook$deliveriesArgs<ExtArgs> = {}>(args?: Subset<T, Webhook$deliveriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WebhookDeliveryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Webhook model
   */
  interface WebhookFieldRefs {
    readonly id: FieldRef<"Webhook", 'String'>
    readonly url: FieldRef<"Webhook", 'String'>
    readonly secret: FieldRef<"Webhook", 'String'>
    readonly events: FieldRef<"Webhook", 'String[]'>
    readonly isActive: FieldRef<"Webhook", 'Boolean'>
    readonly maxRetries: FieldRef<"Webhook", 'Int'>
    readonly retryDelay: FieldRef<"Webhook", 'Int'>
    readonly createdAt: FieldRef<"Webhook", 'DateTime'>
    readonly updatedAt: FieldRef<"Webhook", 'DateTime'>
    readonly deletedAt: FieldRef<"Webhook", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Webhook findUnique
   */
  export type WebhookFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Webhook
     */
    select?: WebhookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Webhook
     */
    omit?: WebhookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookInclude<ExtArgs> | null
    /**
     * Filter, which Webhook to fetch.
     */
    where: WebhookWhereUniqueInput
  }

  /**
   * Webhook findUniqueOrThrow
   */
  export type WebhookFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Webhook
     */
    select?: WebhookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Webhook
     */
    omit?: WebhookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookInclude<ExtArgs> | null
    /**
     * Filter, which Webhook to fetch.
     */
    where: WebhookWhereUniqueInput
  }

  /**
   * Webhook findFirst
   */
  export type WebhookFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Webhook
     */
    select?: WebhookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Webhook
     */
    omit?: WebhookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookInclude<ExtArgs> | null
    /**
     * Filter, which Webhook to fetch.
     */
    where?: WebhookWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Webhooks to fetch.
     */
    orderBy?: WebhookOrderByWithRelationInput | WebhookOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Webhooks.
     */
    cursor?: WebhookWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Webhooks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Webhooks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Webhooks.
     */
    distinct?: WebhookScalarFieldEnum | WebhookScalarFieldEnum[]
  }

  /**
   * Webhook findFirstOrThrow
   */
  export type WebhookFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Webhook
     */
    select?: WebhookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Webhook
     */
    omit?: WebhookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookInclude<ExtArgs> | null
    /**
     * Filter, which Webhook to fetch.
     */
    where?: WebhookWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Webhooks to fetch.
     */
    orderBy?: WebhookOrderByWithRelationInput | WebhookOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Webhooks.
     */
    cursor?: WebhookWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Webhooks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Webhooks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Webhooks.
     */
    distinct?: WebhookScalarFieldEnum | WebhookScalarFieldEnum[]
  }

  /**
   * Webhook findMany
   */
  export type WebhookFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Webhook
     */
    select?: WebhookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Webhook
     */
    omit?: WebhookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookInclude<ExtArgs> | null
    /**
     * Filter, which Webhooks to fetch.
     */
    where?: WebhookWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Webhooks to fetch.
     */
    orderBy?: WebhookOrderByWithRelationInput | WebhookOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Webhooks.
     */
    cursor?: WebhookWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Webhooks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Webhooks.
     */
    skip?: number
    distinct?: WebhookScalarFieldEnum | WebhookScalarFieldEnum[]
  }

  /**
   * Webhook create
   */
  export type WebhookCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Webhook
     */
    select?: WebhookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Webhook
     */
    omit?: WebhookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookInclude<ExtArgs> | null
    /**
     * The data needed to create a Webhook.
     */
    data: XOR<WebhookCreateInput, WebhookUncheckedCreateInput>
  }

  /**
   * Webhook createMany
   */
  export type WebhookCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Webhooks.
     */
    data: WebhookCreateManyInput | WebhookCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Webhook createManyAndReturn
   */
  export type WebhookCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Webhook
     */
    select?: WebhookSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Webhook
     */
    omit?: WebhookOmit<ExtArgs> | null
    /**
     * The data used to create many Webhooks.
     */
    data: WebhookCreateManyInput | WebhookCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Webhook update
   */
  export type WebhookUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Webhook
     */
    select?: WebhookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Webhook
     */
    omit?: WebhookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookInclude<ExtArgs> | null
    /**
     * The data needed to update a Webhook.
     */
    data: XOR<WebhookUpdateInput, WebhookUncheckedUpdateInput>
    /**
     * Choose, which Webhook to update.
     */
    where: WebhookWhereUniqueInput
  }

  /**
   * Webhook updateMany
   */
  export type WebhookUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Webhooks.
     */
    data: XOR<WebhookUpdateManyMutationInput, WebhookUncheckedUpdateManyInput>
    /**
     * Filter which Webhooks to update
     */
    where?: WebhookWhereInput
    /**
     * Limit how many Webhooks to update.
     */
    limit?: number
  }

  /**
   * Webhook updateManyAndReturn
   */
  export type WebhookUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Webhook
     */
    select?: WebhookSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Webhook
     */
    omit?: WebhookOmit<ExtArgs> | null
    /**
     * The data used to update Webhooks.
     */
    data: XOR<WebhookUpdateManyMutationInput, WebhookUncheckedUpdateManyInput>
    /**
     * Filter which Webhooks to update
     */
    where?: WebhookWhereInput
    /**
     * Limit how many Webhooks to update.
     */
    limit?: number
  }

  /**
   * Webhook upsert
   */
  export type WebhookUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Webhook
     */
    select?: WebhookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Webhook
     */
    omit?: WebhookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookInclude<ExtArgs> | null
    /**
     * The filter to search for the Webhook to update in case it exists.
     */
    where: WebhookWhereUniqueInput
    /**
     * In case the Webhook found by the `where` argument doesn't exist, create a new Webhook with this data.
     */
    create: XOR<WebhookCreateInput, WebhookUncheckedCreateInput>
    /**
     * In case the Webhook was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WebhookUpdateInput, WebhookUncheckedUpdateInput>
  }

  /**
   * Webhook delete
   */
  export type WebhookDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Webhook
     */
    select?: WebhookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Webhook
     */
    omit?: WebhookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookInclude<ExtArgs> | null
    /**
     * Filter which Webhook to delete.
     */
    where: WebhookWhereUniqueInput
  }

  /**
   * Webhook deleteMany
   */
  export type WebhookDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Webhooks to delete
     */
    where?: WebhookWhereInput
    /**
     * Limit how many Webhooks to delete.
     */
    limit?: number
  }

  /**
   * Webhook.deliveries
   */
  export type Webhook$deliveriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookDelivery
     */
    select?: WebhookDeliverySelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebhookDelivery
     */
    omit?: WebhookDeliveryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookDeliveryInclude<ExtArgs> | null
    where?: WebhookDeliveryWhereInput
    orderBy?: WebhookDeliveryOrderByWithRelationInput | WebhookDeliveryOrderByWithRelationInput[]
    cursor?: WebhookDeliveryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WebhookDeliveryScalarFieldEnum | WebhookDeliveryScalarFieldEnum[]
  }

  /**
   * Webhook without action
   */
  export type WebhookDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Webhook
     */
    select?: WebhookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Webhook
     */
    omit?: WebhookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookInclude<ExtArgs> | null
  }


  /**
   * Model WebhookDelivery
   */

  export type AggregateWebhookDelivery = {
    _count: WebhookDeliveryCountAggregateOutputType | null
    _avg: WebhookDeliveryAvgAggregateOutputType | null
    _sum: WebhookDeliverySumAggregateOutputType | null
    _min: WebhookDeliveryMinAggregateOutputType | null
    _max: WebhookDeliveryMaxAggregateOutputType | null
  }

  export type WebhookDeliveryAvgAggregateOutputType = {
    attempt: number | null
    statusCode: number | null
    responseTime: number | null
  }

  export type WebhookDeliverySumAggregateOutputType = {
    attempt: number | null
    statusCode: number | null
    responseTime: number | null
  }

  export type WebhookDeliveryMinAggregateOutputType = {
    id: string | null
    webhookId: string | null
    event: string | null
    attempt: number | null
    statusCode: number | null
    responseBody: string | null
    responseTime: number | null
    success: boolean | null
    errorMessage: string | null
    deliveredAt: Date | null
    nextRetryAt: Date | null
  }

  export type WebhookDeliveryMaxAggregateOutputType = {
    id: string | null
    webhookId: string | null
    event: string | null
    attempt: number | null
    statusCode: number | null
    responseBody: string | null
    responseTime: number | null
    success: boolean | null
    errorMessage: string | null
    deliveredAt: Date | null
    nextRetryAt: Date | null
  }

  export type WebhookDeliveryCountAggregateOutputType = {
    id: number
    webhookId: number
    event: number
    payload: number
    attempt: number
    statusCode: number
    responseBody: number
    responseTime: number
    success: number
    errorMessage: number
    deliveredAt: number
    nextRetryAt: number
    _all: number
  }


  export type WebhookDeliveryAvgAggregateInputType = {
    attempt?: true
    statusCode?: true
    responseTime?: true
  }

  export type WebhookDeliverySumAggregateInputType = {
    attempt?: true
    statusCode?: true
    responseTime?: true
  }

  export type WebhookDeliveryMinAggregateInputType = {
    id?: true
    webhookId?: true
    event?: true
    attempt?: true
    statusCode?: true
    responseBody?: true
    responseTime?: true
    success?: true
    errorMessage?: true
    deliveredAt?: true
    nextRetryAt?: true
  }

  export type WebhookDeliveryMaxAggregateInputType = {
    id?: true
    webhookId?: true
    event?: true
    attempt?: true
    statusCode?: true
    responseBody?: true
    responseTime?: true
    success?: true
    errorMessage?: true
    deliveredAt?: true
    nextRetryAt?: true
  }

  export type WebhookDeliveryCountAggregateInputType = {
    id?: true
    webhookId?: true
    event?: true
    payload?: true
    attempt?: true
    statusCode?: true
    responseBody?: true
    responseTime?: true
    success?: true
    errorMessage?: true
    deliveredAt?: true
    nextRetryAt?: true
    _all?: true
  }

  export type WebhookDeliveryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WebhookDelivery to aggregate.
     */
    where?: WebhookDeliveryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WebhookDeliveries to fetch.
     */
    orderBy?: WebhookDeliveryOrderByWithRelationInput | WebhookDeliveryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WebhookDeliveryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WebhookDeliveries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WebhookDeliveries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WebhookDeliveries
    **/
    _count?: true | WebhookDeliveryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WebhookDeliveryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WebhookDeliverySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WebhookDeliveryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WebhookDeliveryMaxAggregateInputType
  }

  export type GetWebhookDeliveryAggregateType<T extends WebhookDeliveryAggregateArgs> = {
        [P in keyof T & keyof AggregateWebhookDelivery]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWebhookDelivery[P]>
      : GetScalarType<T[P], AggregateWebhookDelivery[P]>
  }




  export type WebhookDeliveryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WebhookDeliveryWhereInput
    orderBy?: WebhookDeliveryOrderByWithAggregationInput | WebhookDeliveryOrderByWithAggregationInput[]
    by: WebhookDeliveryScalarFieldEnum[] | WebhookDeliveryScalarFieldEnum
    having?: WebhookDeliveryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WebhookDeliveryCountAggregateInputType | true
    _avg?: WebhookDeliveryAvgAggregateInputType
    _sum?: WebhookDeliverySumAggregateInputType
    _min?: WebhookDeliveryMinAggregateInputType
    _max?: WebhookDeliveryMaxAggregateInputType
  }

  export type WebhookDeliveryGroupByOutputType = {
    id: string
    webhookId: string
    event: string
    payload: JsonValue
    attempt: number
    statusCode: number | null
    responseBody: string | null
    responseTime: number | null
    success: boolean
    errorMessage: string | null
    deliveredAt: Date
    nextRetryAt: Date | null
    _count: WebhookDeliveryCountAggregateOutputType | null
    _avg: WebhookDeliveryAvgAggregateOutputType | null
    _sum: WebhookDeliverySumAggregateOutputType | null
    _min: WebhookDeliveryMinAggregateOutputType | null
    _max: WebhookDeliveryMaxAggregateOutputType | null
  }

  type GetWebhookDeliveryGroupByPayload<T extends WebhookDeliveryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WebhookDeliveryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WebhookDeliveryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WebhookDeliveryGroupByOutputType[P]>
            : GetScalarType<T[P], WebhookDeliveryGroupByOutputType[P]>
        }
      >
    >


  export type WebhookDeliverySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    webhookId?: boolean
    event?: boolean
    payload?: boolean
    attempt?: boolean
    statusCode?: boolean
    responseBody?: boolean
    responseTime?: boolean
    success?: boolean
    errorMessage?: boolean
    deliveredAt?: boolean
    nextRetryAt?: boolean
    webhook?: boolean | WebhookDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["webhookDelivery"]>

  export type WebhookDeliverySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    webhookId?: boolean
    event?: boolean
    payload?: boolean
    attempt?: boolean
    statusCode?: boolean
    responseBody?: boolean
    responseTime?: boolean
    success?: boolean
    errorMessage?: boolean
    deliveredAt?: boolean
    nextRetryAt?: boolean
    webhook?: boolean | WebhookDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["webhookDelivery"]>

  export type WebhookDeliverySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    webhookId?: boolean
    event?: boolean
    payload?: boolean
    attempt?: boolean
    statusCode?: boolean
    responseBody?: boolean
    responseTime?: boolean
    success?: boolean
    errorMessage?: boolean
    deliveredAt?: boolean
    nextRetryAt?: boolean
    webhook?: boolean | WebhookDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["webhookDelivery"]>

  export type WebhookDeliverySelectScalar = {
    id?: boolean
    webhookId?: boolean
    event?: boolean
    payload?: boolean
    attempt?: boolean
    statusCode?: boolean
    responseBody?: boolean
    responseTime?: boolean
    success?: boolean
    errorMessage?: boolean
    deliveredAt?: boolean
    nextRetryAt?: boolean
  }

  export type WebhookDeliveryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "webhookId" | "event" | "payload" | "attempt" | "statusCode" | "responseBody" | "responseTime" | "success" | "errorMessage" | "deliveredAt" | "nextRetryAt", ExtArgs["result"]["webhookDelivery"]>
  export type WebhookDeliveryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    webhook?: boolean | WebhookDefaultArgs<ExtArgs>
  }
  export type WebhookDeliveryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    webhook?: boolean | WebhookDefaultArgs<ExtArgs>
  }
  export type WebhookDeliveryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    webhook?: boolean | WebhookDefaultArgs<ExtArgs>
  }

  export type $WebhookDeliveryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WebhookDelivery"
    objects: {
      webhook: Prisma.$WebhookPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      webhookId: string
      event: string
      payload: Prisma.JsonValue
      attempt: number
      statusCode: number | null
      responseBody: string | null
      responseTime: number | null
      success: boolean
      errorMessage: string | null
      deliveredAt: Date
      nextRetryAt: Date | null
    }, ExtArgs["result"]["webhookDelivery"]>
    composites: {}
  }

  type WebhookDeliveryGetPayload<S extends boolean | null | undefined | WebhookDeliveryDefaultArgs> = $Result.GetResult<Prisma.$WebhookDeliveryPayload, S>

  type WebhookDeliveryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WebhookDeliveryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WebhookDeliveryCountAggregateInputType | true
    }

  export interface WebhookDeliveryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WebhookDelivery'], meta: { name: 'WebhookDelivery' } }
    /**
     * Find zero or one WebhookDelivery that matches the filter.
     * @param {WebhookDeliveryFindUniqueArgs} args - Arguments to find a WebhookDelivery
     * @example
     * // Get one WebhookDelivery
     * const webhookDelivery = await prisma.webhookDelivery.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WebhookDeliveryFindUniqueArgs>(args: SelectSubset<T, WebhookDeliveryFindUniqueArgs<ExtArgs>>): Prisma__WebhookDeliveryClient<$Result.GetResult<Prisma.$WebhookDeliveryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one WebhookDelivery that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WebhookDeliveryFindUniqueOrThrowArgs} args - Arguments to find a WebhookDelivery
     * @example
     * // Get one WebhookDelivery
     * const webhookDelivery = await prisma.webhookDelivery.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WebhookDeliveryFindUniqueOrThrowArgs>(args: SelectSubset<T, WebhookDeliveryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WebhookDeliveryClient<$Result.GetResult<Prisma.$WebhookDeliveryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WebhookDelivery that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookDeliveryFindFirstArgs} args - Arguments to find a WebhookDelivery
     * @example
     * // Get one WebhookDelivery
     * const webhookDelivery = await prisma.webhookDelivery.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WebhookDeliveryFindFirstArgs>(args?: SelectSubset<T, WebhookDeliveryFindFirstArgs<ExtArgs>>): Prisma__WebhookDeliveryClient<$Result.GetResult<Prisma.$WebhookDeliveryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WebhookDelivery that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookDeliveryFindFirstOrThrowArgs} args - Arguments to find a WebhookDelivery
     * @example
     * // Get one WebhookDelivery
     * const webhookDelivery = await prisma.webhookDelivery.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WebhookDeliveryFindFirstOrThrowArgs>(args?: SelectSubset<T, WebhookDeliveryFindFirstOrThrowArgs<ExtArgs>>): Prisma__WebhookDeliveryClient<$Result.GetResult<Prisma.$WebhookDeliveryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more WebhookDeliveries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookDeliveryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WebhookDeliveries
     * const webhookDeliveries = await prisma.webhookDelivery.findMany()
     * 
     * // Get first 10 WebhookDeliveries
     * const webhookDeliveries = await prisma.webhookDelivery.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const webhookDeliveryWithIdOnly = await prisma.webhookDelivery.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WebhookDeliveryFindManyArgs>(args?: SelectSubset<T, WebhookDeliveryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WebhookDeliveryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a WebhookDelivery.
     * @param {WebhookDeliveryCreateArgs} args - Arguments to create a WebhookDelivery.
     * @example
     * // Create one WebhookDelivery
     * const WebhookDelivery = await prisma.webhookDelivery.create({
     *   data: {
     *     // ... data to create a WebhookDelivery
     *   }
     * })
     * 
     */
    create<T extends WebhookDeliveryCreateArgs>(args: SelectSubset<T, WebhookDeliveryCreateArgs<ExtArgs>>): Prisma__WebhookDeliveryClient<$Result.GetResult<Prisma.$WebhookDeliveryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many WebhookDeliveries.
     * @param {WebhookDeliveryCreateManyArgs} args - Arguments to create many WebhookDeliveries.
     * @example
     * // Create many WebhookDeliveries
     * const webhookDelivery = await prisma.webhookDelivery.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WebhookDeliveryCreateManyArgs>(args?: SelectSubset<T, WebhookDeliveryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WebhookDeliveries and returns the data saved in the database.
     * @param {WebhookDeliveryCreateManyAndReturnArgs} args - Arguments to create many WebhookDeliveries.
     * @example
     * // Create many WebhookDeliveries
     * const webhookDelivery = await prisma.webhookDelivery.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WebhookDeliveries and only return the `id`
     * const webhookDeliveryWithIdOnly = await prisma.webhookDelivery.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WebhookDeliveryCreateManyAndReturnArgs>(args?: SelectSubset<T, WebhookDeliveryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WebhookDeliveryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a WebhookDelivery.
     * @param {WebhookDeliveryDeleteArgs} args - Arguments to delete one WebhookDelivery.
     * @example
     * // Delete one WebhookDelivery
     * const WebhookDelivery = await prisma.webhookDelivery.delete({
     *   where: {
     *     // ... filter to delete one WebhookDelivery
     *   }
     * })
     * 
     */
    delete<T extends WebhookDeliveryDeleteArgs>(args: SelectSubset<T, WebhookDeliveryDeleteArgs<ExtArgs>>): Prisma__WebhookDeliveryClient<$Result.GetResult<Prisma.$WebhookDeliveryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one WebhookDelivery.
     * @param {WebhookDeliveryUpdateArgs} args - Arguments to update one WebhookDelivery.
     * @example
     * // Update one WebhookDelivery
     * const webhookDelivery = await prisma.webhookDelivery.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WebhookDeliveryUpdateArgs>(args: SelectSubset<T, WebhookDeliveryUpdateArgs<ExtArgs>>): Prisma__WebhookDeliveryClient<$Result.GetResult<Prisma.$WebhookDeliveryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more WebhookDeliveries.
     * @param {WebhookDeliveryDeleteManyArgs} args - Arguments to filter WebhookDeliveries to delete.
     * @example
     * // Delete a few WebhookDeliveries
     * const { count } = await prisma.webhookDelivery.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WebhookDeliveryDeleteManyArgs>(args?: SelectSubset<T, WebhookDeliveryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WebhookDeliveries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookDeliveryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WebhookDeliveries
     * const webhookDelivery = await prisma.webhookDelivery.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WebhookDeliveryUpdateManyArgs>(args: SelectSubset<T, WebhookDeliveryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WebhookDeliveries and returns the data updated in the database.
     * @param {WebhookDeliveryUpdateManyAndReturnArgs} args - Arguments to update many WebhookDeliveries.
     * @example
     * // Update many WebhookDeliveries
     * const webhookDelivery = await prisma.webhookDelivery.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more WebhookDeliveries and only return the `id`
     * const webhookDeliveryWithIdOnly = await prisma.webhookDelivery.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WebhookDeliveryUpdateManyAndReturnArgs>(args: SelectSubset<T, WebhookDeliveryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WebhookDeliveryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one WebhookDelivery.
     * @param {WebhookDeliveryUpsertArgs} args - Arguments to update or create a WebhookDelivery.
     * @example
     * // Update or create a WebhookDelivery
     * const webhookDelivery = await prisma.webhookDelivery.upsert({
     *   create: {
     *     // ... data to create a WebhookDelivery
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WebhookDelivery we want to update
     *   }
     * })
     */
    upsert<T extends WebhookDeliveryUpsertArgs>(args: SelectSubset<T, WebhookDeliveryUpsertArgs<ExtArgs>>): Prisma__WebhookDeliveryClient<$Result.GetResult<Prisma.$WebhookDeliveryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of WebhookDeliveries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookDeliveryCountArgs} args - Arguments to filter WebhookDeliveries to count.
     * @example
     * // Count the number of WebhookDeliveries
     * const count = await prisma.webhookDelivery.count({
     *   where: {
     *     // ... the filter for the WebhookDeliveries we want to count
     *   }
     * })
    **/
    count<T extends WebhookDeliveryCountArgs>(
      args?: Subset<T, WebhookDeliveryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WebhookDeliveryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WebhookDelivery.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookDeliveryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WebhookDeliveryAggregateArgs>(args: Subset<T, WebhookDeliveryAggregateArgs>): Prisma.PrismaPromise<GetWebhookDeliveryAggregateType<T>>

    /**
     * Group by WebhookDelivery.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookDeliveryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WebhookDeliveryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WebhookDeliveryGroupByArgs['orderBy'] }
        : { orderBy?: WebhookDeliveryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WebhookDeliveryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWebhookDeliveryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WebhookDelivery model
   */
  readonly fields: WebhookDeliveryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WebhookDelivery.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WebhookDeliveryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    webhook<T extends WebhookDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WebhookDefaultArgs<ExtArgs>>): Prisma__WebhookClient<$Result.GetResult<Prisma.$WebhookPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WebhookDelivery model
   */
  interface WebhookDeliveryFieldRefs {
    readonly id: FieldRef<"WebhookDelivery", 'String'>
    readonly webhookId: FieldRef<"WebhookDelivery", 'String'>
    readonly event: FieldRef<"WebhookDelivery", 'String'>
    readonly payload: FieldRef<"WebhookDelivery", 'Json'>
    readonly attempt: FieldRef<"WebhookDelivery", 'Int'>
    readonly statusCode: FieldRef<"WebhookDelivery", 'Int'>
    readonly responseBody: FieldRef<"WebhookDelivery", 'String'>
    readonly responseTime: FieldRef<"WebhookDelivery", 'Int'>
    readonly success: FieldRef<"WebhookDelivery", 'Boolean'>
    readonly errorMessage: FieldRef<"WebhookDelivery", 'String'>
    readonly deliveredAt: FieldRef<"WebhookDelivery", 'DateTime'>
    readonly nextRetryAt: FieldRef<"WebhookDelivery", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * WebhookDelivery findUnique
   */
  export type WebhookDeliveryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookDelivery
     */
    select?: WebhookDeliverySelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebhookDelivery
     */
    omit?: WebhookDeliveryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookDeliveryInclude<ExtArgs> | null
    /**
     * Filter, which WebhookDelivery to fetch.
     */
    where: WebhookDeliveryWhereUniqueInput
  }

  /**
   * WebhookDelivery findUniqueOrThrow
   */
  export type WebhookDeliveryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookDelivery
     */
    select?: WebhookDeliverySelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebhookDelivery
     */
    omit?: WebhookDeliveryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookDeliveryInclude<ExtArgs> | null
    /**
     * Filter, which WebhookDelivery to fetch.
     */
    where: WebhookDeliveryWhereUniqueInput
  }

  /**
   * WebhookDelivery findFirst
   */
  export type WebhookDeliveryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookDelivery
     */
    select?: WebhookDeliverySelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebhookDelivery
     */
    omit?: WebhookDeliveryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookDeliveryInclude<ExtArgs> | null
    /**
     * Filter, which WebhookDelivery to fetch.
     */
    where?: WebhookDeliveryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WebhookDeliveries to fetch.
     */
    orderBy?: WebhookDeliveryOrderByWithRelationInput | WebhookDeliveryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WebhookDeliveries.
     */
    cursor?: WebhookDeliveryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WebhookDeliveries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WebhookDeliveries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WebhookDeliveries.
     */
    distinct?: WebhookDeliveryScalarFieldEnum | WebhookDeliveryScalarFieldEnum[]
  }

  /**
   * WebhookDelivery findFirstOrThrow
   */
  export type WebhookDeliveryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookDelivery
     */
    select?: WebhookDeliverySelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebhookDelivery
     */
    omit?: WebhookDeliveryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookDeliveryInclude<ExtArgs> | null
    /**
     * Filter, which WebhookDelivery to fetch.
     */
    where?: WebhookDeliveryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WebhookDeliveries to fetch.
     */
    orderBy?: WebhookDeliveryOrderByWithRelationInput | WebhookDeliveryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WebhookDeliveries.
     */
    cursor?: WebhookDeliveryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WebhookDeliveries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WebhookDeliveries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WebhookDeliveries.
     */
    distinct?: WebhookDeliveryScalarFieldEnum | WebhookDeliveryScalarFieldEnum[]
  }

  /**
   * WebhookDelivery findMany
   */
  export type WebhookDeliveryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookDelivery
     */
    select?: WebhookDeliverySelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebhookDelivery
     */
    omit?: WebhookDeliveryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookDeliveryInclude<ExtArgs> | null
    /**
     * Filter, which WebhookDeliveries to fetch.
     */
    where?: WebhookDeliveryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WebhookDeliveries to fetch.
     */
    orderBy?: WebhookDeliveryOrderByWithRelationInput | WebhookDeliveryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WebhookDeliveries.
     */
    cursor?: WebhookDeliveryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WebhookDeliveries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WebhookDeliveries.
     */
    skip?: number
    distinct?: WebhookDeliveryScalarFieldEnum | WebhookDeliveryScalarFieldEnum[]
  }

  /**
   * WebhookDelivery create
   */
  export type WebhookDeliveryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookDelivery
     */
    select?: WebhookDeliverySelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebhookDelivery
     */
    omit?: WebhookDeliveryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookDeliveryInclude<ExtArgs> | null
    /**
     * The data needed to create a WebhookDelivery.
     */
    data: XOR<WebhookDeliveryCreateInput, WebhookDeliveryUncheckedCreateInput>
  }

  /**
   * WebhookDelivery createMany
   */
  export type WebhookDeliveryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WebhookDeliveries.
     */
    data: WebhookDeliveryCreateManyInput | WebhookDeliveryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WebhookDelivery createManyAndReturn
   */
  export type WebhookDeliveryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookDelivery
     */
    select?: WebhookDeliverySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WebhookDelivery
     */
    omit?: WebhookDeliveryOmit<ExtArgs> | null
    /**
     * The data used to create many WebhookDeliveries.
     */
    data: WebhookDeliveryCreateManyInput | WebhookDeliveryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookDeliveryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WebhookDelivery update
   */
  export type WebhookDeliveryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookDelivery
     */
    select?: WebhookDeliverySelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebhookDelivery
     */
    omit?: WebhookDeliveryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookDeliveryInclude<ExtArgs> | null
    /**
     * The data needed to update a WebhookDelivery.
     */
    data: XOR<WebhookDeliveryUpdateInput, WebhookDeliveryUncheckedUpdateInput>
    /**
     * Choose, which WebhookDelivery to update.
     */
    where: WebhookDeliveryWhereUniqueInput
  }

  /**
   * WebhookDelivery updateMany
   */
  export type WebhookDeliveryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WebhookDeliveries.
     */
    data: XOR<WebhookDeliveryUpdateManyMutationInput, WebhookDeliveryUncheckedUpdateManyInput>
    /**
     * Filter which WebhookDeliveries to update
     */
    where?: WebhookDeliveryWhereInput
    /**
     * Limit how many WebhookDeliveries to update.
     */
    limit?: number
  }

  /**
   * WebhookDelivery updateManyAndReturn
   */
  export type WebhookDeliveryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookDelivery
     */
    select?: WebhookDeliverySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WebhookDelivery
     */
    omit?: WebhookDeliveryOmit<ExtArgs> | null
    /**
     * The data used to update WebhookDeliveries.
     */
    data: XOR<WebhookDeliveryUpdateManyMutationInput, WebhookDeliveryUncheckedUpdateManyInput>
    /**
     * Filter which WebhookDeliveries to update
     */
    where?: WebhookDeliveryWhereInput
    /**
     * Limit how many WebhookDeliveries to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookDeliveryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * WebhookDelivery upsert
   */
  export type WebhookDeliveryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookDelivery
     */
    select?: WebhookDeliverySelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebhookDelivery
     */
    omit?: WebhookDeliveryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookDeliveryInclude<ExtArgs> | null
    /**
     * The filter to search for the WebhookDelivery to update in case it exists.
     */
    where: WebhookDeliveryWhereUniqueInput
    /**
     * In case the WebhookDelivery found by the `where` argument doesn't exist, create a new WebhookDelivery with this data.
     */
    create: XOR<WebhookDeliveryCreateInput, WebhookDeliveryUncheckedCreateInput>
    /**
     * In case the WebhookDelivery was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WebhookDeliveryUpdateInput, WebhookDeliveryUncheckedUpdateInput>
  }

  /**
   * WebhookDelivery delete
   */
  export type WebhookDeliveryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookDelivery
     */
    select?: WebhookDeliverySelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebhookDelivery
     */
    omit?: WebhookDeliveryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookDeliveryInclude<ExtArgs> | null
    /**
     * Filter which WebhookDelivery to delete.
     */
    where: WebhookDeliveryWhereUniqueInput
  }

  /**
   * WebhookDelivery deleteMany
   */
  export type WebhookDeliveryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WebhookDeliveries to delete
     */
    where?: WebhookDeliveryWhereInput
    /**
     * Limit how many WebhookDeliveries to delete.
     */
    limit?: number
  }

  /**
   * WebhookDelivery without action
   */
  export type WebhookDeliveryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookDelivery
     */
    select?: WebhookDeliverySelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebhookDelivery
     */
    omit?: WebhookDeliveryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookDeliveryInclude<ExtArgs> | null
  }


  /**
   * Model Schedule
   */

  export type AggregateSchedule = {
    _count: ScheduleCountAggregateOutputType | null
    _avg: ScheduleAvgAggregateOutputType | null
    _sum: ScheduleSumAggregateOutputType | null
    _min: ScheduleMinAggregateOutputType | null
    _max: ScheduleMaxAggregateOutputType | null
  }

  export type ScheduleAvgAggregateOutputType = {
    maxConcurrentRuns: number | null
  }

  export type ScheduleSumAggregateOutputType = {
    maxConcurrentRuns: number | null
  }

  export type ScheduleMinAggregateOutputType = {
    id: string | null
    organizationId: string | null
    workflowId: string | null
    name: string | null
    description: string | null
    cronExpression: string | null
    timezone: string | null
    enabled: boolean | null
    nextExecutionTime: Date | null
    lastExecutionTime: Date | null
    lastExecutionStatus: string | null
    eventBridgeRuleArn: string | null
    eventBridgeRuleName: string | null
    maxConcurrentRuns: number | null
    createdAt: Date | null
    updatedAt: Date | null
    createdBy: string | null
    updatedBy: string | null
    deletedAt: Date | null
  }

  export type ScheduleMaxAggregateOutputType = {
    id: string | null
    organizationId: string | null
    workflowId: string | null
    name: string | null
    description: string | null
    cronExpression: string | null
    timezone: string | null
    enabled: boolean | null
    nextExecutionTime: Date | null
    lastExecutionTime: Date | null
    lastExecutionStatus: string | null
    eventBridgeRuleArn: string | null
    eventBridgeRuleName: string | null
    maxConcurrentRuns: number | null
    createdAt: Date | null
    updatedAt: Date | null
    createdBy: string | null
    updatedBy: string | null
    deletedAt: Date | null
  }

  export type ScheduleCountAggregateOutputType = {
    id: number
    organizationId: number
    workflowId: number
    name: number
    description: number
    cronExpression: number
    timezone: number
    enabled: number
    nextExecutionTime: number
    lastExecutionTime: number
    lastExecutionStatus: number
    eventBridgeRuleArn: number
    eventBridgeRuleName: number
    executionWindow: number
    maxConcurrentRuns: number
    retryPolicy: number
    dependencies: number
    notificationConfig: number
    tags: number
    metadata: number
    createdAt: number
    updatedAt: number
    createdBy: number
    updatedBy: number
    deletedAt: number
    _all: number
  }


  export type ScheduleAvgAggregateInputType = {
    maxConcurrentRuns?: true
  }

  export type ScheduleSumAggregateInputType = {
    maxConcurrentRuns?: true
  }

  export type ScheduleMinAggregateInputType = {
    id?: true
    organizationId?: true
    workflowId?: true
    name?: true
    description?: true
    cronExpression?: true
    timezone?: true
    enabled?: true
    nextExecutionTime?: true
    lastExecutionTime?: true
    lastExecutionStatus?: true
    eventBridgeRuleArn?: true
    eventBridgeRuleName?: true
    maxConcurrentRuns?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    updatedBy?: true
    deletedAt?: true
  }

  export type ScheduleMaxAggregateInputType = {
    id?: true
    organizationId?: true
    workflowId?: true
    name?: true
    description?: true
    cronExpression?: true
    timezone?: true
    enabled?: true
    nextExecutionTime?: true
    lastExecutionTime?: true
    lastExecutionStatus?: true
    eventBridgeRuleArn?: true
    eventBridgeRuleName?: true
    maxConcurrentRuns?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    updatedBy?: true
    deletedAt?: true
  }

  export type ScheduleCountAggregateInputType = {
    id?: true
    organizationId?: true
    workflowId?: true
    name?: true
    description?: true
    cronExpression?: true
    timezone?: true
    enabled?: true
    nextExecutionTime?: true
    lastExecutionTime?: true
    lastExecutionStatus?: true
    eventBridgeRuleArn?: true
    eventBridgeRuleName?: true
    executionWindow?: true
    maxConcurrentRuns?: true
    retryPolicy?: true
    dependencies?: true
    notificationConfig?: true
    tags?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    updatedBy?: true
    deletedAt?: true
    _all?: true
  }

  export type ScheduleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Schedule to aggregate.
     */
    where?: ScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Schedules to fetch.
     */
    orderBy?: ScheduleOrderByWithRelationInput | ScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Schedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Schedules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Schedules
    **/
    _count?: true | ScheduleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ScheduleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ScheduleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ScheduleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ScheduleMaxAggregateInputType
  }

  export type GetScheduleAggregateType<T extends ScheduleAggregateArgs> = {
        [P in keyof T & keyof AggregateSchedule]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSchedule[P]>
      : GetScalarType<T[P], AggregateSchedule[P]>
  }




  export type ScheduleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ScheduleWhereInput
    orderBy?: ScheduleOrderByWithAggregationInput | ScheduleOrderByWithAggregationInput[]
    by: ScheduleScalarFieldEnum[] | ScheduleScalarFieldEnum
    having?: ScheduleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ScheduleCountAggregateInputType | true
    _avg?: ScheduleAvgAggregateInputType
    _sum?: ScheduleSumAggregateInputType
    _min?: ScheduleMinAggregateInputType
    _max?: ScheduleMaxAggregateInputType
  }

  export type ScheduleGroupByOutputType = {
    id: string
    organizationId: string
    workflowId: string
    name: string
    description: string | null
    cronExpression: string
    timezone: string
    enabled: boolean
    nextExecutionTime: Date | null
    lastExecutionTime: Date | null
    lastExecutionStatus: string | null
    eventBridgeRuleArn: string | null
    eventBridgeRuleName: string | null
    executionWindow: JsonValue | null
    maxConcurrentRuns: number
    retryPolicy: JsonValue | null
    dependencies: JsonValue | null
    notificationConfig: JsonValue | null
    tags: string[]
    metadata: JsonValue | null
    createdAt: Date
    updatedAt: Date
    createdBy: string
    updatedBy: string | null
    deletedAt: Date | null
    _count: ScheduleCountAggregateOutputType | null
    _avg: ScheduleAvgAggregateOutputType | null
    _sum: ScheduleSumAggregateOutputType | null
    _min: ScheduleMinAggregateOutputType | null
    _max: ScheduleMaxAggregateOutputType | null
  }

  type GetScheduleGroupByPayload<T extends ScheduleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ScheduleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ScheduleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ScheduleGroupByOutputType[P]>
            : GetScalarType<T[P], ScheduleGroupByOutputType[P]>
        }
      >
    >


  export type ScheduleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organizationId?: boolean
    workflowId?: boolean
    name?: boolean
    description?: boolean
    cronExpression?: boolean
    timezone?: boolean
    enabled?: boolean
    nextExecutionTime?: boolean
    lastExecutionTime?: boolean
    lastExecutionStatus?: boolean
    eventBridgeRuleArn?: boolean
    eventBridgeRuleName?: boolean
    executionWindow?: boolean
    maxConcurrentRuns?: boolean
    retryPolicy?: boolean
    dependencies?: boolean
    notificationConfig?: boolean
    tags?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    deletedAt?: boolean
    workflow?: boolean | WorkflowDefaultArgs<ExtArgs>
    executions?: boolean | Schedule$executionsArgs<ExtArgs>
    auditLogs?: boolean | Schedule$auditLogsArgs<ExtArgs>
    _count?: boolean | ScheduleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["schedule"]>

  export type ScheduleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organizationId?: boolean
    workflowId?: boolean
    name?: boolean
    description?: boolean
    cronExpression?: boolean
    timezone?: boolean
    enabled?: boolean
    nextExecutionTime?: boolean
    lastExecutionTime?: boolean
    lastExecutionStatus?: boolean
    eventBridgeRuleArn?: boolean
    eventBridgeRuleName?: boolean
    executionWindow?: boolean
    maxConcurrentRuns?: boolean
    retryPolicy?: boolean
    dependencies?: boolean
    notificationConfig?: boolean
    tags?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    deletedAt?: boolean
    workflow?: boolean | WorkflowDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["schedule"]>

  export type ScheduleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organizationId?: boolean
    workflowId?: boolean
    name?: boolean
    description?: boolean
    cronExpression?: boolean
    timezone?: boolean
    enabled?: boolean
    nextExecutionTime?: boolean
    lastExecutionTime?: boolean
    lastExecutionStatus?: boolean
    eventBridgeRuleArn?: boolean
    eventBridgeRuleName?: boolean
    executionWindow?: boolean
    maxConcurrentRuns?: boolean
    retryPolicy?: boolean
    dependencies?: boolean
    notificationConfig?: boolean
    tags?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    deletedAt?: boolean
    workflow?: boolean | WorkflowDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["schedule"]>

  export type ScheduleSelectScalar = {
    id?: boolean
    organizationId?: boolean
    workflowId?: boolean
    name?: boolean
    description?: boolean
    cronExpression?: boolean
    timezone?: boolean
    enabled?: boolean
    nextExecutionTime?: boolean
    lastExecutionTime?: boolean
    lastExecutionStatus?: boolean
    eventBridgeRuleArn?: boolean
    eventBridgeRuleName?: boolean
    executionWindow?: boolean
    maxConcurrentRuns?: boolean
    retryPolicy?: boolean
    dependencies?: boolean
    notificationConfig?: boolean
    tags?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    deletedAt?: boolean
  }

  export type ScheduleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "organizationId" | "workflowId" | "name" | "description" | "cronExpression" | "timezone" | "enabled" | "nextExecutionTime" | "lastExecutionTime" | "lastExecutionStatus" | "eventBridgeRuleArn" | "eventBridgeRuleName" | "executionWindow" | "maxConcurrentRuns" | "retryPolicy" | "dependencies" | "notificationConfig" | "tags" | "metadata" | "createdAt" | "updatedAt" | "createdBy" | "updatedBy" | "deletedAt", ExtArgs["result"]["schedule"]>
  export type ScheduleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workflow?: boolean | WorkflowDefaultArgs<ExtArgs>
    executions?: boolean | Schedule$executionsArgs<ExtArgs>
    auditLogs?: boolean | Schedule$auditLogsArgs<ExtArgs>
    _count?: boolean | ScheduleCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ScheduleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workflow?: boolean | WorkflowDefaultArgs<ExtArgs>
  }
  export type ScheduleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workflow?: boolean | WorkflowDefaultArgs<ExtArgs>
  }

  export type $SchedulePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Schedule"
    objects: {
      workflow: Prisma.$WorkflowPayload<ExtArgs>
      executions: Prisma.$ScheduleExecutionPayload<ExtArgs>[]
      auditLogs: Prisma.$ScheduleAuditLogPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      organizationId: string
      workflowId: string
      name: string
      description: string | null
      cronExpression: string
      timezone: string
      enabled: boolean
      nextExecutionTime: Date | null
      lastExecutionTime: Date | null
      lastExecutionStatus: string | null
      eventBridgeRuleArn: string | null
      eventBridgeRuleName: string | null
      executionWindow: Prisma.JsonValue | null
      maxConcurrentRuns: number
      retryPolicy: Prisma.JsonValue | null
      dependencies: Prisma.JsonValue | null
      notificationConfig: Prisma.JsonValue | null
      tags: string[]
      metadata: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
      createdBy: string
      updatedBy: string | null
      deletedAt: Date | null
    }, ExtArgs["result"]["schedule"]>
    composites: {}
  }

  type ScheduleGetPayload<S extends boolean | null | undefined | ScheduleDefaultArgs> = $Result.GetResult<Prisma.$SchedulePayload, S>

  type ScheduleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ScheduleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ScheduleCountAggregateInputType | true
    }

  export interface ScheduleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Schedule'], meta: { name: 'Schedule' } }
    /**
     * Find zero or one Schedule that matches the filter.
     * @param {ScheduleFindUniqueArgs} args - Arguments to find a Schedule
     * @example
     * // Get one Schedule
     * const schedule = await prisma.schedule.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ScheduleFindUniqueArgs>(args: SelectSubset<T, ScheduleFindUniqueArgs<ExtArgs>>): Prisma__ScheduleClient<$Result.GetResult<Prisma.$SchedulePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Schedule that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ScheduleFindUniqueOrThrowArgs} args - Arguments to find a Schedule
     * @example
     * // Get one Schedule
     * const schedule = await prisma.schedule.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ScheduleFindUniqueOrThrowArgs>(args: SelectSubset<T, ScheduleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ScheduleClient<$Result.GetResult<Prisma.$SchedulePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Schedule that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleFindFirstArgs} args - Arguments to find a Schedule
     * @example
     * // Get one Schedule
     * const schedule = await prisma.schedule.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ScheduleFindFirstArgs>(args?: SelectSubset<T, ScheduleFindFirstArgs<ExtArgs>>): Prisma__ScheduleClient<$Result.GetResult<Prisma.$SchedulePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Schedule that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleFindFirstOrThrowArgs} args - Arguments to find a Schedule
     * @example
     * // Get one Schedule
     * const schedule = await prisma.schedule.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ScheduleFindFirstOrThrowArgs>(args?: SelectSubset<T, ScheduleFindFirstOrThrowArgs<ExtArgs>>): Prisma__ScheduleClient<$Result.GetResult<Prisma.$SchedulePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Schedules that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Schedules
     * const schedules = await prisma.schedule.findMany()
     * 
     * // Get first 10 Schedules
     * const schedules = await prisma.schedule.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const scheduleWithIdOnly = await prisma.schedule.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ScheduleFindManyArgs>(args?: SelectSubset<T, ScheduleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SchedulePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Schedule.
     * @param {ScheduleCreateArgs} args - Arguments to create a Schedule.
     * @example
     * // Create one Schedule
     * const Schedule = await prisma.schedule.create({
     *   data: {
     *     // ... data to create a Schedule
     *   }
     * })
     * 
     */
    create<T extends ScheduleCreateArgs>(args: SelectSubset<T, ScheduleCreateArgs<ExtArgs>>): Prisma__ScheduleClient<$Result.GetResult<Prisma.$SchedulePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Schedules.
     * @param {ScheduleCreateManyArgs} args - Arguments to create many Schedules.
     * @example
     * // Create many Schedules
     * const schedule = await prisma.schedule.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ScheduleCreateManyArgs>(args?: SelectSubset<T, ScheduleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Schedules and returns the data saved in the database.
     * @param {ScheduleCreateManyAndReturnArgs} args - Arguments to create many Schedules.
     * @example
     * // Create many Schedules
     * const schedule = await prisma.schedule.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Schedules and only return the `id`
     * const scheduleWithIdOnly = await prisma.schedule.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ScheduleCreateManyAndReturnArgs>(args?: SelectSubset<T, ScheduleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SchedulePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Schedule.
     * @param {ScheduleDeleteArgs} args - Arguments to delete one Schedule.
     * @example
     * // Delete one Schedule
     * const Schedule = await prisma.schedule.delete({
     *   where: {
     *     // ... filter to delete one Schedule
     *   }
     * })
     * 
     */
    delete<T extends ScheduleDeleteArgs>(args: SelectSubset<T, ScheduleDeleteArgs<ExtArgs>>): Prisma__ScheduleClient<$Result.GetResult<Prisma.$SchedulePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Schedule.
     * @param {ScheduleUpdateArgs} args - Arguments to update one Schedule.
     * @example
     * // Update one Schedule
     * const schedule = await prisma.schedule.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ScheduleUpdateArgs>(args: SelectSubset<T, ScheduleUpdateArgs<ExtArgs>>): Prisma__ScheduleClient<$Result.GetResult<Prisma.$SchedulePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Schedules.
     * @param {ScheduleDeleteManyArgs} args - Arguments to filter Schedules to delete.
     * @example
     * // Delete a few Schedules
     * const { count } = await prisma.schedule.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ScheduleDeleteManyArgs>(args?: SelectSubset<T, ScheduleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Schedules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Schedules
     * const schedule = await prisma.schedule.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ScheduleUpdateManyArgs>(args: SelectSubset<T, ScheduleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Schedules and returns the data updated in the database.
     * @param {ScheduleUpdateManyAndReturnArgs} args - Arguments to update many Schedules.
     * @example
     * // Update many Schedules
     * const schedule = await prisma.schedule.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Schedules and only return the `id`
     * const scheduleWithIdOnly = await prisma.schedule.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ScheduleUpdateManyAndReturnArgs>(args: SelectSubset<T, ScheduleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SchedulePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Schedule.
     * @param {ScheduleUpsertArgs} args - Arguments to update or create a Schedule.
     * @example
     * // Update or create a Schedule
     * const schedule = await prisma.schedule.upsert({
     *   create: {
     *     // ... data to create a Schedule
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Schedule we want to update
     *   }
     * })
     */
    upsert<T extends ScheduleUpsertArgs>(args: SelectSubset<T, ScheduleUpsertArgs<ExtArgs>>): Prisma__ScheduleClient<$Result.GetResult<Prisma.$SchedulePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Schedules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleCountArgs} args - Arguments to filter Schedules to count.
     * @example
     * // Count the number of Schedules
     * const count = await prisma.schedule.count({
     *   where: {
     *     // ... the filter for the Schedules we want to count
     *   }
     * })
    **/
    count<T extends ScheduleCountArgs>(
      args?: Subset<T, ScheduleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ScheduleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Schedule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ScheduleAggregateArgs>(args: Subset<T, ScheduleAggregateArgs>): Prisma.PrismaPromise<GetScheduleAggregateType<T>>

    /**
     * Group by Schedule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ScheduleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ScheduleGroupByArgs['orderBy'] }
        : { orderBy?: ScheduleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ScheduleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetScheduleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Schedule model
   */
  readonly fields: ScheduleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Schedule.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ScheduleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    workflow<T extends WorkflowDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkflowDefaultArgs<ExtArgs>>): Prisma__WorkflowClient<$Result.GetResult<Prisma.$WorkflowPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    executions<T extends Schedule$executionsArgs<ExtArgs> = {}>(args?: Subset<T, Schedule$executionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScheduleExecutionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    auditLogs<T extends Schedule$auditLogsArgs<ExtArgs> = {}>(args?: Subset<T, Schedule$auditLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScheduleAuditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Schedule model
   */
  interface ScheduleFieldRefs {
    readonly id: FieldRef<"Schedule", 'String'>
    readonly organizationId: FieldRef<"Schedule", 'String'>
    readonly workflowId: FieldRef<"Schedule", 'String'>
    readonly name: FieldRef<"Schedule", 'String'>
    readonly description: FieldRef<"Schedule", 'String'>
    readonly cronExpression: FieldRef<"Schedule", 'String'>
    readonly timezone: FieldRef<"Schedule", 'String'>
    readonly enabled: FieldRef<"Schedule", 'Boolean'>
    readonly nextExecutionTime: FieldRef<"Schedule", 'DateTime'>
    readonly lastExecutionTime: FieldRef<"Schedule", 'DateTime'>
    readonly lastExecutionStatus: FieldRef<"Schedule", 'String'>
    readonly eventBridgeRuleArn: FieldRef<"Schedule", 'String'>
    readonly eventBridgeRuleName: FieldRef<"Schedule", 'String'>
    readonly executionWindow: FieldRef<"Schedule", 'Json'>
    readonly maxConcurrentRuns: FieldRef<"Schedule", 'Int'>
    readonly retryPolicy: FieldRef<"Schedule", 'Json'>
    readonly dependencies: FieldRef<"Schedule", 'Json'>
    readonly notificationConfig: FieldRef<"Schedule", 'Json'>
    readonly tags: FieldRef<"Schedule", 'String[]'>
    readonly metadata: FieldRef<"Schedule", 'Json'>
    readonly createdAt: FieldRef<"Schedule", 'DateTime'>
    readonly updatedAt: FieldRef<"Schedule", 'DateTime'>
    readonly createdBy: FieldRef<"Schedule", 'String'>
    readonly updatedBy: FieldRef<"Schedule", 'String'>
    readonly deletedAt: FieldRef<"Schedule", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Schedule findUnique
   */
  export type ScheduleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Schedule
     */
    omit?: ScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleInclude<ExtArgs> | null
    /**
     * Filter, which Schedule to fetch.
     */
    where: ScheduleWhereUniqueInput
  }

  /**
   * Schedule findUniqueOrThrow
   */
  export type ScheduleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Schedule
     */
    omit?: ScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleInclude<ExtArgs> | null
    /**
     * Filter, which Schedule to fetch.
     */
    where: ScheduleWhereUniqueInput
  }

  /**
   * Schedule findFirst
   */
  export type ScheduleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Schedule
     */
    omit?: ScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleInclude<ExtArgs> | null
    /**
     * Filter, which Schedule to fetch.
     */
    where?: ScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Schedules to fetch.
     */
    orderBy?: ScheduleOrderByWithRelationInput | ScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Schedules.
     */
    cursor?: ScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Schedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Schedules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Schedules.
     */
    distinct?: ScheduleScalarFieldEnum | ScheduleScalarFieldEnum[]
  }

  /**
   * Schedule findFirstOrThrow
   */
  export type ScheduleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Schedule
     */
    omit?: ScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleInclude<ExtArgs> | null
    /**
     * Filter, which Schedule to fetch.
     */
    where?: ScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Schedules to fetch.
     */
    orderBy?: ScheduleOrderByWithRelationInput | ScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Schedules.
     */
    cursor?: ScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Schedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Schedules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Schedules.
     */
    distinct?: ScheduleScalarFieldEnum | ScheduleScalarFieldEnum[]
  }

  /**
   * Schedule findMany
   */
  export type ScheduleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Schedule
     */
    omit?: ScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleInclude<ExtArgs> | null
    /**
     * Filter, which Schedules to fetch.
     */
    where?: ScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Schedules to fetch.
     */
    orderBy?: ScheduleOrderByWithRelationInput | ScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Schedules.
     */
    cursor?: ScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Schedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Schedules.
     */
    skip?: number
    distinct?: ScheduleScalarFieldEnum | ScheduleScalarFieldEnum[]
  }

  /**
   * Schedule create
   */
  export type ScheduleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Schedule
     */
    omit?: ScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleInclude<ExtArgs> | null
    /**
     * The data needed to create a Schedule.
     */
    data: XOR<ScheduleCreateInput, ScheduleUncheckedCreateInput>
  }

  /**
   * Schedule createMany
   */
  export type ScheduleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Schedules.
     */
    data: ScheduleCreateManyInput | ScheduleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Schedule createManyAndReturn
   */
  export type ScheduleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Schedule
     */
    omit?: ScheduleOmit<ExtArgs> | null
    /**
     * The data used to create many Schedules.
     */
    data: ScheduleCreateManyInput | ScheduleCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Schedule update
   */
  export type ScheduleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Schedule
     */
    omit?: ScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleInclude<ExtArgs> | null
    /**
     * The data needed to update a Schedule.
     */
    data: XOR<ScheduleUpdateInput, ScheduleUncheckedUpdateInput>
    /**
     * Choose, which Schedule to update.
     */
    where: ScheduleWhereUniqueInput
  }

  /**
   * Schedule updateMany
   */
  export type ScheduleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Schedules.
     */
    data: XOR<ScheduleUpdateManyMutationInput, ScheduleUncheckedUpdateManyInput>
    /**
     * Filter which Schedules to update
     */
    where?: ScheduleWhereInput
    /**
     * Limit how many Schedules to update.
     */
    limit?: number
  }

  /**
   * Schedule updateManyAndReturn
   */
  export type ScheduleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Schedule
     */
    omit?: ScheduleOmit<ExtArgs> | null
    /**
     * The data used to update Schedules.
     */
    data: XOR<ScheduleUpdateManyMutationInput, ScheduleUncheckedUpdateManyInput>
    /**
     * Filter which Schedules to update
     */
    where?: ScheduleWhereInput
    /**
     * Limit how many Schedules to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Schedule upsert
   */
  export type ScheduleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Schedule
     */
    omit?: ScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleInclude<ExtArgs> | null
    /**
     * The filter to search for the Schedule to update in case it exists.
     */
    where: ScheduleWhereUniqueInput
    /**
     * In case the Schedule found by the `where` argument doesn't exist, create a new Schedule with this data.
     */
    create: XOR<ScheduleCreateInput, ScheduleUncheckedCreateInput>
    /**
     * In case the Schedule was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ScheduleUpdateInput, ScheduleUncheckedUpdateInput>
  }

  /**
   * Schedule delete
   */
  export type ScheduleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Schedule
     */
    omit?: ScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleInclude<ExtArgs> | null
    /**
     * Filter which Schedule to delete.
     */
    where: ScheduleWhereUniqueInput
  }

  /**
   * Schedule deleteMany
   */
  export type ScheduleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Schedules to delete
     */
    where?: ScheduleWhereInput
    /**
     * Limit how many Schedules to delete.
     */
    limit?: number
  }

  /**
   * Schedule.executions
   */
  export type Schedule$executionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduleExecution
     */
    select?: ScheduleExecutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduleExecution
     */
    omit?: ScheduleExecutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleExecutionInclude<ExtArgs> | null
    where?: ScheduleExecutionWhereInput
    orderBy?: ScheduleExecutionOrderByWithRelationInput | ScheduleExecutionOrderByWithRelationInput[]
    cursor?: ScheduleExecutionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ScheduleExecutionScalarFieldEnum | ScheduleExecutionScalarFieldEnum[]
  }

  /**
   * Schedule.auditLogs
   */
  export type Schedule$auditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduleAuditLog
     */
    select?: ScheduleAuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduleAuditLog
     */
    omit?: ScheduleAuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleAuditLogInclude<ExtArgs> | null
    where?: ScheduleAuditLogWhereInput
    orderBy?: ScheduleAuditLogOrderByWithRelationInput | ScheduleAuditLogOrderByWithRelationInput[]
    cursor?: ScheduleAuditLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ScheduleAuditLogScalarFieldEnum | ScheduleAuditLogScalarFieldEnum[]
  }

  /**
   * Schedule without action
   */
  export type ScheduleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Schedule
     */
    omit?: ScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleInclude<ExtArgs> | null
  }


  /**
   * Model ScheduleExecution
   */

  export type AggregateScheduleExecution = {
    _count: ScheduleExecutionCountAggregateOutputType | null
    _avg: ScheduleExecutionAvgAggregateOutputType | null
    _sum: ScheduleExecutionSumAggregateOutputType | null
    _min: ScheduleExecutionMinAggregateOutputType | null
    _max: ScheduleExecutionMaxAggregateOutputType | null
  }

  export type ScheduleExecutionAvgAggregateOutputType = {
    duration: number | null
    attemptNumber: number | null
  }

  export type ScheduleExecutionSumAggregateOutputType = {
    duration: number | null
    attemptNumber: number | null
  }

  export type ScheduleExecutionMinAggregateOutputType = {
    id: string | null
    organizationId: string | null
    scheduleId: string | null
    jobId: string | null
    scheduledTime: Date | null
    startedAt: Date | null
    completedAt: Date | null
    duration: number | null
    status: string | null
    trigger: string | null
    errorMessage: string | null
    errorStack: string | null
    errorCode: string | null
    attemptNumber: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ScheduleExecutionMaxAggregateOutputType = {
    id: string | null
    organizationId: string | null
    scheduleId: string | null
    jobId: string | null
    scheduledTime: Date | null
    startedAt: Date | null
    completedAt: Date | null
    duration: number | null
    status: string | null
    trigger: string | null
    errorMessage: string | null
    errorStack: string | null
    errorCode: string | null
    attemptNumber: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ScheduleExecutionCountAggregateOutputType = {
    id: number
    organizationId: number
    scheduleId: number
    jobId: number
    scheduledTime: number
    startedAt: number
    completedAt: number
    duration: number
    status: number
    trigger: number
    errorMessage: number
    errorStack: number
    errorCode: number
    attemptNumber: number
    metadata: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ScheduleExecutionAvgAggregateInputType = {
    duration?: true
    attemptNumber?: true
  }

  export type ScheduleExecutionSumAggregateInputType = {
    duration?: true
    attemptNumber?: true
  }

  export type ScheduleExecutionMinAggregateInputType = {
    id?: true
    organizationId?: true
    scheduleId?: true
    jobId?: true
    scheduledTime?: true
    startedAt?: true
    completedAt?: true
    duration?: true
    status?: true
    trigger?: true
    errorMessage?: true
    errorStack?: true
    errorCode?: true
    attemptNumber?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ScheduleExecutionMaxAggregateInputType = {
    id?: true
    organizationId?: true
    scheduleId?: true
    jobId?: true
    scheduledTime?: true
    startedAt?: true
    completedAt?: true
    duration?: true
    status?: true
    trigger?: true
    errorMessage?: true
    errorStack?: true
    errorCode?: true
    attemptNumber?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ScheduleExecutionCountAggregateInputType = {
    id?: true
    organizationId?: true
    scheduleId?: true
    jobId?: true
    scheduledTime?: true
    startedAt?: true
    completedAt?: true
    duration?: true
    status?: true
    trigger?: true
    errorMessage?: true
    errorStack?: true
    errorCode?: true
    attemptNumber?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ScheduleExecutionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ScheduleExecution to aggregate.
     */
    where?: ScheduleExecutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScheduleExecutions to fetch.
     */
    orderBy?: ScheduleExecutionOrderByWithRelationInput | ScheduleExecutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ScheduleExecutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScheduleExecutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScheduleExecutions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ScheduleExecutions
    **/
    _count?: true | ScheduleExecutionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ScheduleExecutionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ScheduleExecutionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ScheduleExecutionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ScheduleExecutionMaxAggregateInputType
  }

  export type GetScheduleExecutionAggregateType<T extends ScheduleExecutionAggregateArgs> = {
        [P in keyof T & keyof AggregateScheduleExecution]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateScheduleExecution[P]>
      : GetScalarType<T[P], AggregateScheduleExecution[P]>
  }




  export type ScheduleExecutionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ScheduleExecutionWhereInput
    orderBy?: ScheduleExecutionOrderByWithAggregationInput | ScheduleExecutionOrderByWithAggregationInput[]
    by: ScheduleExecutionScalarFieldEnum[] | ScheduleExecutionScalarFieldEnum
    having?: ScheduleExecutionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ScheduleExecutionCountAggregateInputType | true
    _avg?: ScheduleExecutionAvgAggregateInputType
    _sum?: ScheduleExecutionSumAggregateInputType
    _min?: ScheduleExecutionMinAggregateInputType
    _max?: ScheduleExecutionMaxAggregateInputType
  }

  export type ScheduleExecutionGroupByOutputType = {
    id: string
    organizationId: string
    scheduleId: string
    jobId: string | null
    scheduledTime: Date
    startedAt: Date | null
    completedAt: Date | null
    duration: number | null
    status: string
    trigger: string
    errorMessage: string | null
    errorStack: string | null
    errorCode: string | null
    attemptNumber: number
    metadata: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: ScheduleExecutionCountAggregateOutputType | null
    _avg: ScheduleExecutionAvgAggregateOutputType | null
    _sum: ScheduleExecutionSumAggregateOutputType | null
    _min: ScheduleExecutionMinAggregateOutputType | null
    _max: ScheduleExecutionMaxAggregateOutputType | null
  }

  type GetScheduleExecutionGroupByPayload<T extends ScheduleExecutionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ScheduleExecutionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ScheduleExecutionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ScheduleExecutionGroupByOutputType[P]>
            : GetScalarType<T[P], ScheduleExecutionGroupByOutputType[P]>
        }
      >
    >


  export type ScheduleExecutionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organizationId?: boolean
    scheduleId?: boolean
    jobId?: boolean
    scheduledTime?: boolean
    startedAt?: boolean
    completedAt?: boolean
    duration?: boolean
    status?: boolean
    trigger?: boolean
    errorMessage?: boolean
    errorStack?: boolean
    errorCode?: boolean
    attemptNumber?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    schedule?: boolean | ScheduleDefaultArgs<ExtArgs>
    job?: boolean | ScheduleExecution$jobArgs<ExtArgs>
  }, ExtArgs["result"]["scheduleExecution"]>

  export type ScheduleExecutionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organizationId?: boolean
    scheduleId?: boolean
    jobId?: boolean
    scheduledTime?: boolean
    startedAt?: boolean
    completedAt?: boolean
    duration?: boolean
    status?: boolean
    trigger?: boolean
    errorMessage?: boolean
    errorStack?: boolean
    errorCode?: boolean
    attemptNumber?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    schedule?: boolean | ScheduleDefaultArgs<ExtArgs>
    job?: boolean | ScheduleExecution$jobArgs<ExtArgs>
  }, ExtArgs["result"]["scheduleExecution"]>

  export type ScheduleExecutionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organizationId?: boolean
    scheduleId?: boolean
    jobId?: boolean
    scheduledTime?: boolean
    startedAt?: boolean
    completedAt?: boolean
    duration?: boolean
    status?: boolean
    trigger?: boolean
    errorMessage?: boolean
    errorStack?: boolean
    errorCode?: boolean
    attemptNumber?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    schedule?: boolean | ScheduleDefaultArgs<ExtArgs>
    job?: boolean | ScheduleExecution$jobArgs<ExtArgs>
  }, ExtArgs["result"]["scheduleExecution"]>

  export type ScheduleExecutionSelectScalar = {
    id?: boolean
    organizationId?: boolean
    scheduleId?: boolean
    jobId?: boolean
    scheduledTime?: boolean
    startedAt?: boolean
    completedAt?: boolean
    duration?: boolean
    status?: boolean
    trigger?: boolean
    errorMessage?: boolean
    errorStack?: boolean
    errorCode?: boolean
    attemptNumber?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ScheduleExecutionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "organizationId" | "scheduleId" | "jobId" | "scheduledTime" | "startedAt" | "completedAt" | "duration" | "status" | "trigger" | "errorMessage" | "errorStack" | "errorCode" | "attemptNumber" | "metadata" | "createdAt" | "updatedAt", ExtArgs["result"]["scheduleExecution"]>
  export type ScheduleExecutionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    schedule?: boolean | ScheduleDefaultArgs<ExtArgs>
    job?: boolean | ScheduleExecution$jobArgs<ExtArgs>
  }
  export type ScheduleExecutionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    schedule?: boolean | ScheduleDefaultArgs<ExtArgs>
    job?: boolean | ScheduleExecution$jobArgs<ExtArgs>
  }
  export type ScheduleExecutionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    schedule?: boolean | ScheduleDefaultArgs<ExtArgs>
    job?: boolean | ScheduleExecution$jobArgs<ExtArgs>
  }

  export type $ScheduleExecutionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ScheduleExecution"
    objects: {
      schedule: Prisma.$SchedulePayload<ExtArgs>
      job: Prisma.$JobPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      organizationId: string
      scheduleId: string
      jobId: string | null
      scheduledTime: Date
      startedAt: Date | null
      completedAt: Date | null
      duration: number | null
      status: string
      trigger: string
      errorMessage: string | null
      errorStack: string | null
      errorCode: string | null
      attemptNumber: number
      metadata: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["scheduleExecution"]>
    composites: {}
  }

  type ScheduleExecutionGetPayload<S extends boolean | null | undefined | ScheduleExecutionDefaultArgs> = $Result.GetResult<Prisma.$ScheduleExecutionPayload, S>

  type ScheduleExecutionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ScheduleExecutionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ScheduleExecutionCountAggregateInputType | true
    }

  export interface ScheduleExecutionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ScheduleExecution'], meta: { name: 'ScheduleExecution' } }
    /**
     * Find zero or one ScheduleExecution that matches the filter.
     * @param {ScheduleExecutionFindUniqueArgs} args - Arguments to find a ScheduleExecution
     * @example
     * // Get one ScheduleExecution
     * const scheduleExecution = await prisma.scheduleExecution.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ScheduleExecutionFindUniqueArgs>(args: SelectSubset<T, ScheduleExecutionFindUniqueArgs<ExtArgs>>): Prisma__ScheduleExecutionClient<$Result.GetResult<Prisma.$ScheduleExecutionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ScheduleExecution that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ScheduleExecutionFindUniqueOrThrowArgs} args - Arguments to find a ScheduleExecution
     * @example
     * // Get one ScheduleExecution
     * const scheduleExecution = await prisma.scheduleExecution.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ScheduleExecutionFindUniqueOrThrowArgs>(args: SelectSubset<T, ScheduleExecutionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ScheduleExecutionClient<$Result.GetResult<Prisma.$ScheduleExecutionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ScheduleExecution that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleExecutionFindFirstArgs} args - Arguments to find a ScheduleExecution
     * @example
     * // Get one ScheduleExecution
     * const scheduleExecution = await prisma.scheduleExecution.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ScheduleExecutionFindFirstArgs>(args?: SelectSubset<T, ScheduleExecutionFindFirstArgs<ExtArgs>>): Prisma__ScheduleExecutionClient<$Result.GetResult<Prisma.$ScheduleExecutionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ScheduleExecution that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleExecutionFindFirstOrThrowArgs} args - Arguments to find a ScheduleExecution
     * @example
     * // Get one ScheduleExecution
     * const scheduleExecution = await prisma.scheduleExecution.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ScheduleExecutionFindFirstOrThrowArgs>(args?: SelectSubset<T, ScheduleExecutionFindFirstOrThrowArgs<ExtArgs>>): Prisma__ScheduleExecutionClient<$Result.GetResult<Prisma.$ScheduleExecutionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ScheduleExecutions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleExecutionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ScheduleExecutions
     * const scheduleExecutions = await prisma.scheduleExecution.findMany()
     * 
     * // Get first 10 ScheduleExecutions
     * const scheduleExecutions = await prisma.scheduleExecution.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const scheduleExecutionWithIdOnly = await prisma.scheduleExecution.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ScheduleExecutionFindManyArgs>(args?: SelectSubset<T, ScheduleExecutionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScheduleExecutionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ScheduleExecution.
     * @param {ScheduleExecutionCreateArgs} args - Arguments to create a ScheduleExecution.
     * @example
     * // Create one ScheduleExecution
     * const ScheduleExecution = await prisma.scheduleExecution.create({
     *   data: {
     *     // ... data to create a ScheduleExecution
     *   }
     * })
     * 
     */
    create<T extends ScheduleExecutionCreateArgs>(args: SelectSubset<T, ScheduleExecutionCreateArgs<ExtArgs>>): Prisma__ScheduleExecutionClient<$Result.GetResult<Prisma.$ScheduleExecutionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ScheduleExecutions.
     * @param {ScheduleExecutionCreateManyArgs} args - Arguments to create many ScheduleExecutions.
     * @example
     * // Create many ScheduleExecutions
     * const scheduleExecution = await prisma.scheduleExecution.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ScheduleExecutionCreateManyArgs>(args?: SelectSubset<T, ScheduleExecutionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ScheduleExecutions and returns the data saved in the database.
     * @param {ScheduleExecutionCreateManyAndReturnArgs} args - Arguments to create many ScheduleExecutions.
     * @example
     * // Create many ScheduleExecutions
     * const scheduleExecution = await prisma.scheduleExecution.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ScheduleExecutions and only return the `id`
     * const scheduleExecutionWithIdOnly = await prisma.scheduleExecution.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ScheduleExecutionCreateManyAndReturnArgs>(args?: SelectSubset<T, ScheduleExecutionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScheduleExecutionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ScheduleExecution.
     * @param {ScheduleExecutionDeleteArgs} args - Arguments to delete one ScheduleExecution.
     * @example
     * // Delete one ScheduleExecution
     * const ScheduleExecution = await prisma.scheduleExecution.delete({
     *   where: {
     *     // ... filter to delete one ScheduleExecution
     *   }
     * })
     * 
     */
    delete<T extends ScheduleExecutionDeleteArgs>(args: SelectSubset<T, ScheduleExecutionDeleteArgs<ExtArgs>>): Prisma__ScheduleExecutionClient<$Result.GetResult<Prisma.$ScheduleExecutionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ScheduleExecution.
     * @param {ScheduleExecutionUpdateArgs} args - Arguments to update one ScheduleExecution.
     * @example
     * // Update one ScheduleExecution
     * const scheduleExecution = await prisma.scheduleExecution.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ScheduleExecutionUpdateArgs>(args: SelectSubset<T, ScheduleExecutionUpdateArgs<ExtArgs>>): Prisma__ScheduleExecutionClient<$Result.GetResult<Prisma.$ScheduleExecutionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ScheduleExecutions.
     * @param {ScheduleExecutionDeleteManyArgs} args - Arguments to filter ScheduleExecutions to delete.
     * @example
     * // Delete a few ScheduleExecutions
     * const { count } = await prisma.scheduleExecution.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ScheduleExecutionDeleteManyArgs>(args?: SelectSubset<T, ScheduleExecutionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ScheduleExecutions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleExecutionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ScheduleExecutions
     * const scheduleExecution = await prisma.scheduleExecution.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ScheduleExecutionUpdateManyArgs>(args: SelectSubset<T, ScheduleExecutionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ScheduleExecutions and returns the data updated in the database.
     * @param {ScheduleExecutionUpdateManyAndReturnArgs} args - Arguments to update many ScheduleExecutions.
     * @example
     * // Update many ScheduleExecutions
     * const scheduleExecution = await prisma.scheduleExecution.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ScheduleExecutions and only return the `id`
     * const scheduleExecutionWithIdOnly = await prisma.scheduleExecution.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ScheduleExecutionUpdateManyAndReturnArgs>(args: SelectSubset<T, ScheduleExecutionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScheduleExecutionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ScheduleExecution.
     * @param {ScheduleExecutionUpsertArgs} args - Arguments to update or create a ScheduleExecution.
     * @example
     * // Update or create a ScheduleExecution
     * const scheduleExecution = await prisma.scheduleExecution.upsert({
     *   create: {
     *     // ... data to create a ScheduleExecution
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ScheduleExecution we want to update
     *   }
     * })
     */
    upsert<T extends ScheduleExecutionUpsertArgs>(args: SelectSubset<T, ScheduleExecutionUpsertArgs<ExtArgs>>): Prisma__ScheduleExecutionClient<$Result.GetResult<Prisma.$ScheduleExecutionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ScheduleExecutions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleExecutionCountArgs} args - Arguments to filter ScheduleExecutions to count.
     * @example
     * // Count the number of ScheduleExecutions
     * const count = await prisma.scheduleExecution.count({
     *   where: {
     *     // ... the filter for the ScheduleExecutions we want to count
     *   }
     * })
    **/
    count<T extends ScheduleExecutionCountArgs>(
      args?: Subset<T, ScheduleExecutionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ScheduleExecutionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ScheduleExecution.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleExecutionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ScheduleExecutionAggregateArgs>(args: Subset<T, ScheduleExecutionAggregateArgs>): Prisma.PrismaPromise<GetScheduleExecutionAggregateType<T>>

    /**
     * Group by ScheduleExecution.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleExecutionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ScheduleExecutionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ScheduleExecutionGroupByArgs['orderBy'] }
        : { orderBy?: ScheduleExecutionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ScheduleExecutionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetScheduleExecutionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ScheduleExecution model
   */
  readonly fields: ScheduleExecutionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ScheduleExecution.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ScheduleExecutionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    schedule<T extends ScheduleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ScheduleDefaultArgs<ExtArgs>>): Prisma__ScheduleClient<$Result.GetResult<Prisma.$SchedulePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    job<T extends ScheduleExecution$jobArgs<ExtArgs> = {}>(args?: Subset<T, ScheduleExecution$jobArgs<ExtArgs>>): Prisma__JobClient<$Result.GetResult<Prisma.$JobPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ScheduleExecution model
   */
  interface ScheduleExecutionFieldRefs {
    readonly id: FieldRef<"ScheduleExecution", 'String'>
    readonly organizationId: FieldRef<"ScheduleExecution", 'String'>
    readonly scheduleId: FieldRef<"ScheduleExecution", 'String'>
    readonly jobId: FieldRef<"ScheduleExecution", 'String'>
    readonly scheduledTime: FieldRef<"ScheduleExecution", 'DateTime'>
    readonly startedAt: FieldRef<"ScheduleExecution", 'DateTime'>
    readonly completedAt: FieldRef<"ScheduleExecution", 'DateTime'>
    readonly duration: FieldRef<"ScheduleExecution", 'Int'>
    readonly status: FieldRef<"ScheduleExecution", 'String'>
    readonly trigger: FieldRef<"ScheduleExecution", 'String'>
    readonly errorMessage: FieldRef<"ScheduleExecution", 'String'>
    readonly errorStack: FieldRef<"ScheduleExecution", 'String'>
    readonly errorCode: FieldRef<"ScheduleExecution", 'String'>
    readonly attemptNumber: FieldRef<"ScheduleExecution", 'Int'>
    readonly metadata: FieldRef<"ScheduleExecution", 'Json'>
    readonly createdAt: FieldRef<"ScheduleExecution", 'DateTime'>
    readonly updatedAt: FieldRef<"ScheduleExecution", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ScheduleExecution findUnique
   */
  export type ScheduleExecutionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduleExecution
     */
    select?: ScheduleExecutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduleExecution
     */
    omit?: ScheduleExecutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleExecutionInclude<ExtArgs> | null
    /**
     * Filter, which ScheduleExecution to fetch.
     */
    where: ScheduleExecutionWhereUniqueInput
  }

  /**
   * ScheduleExecution findUniqueOrThrow
   */
  export type ScheduleExecutionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduleExecution
     */
    select?: ScheduleExecutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduleExecution
     */
    omit?: ScheduleExecutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleExecutionInclude<ExtArgs> | null
    /**
     * Filter, which ScheduleExecution to fetch.
     */
    where: ScheduleExecutionWhereUniqueInput
  }

  /**
   * ScheduleExecution findFirst
   */
  export type ScheduleExecutionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduleExecution
     */
    select?: ScheduleExecutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduleExecution
     */
    omit?: ScheduleExecutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleExecutionInclude<ExtArgs> | null
    /**
     * Filter, which ScheduleExecution to fetch.
     */
    where?: ScheduleExecutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScheduleExecutions to fetch.
     */
    orderBy?: ScheduleExecutionOrderByWithRelationInput | ScheduleExecutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ScheduleExecutions.
     */
    cursor?: ScheduleExecutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScheduleExecutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScheduleExecutions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ScheduleExecutions.
     */
    distinct?: ScheduleExecutionScalarFieldEnum | ScheduleExecutionScalarFieldEnum[]
  }

  /**
   * ScheduleExecution findFirstOrThrow
   */
  export type ScheduleExecutionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduleExecution
     */
    select?: ScheduleExecutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduleExecution
     */
    omit?: ScheduleExecutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleExecutionInclude<ExtArgs> | null
    /**
     * Filter, which ScheduleExecution to fetch.
     */
    where?: ScheduleExecutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScheduleExecutions to fetch.
     */
    orderBy?: ScheduleExecutionOrderByWithRelationInput | ScheduleExecutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ScheduleExecutions.
     */
    cursor?: ScheduleExecutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScheduleExecutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScheduleExecutions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ScheduleExecutions.
     */
    distinct?: ScheduleExecutionScalarFieldEnum | ScheduleExecutionScalarFieldEnum[]
  }

  /**
   * ScheduleExecution findMany
   */
  export type ScheduleExecutionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduleExecution
     */
    select?: ScheduleExecutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduleExecution
     */
    omit?: ScheduleExecutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleExecutionInclude<ExtArgs> | null
    /**
     * Filter, which ScheduleExecutions to fetch.
     */
    where?: ScheduleExecutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScheduleExecutions to fetch.
     */
    orderBy?: ScheduleExecutionOrderByWithRelationInput | ScheduleExecutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ScheduleExecutions.
     */
    cursor?: ScheduleExecutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScheduleExecutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScheduleExecutions.
     */
    skip?: number
    distinct?: ScheduleExecutionScalarFieldEnum | ScheduleExecutionScalarFieldEnum[]
  }

  /**
   * ScheduleExecution create
   */
  export type ScheduleExecutionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduleExecution
     */
    select?: ScheduleExecutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduleExecution
     */
    omit?: ScheduleExecutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleExecutionInclude<ExtArgs> | null
    /**
     * The data needed to create a ScheduleExecution.
     */
    data: XOR<ScheduleExecutionCreateInput, ScheduleExecutionUncheckedCreateInput>
  }

  /**
   * ScheduleExecution createMany
   */
  export type ScheduleExecutionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ScheduleExecutions.
     */
    data: ScheduleExecutionCreateManyInput | ScheduleExecutionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ScheduleExecution createManyAndReturn
   */
  export type ScheduleExecutionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduleExecution
     */
    select?: ScheduleExecutionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduleExecution
     */
    omit?: ScheduleExecutionOmit<ExtArgs> | null
    /**
     * The data used to create many ScheduleExecutions.
     */
    data: ScheduleExecutionCreateManyInput | ScheduleExecutionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleExecutionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ScheduleExecution update
   */
  export type ScheduleExecutionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduleExecution
     */
    select?: ScheduleExecutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduleExecution
     */
    omit?: ScheduleExecutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleExecutionInclude<ExtArgs> | null
    /**
     * The data needed to update a ScheduleExecution.
     */
    data: XOR<ScheduleExecutionUpdateInput, ScheduleExecutionUncheckedUpdateInput>
    /**
     * Choose, which ScheduleExecution to update.
     */
    where: ScheduleExecutionWhereUniqueInput
  }

  /**
   * ScheduleExecution updateMany
   */
  export type ScheduleExecutionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ScheduleExecutions.
     */
    data: XOR<ScheduleExecutionUpdateManyMutationInput, ScheduleExecutionUncheckedUpdateManyInput>
    /**
     * Filter which ScheduleExecutions to update
     */
    where?: ScheduleExecutionWhereInput
    /**
     * Limit how many ScheduleExecutions to update.
     */
    limit?: number
  }

  /**
   * ScheduleExecution updateManyAndReturn
   */
  export type ScheduleExecutionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduleExecution
     */
    select?: ScheduleExecutionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduleExecution
     */
    omit?: ScheduleExecutionOmit<ExtArgs> | null
    /**
     * The data used to update ScheduleExecutions.
     */
    data: XOR<ScheduleExecutionUpdateManyMutationInput, ScheduleExecutionUncheckedUpdateManyInput>
    /**
     * Filter which ScheduleExecutions to update
     */
    where?: ScheduleExecutionWhereInput
    /**
     * Limit how many ScheduleExecutions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleExecutionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ScheduleExecution upsert
   */
  export type ScheduleExecutionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduleExecution
     */
    select?: ScheduleExecutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduleExecution
     */
    omit?: ScheduleExecutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleExecutionInclude<ExtArgs> | null
    /**
     * The filter to search for the ScheduleExecution to update in case it exists.
     */
    where: ScheduleExecutionWhereUniqueInput
    /**
     * In case the ScheduleExecution found by the `where` argument doesn't exist, create a new ScheduleExecution with this data.
     */
    create: XOR<ScheduleExecutionCreateInput, ScheduleExecutionUncheckedCreateInput>
    /**
     * In case the ScheduleExecution was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ScheduleExecutionUpdateInput, ScheduleExecutionUncheckedUpdateInput>
  }

  /**
   * ScheduleExecution delete
   */
  export type ScheduleExecutionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduleExecution
     */
    select?: ScheduleExecutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduleExecution
     */
    omit?: ScheduleExecutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleExecutionInclude<ExtArgs> | null
    /**
     * Filter which ScheduleExecution to delete.
     */
    where: ScheduleExecutionWhereUniqueInput
  }

  /**
   * ScheduleExecution deleteMany
   */
  export type ScheduleExecutionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ScheduleExecutions to delete
     */
    where?: ScheduleExecutionWhereInput
    /**
     * Limit how many ScheduleExecutions to delete.
     */
    limit?: number
  }

  /**
   * ScheduleExecution.job
   */
  export type ScheduleExecution$jobArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Job
     */
    select?: JobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Job
     */
    omit?: JobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobInclude<ExtArgs> | null
    where?: JobWhereInput
  }

  /**
   * ScheduleExecution without action
   */
  export type ScheduleExecutionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduleExecution
     */
    select?: ScheduleExecutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduleExecution
     */
    omit?: ScheduleExecutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleExecutionInclude<ExtArgs> | null
  }


  /**
   * Model ScheduleAuditLog
   */

  export type AggregateScheduleAuditLog = {
    _count: ScheduleAuditLogCountAggregateOutputType | null
    _avg: ScheduleAuditLogAvgAggregateOutputType | null
    _sum: ScheduleAuditLogSumAggregateOutputType | null
    _min: ScheduleAuditLogMinAggregateOutputType | null
    _max: ScheduleAuditLogMaxAggregateOutputType | null
  }

  export type ScheduleAuditLogAvgAggregateOutputType = {
    durationMs: number | null
  }

  export type ScheduleAuditLogSumAggregateOutputType = {
    durationMs: number | null
  }

  export type ScheduleAuditLogMinAggregateOutputType = {
    id: string | null
    scheduleId: string | null
    organizationId: string | null
    action: string | null
    resource: string | null
    userId: string | null
    userEmail: string | null
    ipAddress: string | null
    userAgent: string | null
    requestId: string | null
    status: string | null
    errorMessage: string | null
    errorCode: string | null
    durationMs: number | null
    timestamp: Date | null
    retainUntil: Date | null
  }

  export type ScheduleAuditLogMaxAggregateOutputType = {
    id: string | null
    scheduleId: string | null
    organizationId: string | null
    action: string | null
    resource: string | null
    userId: string | null
    userEmail: string | null
    ipAddress: string | null
    userAgent: string | null
    requestId: string | null
    status: string | null
    errorMessage: string | null
    errorCode: string | null
    durationMs: number | null
    timestamp: Date | null
    retainUntil: Date | null
  }

  export type ScheduleAuditLogCountAggregateOutputType = {
    id: number
    scheduleId: number
    organizationId: number
    action: number
    resource: number
    userId: number
    userEmail: number
    ipAddress: number
    userAgent: number
    requestId: number
    previousValue: number
    newValue: number
    changedFields: number
    status: number
    errorMessage: number
    errorCode: number
    durationMs: number
    metadata: number
    timestamp: number
    retainUntil: number
    _all: number
  }


  export type ScheduleAuditLogAvgAggregateInputType = {
    durationMs?: true
  }

  export type ScheduleAuditLogSumAggregateInputType = {
    durationMs?: true
  }

  export type ScheduleAuditLogMinAggregateInputType = {
    id?: true
    scheduleId?: true
    organizationId?: true
    action?: true
    resource?: true
    userId?: true
    userEmail?: true
    ipAddress?: true
    userAgent?: true
    requestId?: true
    status?: true
    errorMessage?: true
    errorCode?: true
    durationMs?: true
    timestamp?: true
    retainUntil?: true
  }

  export type ScheduleAuditLogMaxAggregateInputType = {
    id?: true
    scheduleId?: true
    organizationId?: true
    action?: true
    resource?: true
    userId?: true
    userEmail?: true
    ipAddress?: true
    userAgent?: true
    requestId?: true
    status?: true
    errorMessage?: true
    errorCode?: true
    durationMs?: true
    timestamp?: true
    retainUntil?: true
  }

  export type ScheduleAuditLogCountAggregateInputType = {
    id?: true
    scheduleId?: true
    organizationId?: true
    action?: true
    resource?: true
    userId?: true
    userEmail?: true
    ipAddress?: true
    userAgent?: true
    requestId?: true
    previousValue?: true
    newValue?: true
    changedFields?: true
    status?: true
    errorMessage?: true
    errorCode?: true
    durationMs?: true
    metadata?: true
    timestamp?: true
    retainUntil?: true
    _all?: true
  }

  export type ScheduleAuditLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ScheduleAuditLog to aggregate.
     */
    where?: ScheduleAuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScheduleAuditLogs to fetch.
     */
    orderBy?: ScheduleAuditLogOrderByWithRelationInput | ScheduleAuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ScheduleAuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScheduleAuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScheduleAuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ScheduleAuditLogs
    **/
    _count?: true | ScheduleAuditLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ScheduleAuditLogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ScheduleAuditLogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ScheduleAuditLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ScheduleAuditLogMaxAggregateInputType
  }

  export type GetScheduleAuditLogAggregateType<T extends ScheduleAuditLogAggregateArgs> = {
        [P in keyof T & keyof AggregateScheduleAuditLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateScheduleAuditLog[P]>
      : GetScalarType<T[P], AggregateScheduleAuditLog[P]>
  }




  export type ScheduleAuditLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ScheduleAuditLogWhereInput
    orderBy?: ScheduleAuditLogOrderByWithAggregationInput | ScheduleAuditLogOrderByWithAggregationInput[]
    by: ScheduleAuditLogScalarFieldEnum[] | ScheduleAuditLogScalarFieldEnum
    having?: ScheduleAuditLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ScheduleAuditLogCountAggregateInputType | true
    _avg?: ScheduleAuditLogAvgAggregateInputType
    _sum?: ScheduleAuditLogSumAggregateInputType
    _min?: ScheduleAuditLogMinAggregateInputType
    _max?: ScheduleAuditLogMaxAggregateInputType
  }

  export type ScheduleAuditLogGroupByOutputType = {
    id: string
    scheduleId: string | null
    organizationId: string
    action: string
    resource: string
    userId: string
    userEmail: string | null
    ipAddress: string | null
    userAgent: string | null
    requestId: string | null
    previousValue: JsonValue | null
    newValue: JsonValue | null
    changedFields: string[]
    status: string
    errorMessage: string | null
    errorCode: string | null
    durationMs: number | null
    metadata: JsonValue | null
    timestamp: Date
    retainUntil: Date
    _count: ScheduleAuditLogCountAggregateOutputType | null
    _avg: ScheduleAuditLogAvgAggregateOutputType | null
    _sum: ScheduleAuditLogSumAggregateOutputType | null
    _min: ScheduleAuditLogMinAggregateOutputType | null
    _max: ScheduleAuditLogMaxAggregateOutputType | null
  }

  type GetScheduleAuditLogGroupByPayload<T extends ScheduleAuditLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ScheduleAuditLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ScheduleAuditLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ScheduleAuditLogGroupByOutputType[P]>
            : GetScalarType<T[P], ScheduleAuditLogGroupByOutputType[P]>
        }
      >
    >


  export type ScheduleAuditLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    scheduleId?: boolean
    organizationId?: boolean
    action?: boolean
    resource?: boolean
    userId?: boolean
    userEmail?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    requestId?: boolean
    previousValue?: boolean
    newValue?: boolean
    changedFields?: boolean
    status?: boolean
    errorMessage?: boolean
    errorCode?: boolean
    durationMs?: boolean
    metadata?: boolean
    timestamp?: boolean
    retainUntil?: boolean
    schedule?: boolean | ScheduleAuditLog$scheduleArgs<ExtArgs>
  }, ExtArgs["result"]["scheduleAuditLog"]>

  export type ScheduleAuditLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    scheduleId?: boolean
    organizationId?: boolean
    action?: boolean
    resource?: boolean
    userId?: boolean
    userEmail?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    requestId?: boolean
    previousValue?: boolean
    newValue?: boolean
    changedFields?: boolean
    status?: boolean
    errorMessage?: boolean
    errorCode?: boolean
    durationMs?: boolean
    metadata?: boolean
    timestamp?: boolean
    retainUntil?: boolean
    schedule?: boolean | ScheduleAuditLog$scheduleArgs<ExtArgs>
  }, ExtArgs["result"]["scheduleAuditLog"]>

  export type ScheduleAuditLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    scheduleId?: boolean
    organizationId?: boolean
    action?: boolean
    resource?: boolean
    userId?: boolean
    userEmail?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    requestId?: boolean
    previousValue?: boolean
    newValue?: boolean
    changedFields?: boolean
    status?: boolean
    errorMessage?: boolean
    errorCode?: boolean
    durationMs?: boolean
    metadata?: boolean
    timestamp?: boolean
    retainUntil?: boolean
    schedule?: boolean | ScheduleAuditLog$scheduleArgs<ExtArgs>
  }, ExtArgs["result"]["scheduleAuditLog"]>

  export type ScheduleAuditLogSelectScalar = {
    id?: boolean
    scheduleId?: boolean
    organizationId?: boolean
    action?: boolean
    resource?: boolean
    userId?: boolean
    userEmail?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    requestId?: boolean
    previousValue?: boolean
    newValue?: boolean
    changedFields?: boolean
    status?: boolean
    errorMessage?: boolean
    errorCode?: boolean
    durationMs?: boolean
    metadata?: boolean
    timestamp?: boolean
    retainUntil?: boolean
  }

  export type ScheduleAuditLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "scheduleId" | "organizationId" | "action" | "resource" | "userId" | "userEmail" | "ipAddress" | "userAgent" | "requestId" | "previousValue" | "newValue" | "changedFields" | "status" | "errorMessage" | "errorCode" | "durationMs" | "metadata" | "timestamp" | "retainUntil", ExtArgs["result"]["scheduleAuditLog"]>
  export type ScheduleAuditLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    schedule?: boolean | ScheduleAuditLog$scheduleArgs<ExtArgs>
  }
  export type ScheduleAuditLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    schedule?: boolean | ScheduleAuditLog$scheduleArgs<ExtArgs>
  }
  export type ScheduleAuditLogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    schedule?: boolean | ScheduleAuditLog$scheduleArgs<ExtArgs>
  }

  export type $ScheduleAuditLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ScheduleAuditLog"
    objects: {
      schedule: Prisma.$SchedulePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      scheduleId: string | null
      organizationId: string
      action: string
      resource: string
      userId: string
      userEmail: string | null
      ipAddress: string | null
      userAgent: string | null
      requestId: string | null
      previousValue: Prisma.JsonValue | null
      newValue: Prisma.JsonValue | null
      changedFields: string[]
      status: string
      errorMessage: string | null
      errorCode: string | null
      durationMs: number | null
      metadata: Prisma.JsonValue | null
      timestamp: Date
      retainUntil: Date
    }, ExtArgs["result"]["scheduleAuditLog"]>
    composites: {}
  }

  type ScheduleAuditLogGetPayload<S extends boolean | null | undefined | ScheduleAuditLogDefaultArgs> = $Result.GetResult<Prisma.$ScheduleAuditLogPayload, S>

  type ScheduleAuditLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ScheduleAuditLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ScheduleAuditLogCountAggregateInputType | true
    }

  export interface ScheduleAuditLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ScheduleAuditLog'], meta: { name: 'ScheduleAuditLog' } }
    /**
     * Find zero or one ScheduleAuditLog that matches the filter.
     * @param {ScheduleAuditLogFindUniqueArgs} args - Arguments to find a ScheduleAuditLog
     * @example
     * // Get one ScheduleAuditLog
     * const scheduleAuditLog = await prisma.scheduleAuditLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ScheduleAuditLogFindUniqueArgs>(args: SelectSubset<T, ScheduleAuditLogFindUniqueArgs<ExtArgs>>): Prisma__ScheduleAuditLogClient<$Result.GetResult<Prisma.$ScheduleAuditLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ScheduleAuditLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ScheduleAuditLogFindUniqueOrThrowArgs} args - Arguments to find a ScheduleAuditLog
     * @example
     * // Get one ScheduleAuditLog
     * const scheduleAuditLog = await prisma.scheduleAuditLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ScheduleAuditLogFindUniqueOrThrowArgs>(args: SelectSubset<T, ScheduleAuditLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ScheduleAuditLogClient<$Result.GetResult<Prisma.$ScheduleAuditLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ScheduleAuditLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleAuditLogFindFirstArgs} args - Arguments to find a ScheduleAuditLog
     * @example
     * // Get one ScheduleAuditLog
     * const scheduleAuditLog = await prisma.scheduleAuditLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ScheduleAuditLogFindFirstArgs>(args?: SelectSubset<T, ScheduleAuditLogFindFirstArgs<ExtArgs>>): Prisma__ScheduleAuditLogClient<$Result.GetResult<Prisma.$ScheduleAuditLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ScheduleAuditLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleAuditLogFindFirstOrThrowArgs} args - Arguments to find a ScheduleAuditLog
     * @example
     * // Get one ScheduleAuditLog
     * const scheduleAuditLog = await prisma.scheduleAuditLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ScheduleAuditLogFindFirstOrThrowArgs>(args?: SelectSubset<T, ScheduleAuditLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__ScheduleAuditLogClient<$Result.GetResult<Prisma.$ScheduleAuditLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ScheduleAuditLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleAuditLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ScheduleAuditLogs
     * const scheduleAuditLogs = await prisma.scheduleAuditLog.findMany()
     * 
     * // Get first 10 ScheduleAuditLogs
     * const scheduleAuditLogs = await prisma.scheduleAuditLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const scheduleAuditLogWithIdOnly = await prisma.scheduleAuditLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ScheduleAuditLogFindManyArgs>(args?: SelectSubset<T, ScheduleAuditLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScheduleAuditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ScheduleAuditLog.
     * @param {ScheduleAuditLogCreateArgs} args - Arguments to create a ScheduleAuditLog.
     * @example
     * // Create one ScheduleAuditLog
     * const ScheduleAuditLog = await prisma.scheduleAuditLog.create({
     *   data: {
     *     // ... data to create a ScheduleAuditLog
     *   }
     * })
     * 
     */
    create<T extends ScheduleAuditLogCreateArgs>(args: SelectSubset<T, ScheduleAuditLogCreateArgs<ExtArgs>>): Prisma__ScheduleAuditLogClient<$Result.GetResult<Prisma.$ScheduleAuditLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ScheduleAuditLogs.
     * @param {ScheduleAuditLogCreateManyArgs} args - Arguments to create many ScheduleAuditLogs.
     * @example
     * // Create many ScheduleAuditLogs
     * const scheduleAuditLog = await prisma.scheduleAuditLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ScheduleAuditLogCreateManyArgs>(args?: SelectSubset<T, ScheduleAuditLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ScheduleAuditLogs and returns the data saved in the database.
     * @param {ScheduleAuditLogCreateManyAndReturnArgs} args - Arguments to create many ScheduleAuditLogs.
     * @example
     * // Create many ScheduleAuditLogs
     * const scheduleAuditLog = await prisma.scheduleAuditLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ScheduleAuditLogs and only return the `id`
     * const scheduleAuditLogWithIdOnly = await prisma.scheduleAuditLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ScheduleAuditLogCreateManyAndReturnArgs>(args?: SelectSubset<T, ScheduleAuditLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScheduleAuditLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ScheduleAuditLog.
     * @param {ScheduleAuditLogDeleteArgs} args - Arguments to delete one ScheduleAuditLog.
     * @example
     * // Delete one ScheduleAuditLog
     * const ScheduleAuditLog = await prisma.scheduleAuditLog.delete({
     *   where: {
     *     // ... filter to delete one ScheduleAuditLog
     *   }
     * })
     * 
     */
    delete<T extends ScheduleAuditLogDeleteArgs>(args: SelectSubset<T, ScheduleAuditLogDeleteArgs<ExtArgs>>): Prisma__ScheduleAuditLogClient<$Result.GetResult<Prisma.$ScheduleAuditLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ScheduleAuditLog.
     * @param {ScheduleAuditLogUpdateArgs} args - Arguments to update one ScheduleAuditLog.
     * @example
     * // Update one ScheduleAuditLog
     * const scheduleAuditLog = await prisma.scheduleAuditLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ScheduleAuditLogUpdateArgs>(args: SelectSubset<T, ScheduleAuditLogUpdateArgs<ExtArgs>>): Prisma__ScheduleAuditLogClient<$Result.GetResult<Prisma.$ScheduleAuditLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ScheduleAuditLogs.
     * @param {ScheduleAuditLogDeleteManyArgs} args - Arguments to filter ScheduleAuditLogs to delete.
     * @example
     * // Delete a few ScheduleAuditLogs
     * const { count } = await prisma.scheduleAuditLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ScheduleAuditLogDeleteManyArgs>(args?: SelectSubset<T, ScheduleAuditLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ScheduleAuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleAuditLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ScheduleAuditLogs
     * const scheduleAuditLog = await prisma.scheduleAuditLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ScheduleAuditLogUpdateManyArgs>(args: SelectSubset<T, ScheduleAuditLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ScheduleAuditLogs and returns the data updated in the database.
     * @param {ScheduleAuditLogUpdateManyAndReturnArgs} args - Arguments to update many ScheduleAuditLogs.
     * @example
     * // Update many ScheduleAuditLogs
     * const scheduleAuditLog = await prisma.scheduleAuditLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ScheduleAuditLogs and only return the `id`
     * const scheduleAuditLogWithIdOnly = await prisma.scheduleAuditLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ScheduleAuditLogUpdateManyAndReturnArgs>(args: SelectSubset<T, ScheduleAuditLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScheduleAuditLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ScheduleAuditLog.
     * @param {ScheduleAuditLogUpsertArgs} args - Arguments to update or create a ScheduleAuditLog.
     * @example
     * // Update or create a ScheduleAuditLog
     * const scheduleAuditLog = await prisma.scheduleAuditLog.upsert({
     *   create: {
     *     // ... data to create a ScheduleAuditLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ScheduleAuditLog we want to update
     *   }
     * })
     */
    upsert<T extends ScheduleAuditLogUpsertArgs>(args: SelectSubset<T, ScheduleAuditLogUpsertArgs<ExtArgs>>): Prisma__ScheduleAuditLogClient<$Result.GetResult<Prisma.$ScheduleAuditLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ScheduleAuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleAuditLogCountArgs} args - Arguments to filter ScheduleAuditLogs to count.
     * @example
     * // Count the number of ScheduleAuditLogs
     * const count = await prisma.scheduleAuditLog.count({
     *   where: {
     *     // ... the filter for the ScheduleAuditLogs we want to count
     *   }
     * })
    **/
    count<T extends ScheduleAuditLogCountArgs>(
      args?: Subset<T, ScheduleAuditLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ScheduleAuditLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ScheduleAuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleAuditLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ScheduleAuditLogAggregateArgs>(args: Subset<T, ScheduleAuditLogAggregateArgs>): Prisma.PrismaPromise<GetScheduleAuditLogAggregateType<T>>

    /**
     * Group by ScheduleAuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleAuditLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ScheduleAuditLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ScheduleAuditLogGroupByArgs['orderBy'] }
        : { orderBy?: ScheduleAuditLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ScheduleAuditLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetScheduleAuditLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ScheduleAuditLog model
   */
  readonly fields: ScheduleAuditLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ScheduleAuditLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ScheduleAuditLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    schedule<T extends ScheduleAuditLog$scheduleArgs<ExtArgs> = {}>(args?: Subset<T, ScheduleAuditLog$scheduleArgs<ExtArgs>>): Prisma__ScheduleClient<$Result.GetResult<Prisma.$SchedulePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ScheduleAuditLog model
   */
  interface ScheduleAuditLogFieldRefs {
    readonly id: FieldRef<"ScheduleAuditLog", 'String'>
    readonly scheduleId: FieldRef<"ScheduleAuditLog", 'String'>
    readonly organizationId: FieldRef<"ScheduleAuditLog", 'String'>
    readonly action: FieldRef<"ScheduleAuditLog", 'String'>
    readonly resource: FieldRef<"ScheduleAuditLog", 'String'>
    readonly userId: FieldRef<"ScheduleAuditLog", 'String'>
    readonly userEmail: FieldRef<"ScheduleAuditLog", 'String'>
    readonly ipAddress: FieldRef<"ScheduleAuditLog", 'String'>
    readonly userAgent: FieldRef<"ScheduleAuditLog", 'String'>
    readonly requestId: FieldRef<"ScheduleAuditLog", 'String'>
    readonly previousValue: FieldRef<"ScheduleAuditLog", 'Json'>
    readonly newValue: FieldRef<"ScheduleAuditLog", 'Json'>
    readonly changedFields: FieldRef<"ScheduleAuditLog", 'String[]'>
    readonly status: FieldRef<"ScheduleAuditLog", 'String'>
    readonly errorMessage: FieldRef<"ScheduleAuditLog", 'String'>
    readonly errorCode: FieldRef<"ScheduleAuditLog", 'String'>
    readonly durationMs: FieldRef<"ScheduleAuditLog", 'Int'>
    readonly metadata: FieldRef<"ScheduleAuditLog", 'Json'>
    readonly timestamp: FieldRef<"ScheduleAuditLog", 'DateTime'>
    readonly retainUntil: FieldRef<"ScheduleAuditLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ScheduleAuditLog findUnique
   */
  export type ScheduleAuditLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduleAuditLog
     */
    select?: ScheduleAuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduleAuditLog
     */
    omit?: ScheduleAuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleAuditLogInclude<ExtArgs> | null
    /**
     * Filter, which ScheduleAuditLog to fetch.
     */
    where: ScheduleAuditLogWhereUniqueInput
  }

  /**
   * ScheduleAuditLog findUniqueOrThrow
   */
  export type ScheduleAuditLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduleAuditLog
     */
    select?: ScheduleAuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduleAuditLog
     */
    omit?: ScheduleAuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleAuditLogInclude<ExtArgs> | null
    /**
     * Filter, which ScheduleAuditLog to fetch.
     */
    where: ScheduleAuditLogWhereUniqueInput
  }

  /**
   * ScheduleAuditLog findFirst
   */
  export type ScheduleAuditLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduleAuditLog
     */
    select?: ScheduleAuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduleAuditLog
     */
    omit?: ScheduleAuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleAuditLogInclude<ExtArgs> | null
    /**
     * Filter, which ScheduleAuditLog to fetch.
     */
    where?: ScheduleAuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScheduleAuditLogs to fetch.
     */
    orderBy?: ScheduleAuditLogOrderByWithRelationInput | ScheduleAuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ScheduleAuditLogs.
     */
    cursor?: ScheduleAuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScheduleAuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScheduleAuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ScheduleAuditLogs.
     */
    distinct?: ScheduleAuditLogScalarFieldEnum | ScheduleAuditLogScalarFieldEnum[]
  }

  /**
   * ScheduleAuditLog findFirstOrThrow
   */
  export type ScheduleAuditLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduleAuditLog
     */
    select?: ScheduleAuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduleAuditLog
     */
    omit?: ScheduleAuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleAuditLogInclude<ExtArgs> | null
    /**
     * Filter, which ScheduleAuditLog to fetch.
     */
    where?: ScheduleAuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScheduleAuditLogs to fetch.
     */
    orderBy?: ScheduleAuditLogOrderByWithRelationInput | ScheduleAuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ScheduleAuditLogs.
     */
    cursor?: ScheduleAuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScheduleAuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScheduleAuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ScheduleAuditLogs.
     */
    distinct?: ScheduleAuditLogScalarFieldEnum | ScheduleAuditLogScalarFieldEnum[]
  }

  /**
   * ScheduleAuditLog findMany
   */
  export type ScheduleAuditLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduleAuditLog
     */
    select?: ScheduleAuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduleAuditLog
     */
    omit?: ScheduleAuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleAuditLogInclude<ExtArgs> | null
    /**
     * Filter, which ScheduleAuditLogs to fetch.
     */
    where?: ScheduleAuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScheduleAuditLogs to fetch.
     */
    orderBy?: ScheduleAuditLogOrderByWithRelationInput | ScheduleAuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ScheduleAuditLogs.
     */
    cursor?: ScheduleAuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScheduleAuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScheduleAuditLogs.
     */
    skip?: number
    distinct?: ScheduleAuditLogScalarFieldEnum | ScheduleAuditLogScalarFieldEnum[]
  }

  /**
   * ScheduleAuditLog create
   */
  export type ScheduleAuditLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduleAuditLog
     */
    select?: ScheduleAuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduleAuditLog
     */
    omit?: ScheduleAuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleAuditLogInclude<ExtArgs> | null
    /**
     * The data needed to create a ScheduleAuditLog.
     */
    data: XOR<ScheduleAuditLogCreateInput, ScheduleAuditLogUncheckedCreateInput>
  }

  /**
   * ScheduleAuditLog createMany
   */
  export type ScheduleAuditLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ScheduleAuditLogs.
     */
    data: ScheduleAuditLogCreateManyInput | ScheduleAuditLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ScheduleAuditLog createManyAndReturn
   */
  export type ScheduleAuditLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduleAuditLog
     */
    select?: ScheduleAuditLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduleAuditLog
     */
    omit?: ScheduleAuditLogOmit<ExtArgs> | null
    /**
     * The data used to create many ScheduleAuditLogs.
     */
    data: ScheduleAuditLogCreateManyInput | ScheduleAuditLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleAuditLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ScheduleAuditLog update
   */
  export type ScheduleAuditLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduleAuditLog
     */
    select?: ScheduleAuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduleAuditLog
     */
    omit?: ScheduleAuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleAuditLogInclude<ExtArgs> | null
    /**
     * The data needed to update a ScheduleAuditLog.
     */
    data: XOR<ScheduleAuditLogUpdateInput, ScheduleAuditLogUncheckedUpdateInput>
    /**
     * Choose, which ScheduleAuditLog to update.
     */
    where: ScheduleAuditLogWhereUniqueInput
  }

  /**
   * ScheduleAuditLog updateMany
   */
  export type ScheduleAuditLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ScheduleAuditLogs.
     */
    data: XOR<ScheduleAuditLogUpdateManyMutationInput, ScheduleAuditLogUncheckedUpdateManyInput>
    /**
     * Filter which ScheduleAuditLogs to update
     */
    where?: ScheduleAuditLogWhereInput
    /**
     * Limit how many ScheduleAuditLogs to update.
     */
    limit?: number
  }

  /**
   * ScheduleAuditLog updateManyAndReturn
   */
  export type ScheduleAuditLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduleAuditLog
     */
    select?: ScheduleAuditLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduleAuditLog
     */
    omit?: ScheduleAuditLogOmit<ExtArgs> | null
    /**
     * The data used to update ScheduleAuditLogs.
     */
    data: XOR<ScheduleAuditLogUpdateManyMutationInput, ScheduleAuditLogUncheckedUpdateManyInput>
    /**
     * Filter which ScheduleAuditLogs to update
     */
    where?: ScheduleAuditLogWhereInput
    /**
     * Limit how many ScheduleAuditLogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleAuditLogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ScheduleAuditLog upsert
   */
  export type ScheduleAuditLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduleAuditLog
     */
    select?: ScheduleAuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduleAuditLog
     */
    omit?: ScheduleAuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleAuditLogInclude<ExtArgs> | null
    /**
     * The filter to search for the ScheduleAuditLog to update in case it exists.
     */
    where: ScheduleAuditLogWhereUniqueInput
    /**
     * In case the ScheduleAuditLog found by the `where` argument doesn't exist, create a new ScheduleAuditLog with this data.
     */
    create: XOR<ScheduleAuditLogCreateInput, ScheduleAuditLogUncheckedCreateInput>
    /**
     * In case the ScheduleAuditLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ScheduleAuditLogUpdateInput, ScheduleAuditLogUncheckedUpdateInput>
  }

  /**
   * ScheduleAuditLog delete
   */
  export type ScheduleAuditLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduleAuditLog
     */
    select?: ScheduleAuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduleAuditLog
     */
    omit?: ScheduleAuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleAuditLogInclude<ExtArgs> | null
    /**
     * Filter which ScheduleAuditLog to delete.
     */
    where: ScheduleAuditLogWhereUniqueInput
  }

  /**
   * ScheduleAuditLog deleteMany
   */
  export type ScheduleAuditLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ScheduleAuditLogs to delete
     */
    where?: ScheduleAuditLogWhereInput
    /**
     * Limit how many ScheduleAuditLogs to delete.
     */
    limit?: number
  }

  /**
   * ScheduleAuditLog.schedule
   */
  export type ScheduleAuditLog$scheduleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Schedule
     */
    omit?: ScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleInclude<ExtArgs> | null
    where?: ScheduleWhereInput
  }

  /**
   * ScheduleAuditLog without action
   */
  export type ScheduleAuditLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduleAuditLog
     */
    select?: ScheduleAuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduleAuditLog
     */
    omit?: ScheduleAuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleAuditLogInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const WorkflowScalarFieldEnum: {
    id: 'id',
    organizationId: 'organizationId',
    name: 'name',
    description: 'description',
    version: 'version',
    isActive: 'isActive',
    definition: 'definition',
    eventsCount: 'eventsCount',
    estimatedDuration: 'estimatedDuration',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type WorkflowScalarFieldEnum = (typeof WorkflowScalarFieldEnum)[keyof typeof WorkflowScalarFieldEnum]


  export const JobScalarFieldEnum: {
    id: 'id',
    workflowId: 'workflowId',
    userId: 'userId',
    priority: 'priority',
    status: 'status',
    currentStep: 'currentStep',
    totalSteps: 'totalSteps',
    progressPercent: 'progressPercent',
    estimatedTimeRemaining: 'estimatedTimeRemaining',
    startedAt: 'startedAt',
    completedAt: 'completedAt',
    failedAt: 'failedAt',
    errorCode: 'errorCode',
    errorMessage: 'errorMessage',
    isRecoverable: 'isRecoverable',
    retryCount: 'retryCount',
    maxRetries: 'maxRetries',
    lastRetryAt: 'lastRetryAt',
    result: 'result',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type JobScalarFieldEnum = (typeof JobScalarFieldEnum)[keyof typeof JobScalarFieldEnum]


  export const ExecutionLogScalarFieldEnum: {
    id: 'id',
    jobId: 'jobId',
    stepIndex: 'stepIndex',
    stepName: 'stepName',
    level: 'level',
    message: 'message',
    metadata: 'metadata',
    timestamp: 'timestamp',
    duration: 'duration'
  };

  export type ExecutionLogScalarFieldEnum = (typeof ExecutionLogScalarFieldEnum)[keyof typeof ExecutionLogScalarFieldEnum]


  export const ExecutionScreenshotScalarFieldEnum: {
    id: 'id',
    jobId: 'jobId',
    stepIndex: 'stepIndex',
    stepName: 'stepName',
    screenshotType: 'screenshotType',
    blobUrl: 'blobUrl',
    signedUrl: 'signedUrl',
    size: 'size',
    width: 'width',
    height: 'height',
    format: 'format',
    isCompressed: 'isCompressed',
    originalSize: 'originalSize',
    compressionRatio: 'compressionRatio',
    metadata: 'metadata',
    capturedAt: 'capturedAt',
    expiresAt: 'expiresAt'
  };

  export type ExecutionScreenshotScalarFieldEnum = (typeof ExecutionScreenshotScalarFieldEnum)[keyof typeof ExecutionScreenshotScalarFieldEnum]


  export const CredentialScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    type: 'type',
    encryptedValue: 'encryptedValue',
    iv: 'iv',
    authTag: 'authTag',
    keyVaultId: 'keyVaultId',
    keyVersion: 'keyVersion',
    rotationDays: 'rotationDays',
    lastRotatedAt: 'lastRotatedAt',
    nextRotationAt: 'nextRotationAt',
    lastAccessedAt: 'lastAccessedAt',
    accessCount: 'accessCount',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type CredentialScalarFieldEnum = (typeof CredentialScalarFieldEnum)[keyof typeof CredentialScalarFieldEnum]


  export const CredentialAuditLogScalarFieldEnum: {
    id: 'id',
    credentialId: 'credentialId',
    action: 'action',
    userId: 'userId',
    jobId: 'jobId',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    success: 'success',
    errorMessage: 'errorMessage',
    timestamp: 'timestamp'
  };

  export type CredentialAuditLogScalarFieldEnum = (typeof CredentialAuditLogScalarFieldEnum)[keyof typeof CredentialAuditLogScalarFieldEnum]


  export const WebhookScalarFieldEnum: {
    id: 'id',
    url: 'url',
    secret: 'secret',
    events: 'events',
    isActive: 'isActive',
    maxRetries: 'maxRetries',
    retryDelay: 'retryDelay',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type WebhookScalarFieldEnum = (typeof WebhookScalarFieldEnum)[keyof typeof WebhookScalarFieldEnum]


  export const WebhookDeliveryScalarFieldEnum: {
    id: 'id',
    webhookId: 'webhookId',
    event: 'event',
    payload: 'payload',
    attempt: 'attempt',
    statusCode: 'statusCode',
    responseBody: 'responseBody',
    responseTime: 'responseTime',
    success: 'success',
    errorMessage: 'errorMessage',
    deliveredAt: 'deliveredAt',
    nextRetryAt: 'nextRetryAt'
  };

  export type WebhookDeliveryScalarFieldEnum = (typeof WebhookDeliveryScalarFieldEnum)[keyof typeof WebhookDeliveryScalarFieldEnum]


  export const ScheduleScalarFieldEnum: {
    id: 'id',
    organizationId: 'organizationId',
    workflowId: 'workflowId',
    name: 'name',
    description: 'description',
    cronExpression: 'cronExpression',
    timezone: 'timezone',
    enabled: 'enabled',
    nextExecutionTime: 'nextExecutionTime',
    lastExecutionTime: 'lastExecutionTime',
    lastExecutionStatus: 'lastExecutionStatus',
    eventBridgeRuleArn: 'eventBridgeRuleArn',
    eventBridgeRuleName: 'eventBridgeRuleName',
    executionWindow: 'executionWindow',
    maxConcurrentRuns: 'maxConcurrentRuns',
    retryPolicy: 'retryPolicy',
    dependencies: 'dependencies',
    notificationConfig: 'notificationConfig',
    tags: 'tags',
    metadata: 'metadata',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    createdBy: 'createdBy',
    updatedBy: 'updatedBy',
    deletedAt: 'deletedAt'
  };

  export type ScheduleScalarFieldEnum = (typeof ScheduleScalarFieldEnum)[keyof typeof ScheduleScalarFieldEnum]


  export const ScheduleExecutionScalarFieldEnum: {
    id: 'id',
    organizationId: 'organizationId',
    scheduleId: 'scheduleId',
    jobId: 'jobId',
    scheduledTime: 'scheduledTime',
    startedAt: 'startedAt',
    completedAt: 'completedAt',
    duration: 'duration',
    status: 'status',
    trigger: 'trigger',
    errorMessage: 'errorMessage',
    errorStack: 'errorStack',
    errorCode: 'errorCode',
    attemptNumber: 'attemptNumber',
    metadata: 'metadata',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ScheduleExecutionScalarFieldEnum = (typeof ScheduleExecutionScalarFieldEnum)[keyof typeof ScheduleExecutionScalarFieldEnum]


  export const ScheduleAuditLogScalarFieldEnum: {
    id: 'id',
    scheduleId: 'scheduleId',
    organizationId: 'organizationId',
    action: 'action',
    resource: 'resource',
    userId: 'userId',
    userEmail: 'userEmail',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    requestId: 'requestId',
    previousValue: 'previousValue',
    newValue: 'newValue',
    changedFields: 'changedFields',
    status: 'status',
    errorMessage: 'errorMessage',
    errorCode: 'errorCode',
    durationMs: 'durationMs',
    metadata: 'metadata',
    timestamp: 'timestamp',
    retainUntil: 'retainUntil'
  };

  export type ScheduleAuditLogScalarFieldEnum = (typeof ScheduleAuditLogScalarFieldEnum)[keyof typeof ScheduleAuditLogScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'JobStatus'
   */
  export type EnumJobStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'JobStatus'>
    


  /**
   * Reference to a field of type 'JobStatus[]'
   */
  export type ListEnumJobStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'JobStatus[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'LogLevel'
   */
  export type EnumLogLevelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LogLevel'>
    


  /**
   * Reference to a field of type 'LogLevel[]'
   */
  export type ListEnumLogLevelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LogLevel[]'>
    


  /**
   * Reference to a field of type 'ScreenshotType'
   */
  export type EnumScreenshotTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ScreenshotType'>
    


  /**
   * Reference to a field of type 'ScreenshotType[]'
   */
  export type ListEnumScreenshotTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ScreenshotType[]'>
    


  /**
   * Reference to a field of type 'CredentialType'
   */
  export type EnumCredentialTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CredentialType'>
    


  /**
   * Reference to a field of type 'CredentialType[]'
   */
  export type ListEnumCredentialTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CredentialType[]'>
    


  /**
   * Reference to a field of type 'CredentialAction'
   */
  export type EnumCredentialActionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CredentialAction'>
    


  /**
   * Reference to a field of type 'CredentialAction[]'
   */
  export type ListEnumCredentialActionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CredentialAction[]'>
    
  /**
   * Deep Input Types
   */


  export type WorkflowWhereInput = {
    AND?: WorkflowWhereInput | WorkflowWhereInput[]
    OR?: WorkflowWhereInput[]
    NOT?: WorkflowWhereInput | WorkflowWhereInput[]
    id?: StringFilter<"Workflow"> | string
    organizationId?: StringFilter<"Workflow"> | string
    name?: StringFilter<"Workflow"> | string
    description?: StringNullableFilter<"Workflow"> | string | null
    version?: IntFilter<"Workflow"> | number
    isActive?: BoolFilter<"Workflow"> | boolean
    definition?: JsonFilter<"Workflow">
    eventsCount?: IntFilter<"Workflow"> | number
    estimatedDuration?: IntNullableFilter<"Workflow"> | number | null
    createdAt?: DateTimeFilter<"Workflow"> | Date | string
    updatedAt?: DateTimeFilter<"Workflow"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Workflow"> | Date | string | null
    jobs?: JobListRelationFilter
    schedules?: ScheduleListRelationFilter
  }

  export type WorkflowOrderByWithRelationInput = {
    id?: SortOrder
    organizationId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    version?: SortOrder
    isActive?: SortOrder
    definition?: SortOrder
    eventsCount?: SortOrder
    estimatedDuration?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    jobs?: JobOrderByRelationAggregateInput
    schedules?: ScheduleOrderByRelationAggregateInput
  }

  export type WorkflowWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: WorkflowWhereInput | WorkflowWhereInput[]
    OR?: WorkflowWhereInput[]
    NOT?: WorkflowWhereInput | WorkflowWhereInput[]
    organizationId?: StringFilter<"Workflow"> | string
    name?: StringFilter<"Workflow"> | string
    description?: StringNullableFilter<"Workflow"> | string | null
    version?: IntFilter<"Workflow"> | number
    isActive?: BoolFilter<"Workflow"> | boolean
    definition?: JsonFilter<"Workflow">
    eventsCount?: IntFilter<"Workflow"> | number
    estimatedDuration?: IntNullableFilter<"Workflow"> | number | null
    createdAt?: DateTimeFilter<"Workflow"> | Date | string
    updatedAt?: DateTimeFilter<"Workflow"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Workflow"> | Date | string | null
    jobs?: JobListRelationFilter
    schedules?: ScheduleListRelationFilter
  }, "id">

  export type WorkflowOrderByWithAggregationInput = {
    id?: SortOrder
    organizationId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    version?: SortOrder
    isActive?: SortOrder
    definition?: SortOrder
    eventsCount?: SortOrder
    estimatedDuration?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: WorkflowCountOrderByAggregateInput
    _avg?: WorkflowAvgOrderByAggregateInput
    _max?: WorkflowMaxOrderByAggregateInput
    _min?: WorkflowMinOrderByAggregateInput
    _sum?: WorkflowSumOrderByAggregateInput
  }

  export type WorkflowScalarWhereWithAggregatesInput = {
    AND?: WorkflowScalarWhereWithAggregatesInput | WorkflowScalarWhereWithAggregatesInput[]
    OR?: WorkflowScalarWhereWithAggregatesInput[]
    NOT?: WorkflowScalarWhereWithAggregatesInput | WorkflowScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Workflow"> | string
    organizationId?: StringWithAggregatesFilter<"Workflow"> | string
    name?: StringWithAggregatesFilter<"Workflow"> | string
    description?: StringNullableWithAggregatesFilter<"Workflow"> | string | null
    version?: IntWithAggregatesFilter<"Workflow"> | number
    isActive?: BoolWithAggregatesFilter<"Workflow"> | boolean
    definition?: JsonWithAggregatesFilter<"Workflow">
    eventsCount?: IntWithAggregatesFilter<"Workflow"> | number
    estimatedDuration?: IntNullableWithAggregatesFilter<"Workflow"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"Workflow"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Workflow"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Workflow"> | Date | string | null
  }

  export type JobWhereInput = {
    AND?: JobWhereInput | JobWhereInput[]
    OR?: JobWhereInput[]
    NOT?: JobWhereInput | JobWhereInput[]
    id?: StringFilter<"Job"> | string
    workflowId?: StringFilter<"Job"> | string
    userId?: StringFilter<"Job"> | string
    priority?: IntFilter<"Job"> | number
    status?: EnumJobStatusFilter<"Job"> | $Enums.JobStatus
    currentStep?: IntFilter<"Job"> | number
    totalSteps?: IntFilter<"Job"> | number
    progressPercent?: FloatFilter<"Job"> | number
    estimatedTimeRemaining?: IntNullableFilter<"Job"> | number | null
    startedAt?: DateTimeNullableFilter<"Job"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"Job"> | Date | string | null
    failedAt?: DateTimeNullableFilter<"Job"> | Date | string | null
    errorCode?: StringNullableFilter<"Job"> | string | null
    errorMessage?: StringNullableFilter<"Job"> | string | null
    isRecoverable?: BoolFilter<"Job"> | boolean
    retryCount?: IntFilter<"Job"> | number
    maxRetries?: IntFilter<"Job"> | number
    lastRetryAt?: DateTimeNullableFilter<"Job"> | Date | string | null
    result?: JsonNullableFilter<"Job">
    createdAt?: DateTimeFilter<"Job"> | Date | string
    updatedAt?: DateTimeFilter<"Job"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Job"> | Date | string | null
    workflow?: XOR<WorkflowScalarRelationFilter, WorkflowWhereInput>
    executionLogs?: ExecutionLogListRelationFilter
    screenshots?: ExecutionScreenshotListRelationFilter
    scheduleExecution?: XOR<ScheduleExecutionNullableScalarRelationFilter, ScheduleExecutionWhereInput> | null
  }

  export type JobOrderByWithRelationInput = {
    id?: SortOrder
    workflowId?: SortOrder
    userId?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    currentStep?: SortOrder
    totalSteps?: SortOrder
    progressPercent?: SortOrder
    estimatedTimeRemaining?: SortOrderInput | SortOrder
    startedAt?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    failedAt?: SortOrderInput | SortOrder
    errorCode?: SortOrderInput | SortOrder
    errorMessage?: SortOrderInput | SortOrder
    isRecoverable?: SortOrder
    retryCount?: SortOrder
    maxRetries?: SortOrder
    lastRetryAt?: SortOrderInput | SortOrder
    result?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    workflow?: WorkflowOrderByWithRelationInput
    executionLogs?: ExecutionLogOrderByRelationAggregateInput
    screenshots?: ExecutionScreenshotOrderByRelationAggregateInput
    scheduleExecution?: ScheduleExecutionOrderByWithRelationInput
  }

  export type JobWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: JobWhereInput | JobWhereInput[]
    OR?: JobWhereInput[]
    NOT?: JobWhereInput | JobWhereInput[]
    workflowId?: StringFilter<"Job"> | string
    userId?: StringFilter<"Job"> | string
    priority?: IntFilter<"Job"> | number
    status?: EnumJobStatusFilter<"Job"> | $Enums.JobStatus
    currentStep?: IntFilter<"Job"> | number
    totalSteps?: IntFilter<"Job"> | number
    progressPercent?: FloatFilter<"Job"> | number
    estimatedTimeRemaining?: IntNullableFilter<"Job"> | number | null
    startedAt?: DateTimeNullableFilter<"Job"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"Job"> | Date | string | null
    failedAt?: DateTimeNullableFilter<"Job"> | Date | string | null
    errorCode?: StringNullableFilter<"Job"> | string | null
    errorMessage?: StringNullableFilter<"Job"> | string | null
    isRecoverable?: BoolFilter<"Job"> | boolean
    retryCount?: IntFilter<"Job"> | number
    maxRetries?: IntFilter<"Job"> | number
    lastRetryAt?: DateTimeNullableFilter<"Job"> | Date | string | null
    result?: JsonNullableFilter<"Job">
    createdAt?: DateTimeFilter<"Job"> | Date | string
    updatedAt?: DateTimeFilter<"Job"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Job"> | Date | string | null
    workflow?: XOR<WorkflowScalarRelationFilter, WorkflowWhereInput>
    executionLogs?: ExecutionLogListRelationFilter
    screenshots?: ExecutionScreenshotListRelationFilter
    scheduleExecution?: XOR<ScheduleExecutionNullableScalarRelationFilter, ScheduleExecutionWhereInput> | null
  }, "id">

  export type JobOrderByWithAggregationInput = {
    id?: SortOrder
    workflowId?: SortOrder
    userId?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    currentStep?: SortOrder
    totalSteps?: SortOrder
    progressPercent?: SortOrder
    estimatedTimeRemaining?: SortOrderInput | SortOrder
    startedAt?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    failedAt?: SortOrderInput | SortOrder
    errorCode?: SortOrderInput | SortOrder
    errorMessage?: SortOrderInput | SortOrder
    isRecoverable?: SortOrder
    retryCount?: SortOrder
    maxRetries?: SortOrder
    lastRetryAt?: SortOrderInput | SortOrder
    result?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: JobCountOrderByAggregateInput
    _avg?: JobAvgOrderByAggregateInput
    _max?: JobMaxOrderByAggregateInput
    _min?: JobMinOrderByAggregateInput
    _sum?: JobSumOrderByAggregateInput
  }

  export type JobScalarWhereWithAggregatesInput = {
    AND?: JobScalarWhereWithAggregatesInput | JobScalarWhereWithAggregatesInput[]
    OR?: JobScalarWhereWithAggregatesInput[]
    NOT?: JobScalarWhereWithAggregatesInput | JobScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Job"> | string
    workflowId?: StringWithAggregatesFilter<"Job"> | string
    userId?: StringWithAggregatesFilter<"Job"> | string
    priority?: IntWithAggregatesFilter<"Job"> | number
    status?: EnumJobStatusWithAggregatesFilter<"Job"> | $Enums.JobStatus
    currentStep?: IntWithAggregatesFilter<"Job"> | number
    totalSteps?: IntWithAggregatesFilter<"Job"> | number
    progressPercent?: FloatWithAggregatesFilter<"Job"> | number
    estimatedTimeRemaining?: IntNullableWithAggregatesFilter<"Job"> | number | null
    startedAt?: DateTimeNullableWithAggregatesFilter<"Job"> | Date | string | null
    completedAt?: DateTimeNullableWithAggregatesFilter<"Job"> | Date | string | null
    failedAt?: DateTimeNullableWithAggregatesFilter<"Job"> | Date | string | null
    errorCode?: StringNullableWithAggregatesFilter<"Job"> | string | null
    errorMessage?: StringNullableWithAggregatesFilter<"Job"> | string | null
    isRecoverable?: BoolWithAggregatesFilter<"Job"> | boolean
    retryCount?: IntWithAggregatesFilter<"Job"> | number
    maxRetries?: IntWithAggregatesFilter<"Job"> | number
    lastRetryAt?: DateTimeNullableWithAggregatesFilter<"Job"> | Date | string | null
    result?: JsonNullableWithAggregatesFilter<"Job">
    createdAt?: DateTimeWithAggregatesFilter<"Job"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Job"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Job"> | Date | string | null
  }

  export type ExecutionLogWhereInput = {
    AND?: ExecutionLogWhereInput | ExecutionLogWhereInput[]
    OR?: ExecutionLogWhereInput[]
    NOT?: ExecutionLogWhereInput | ExecutionLogWhereInput[]
    id?: StringFilter<"ExecutionLog"> | string
    jobId?: StringFilter<"ExecutionLog"> | string
    stepIndex?: IntFilter<"ExecutionLog"> | number
    stepName?: StringNullableFilter<"ExecutionLog"> | string | null
    level?: EnumLogLevelFilter<"ExecutionLog"> | $Enums.LogLevel
    message?: StringFilter<"ExecutionLog"> | string
    metadata?: JsonNullableFilter<"ExecutionLog">
    timestamp?: DateTimeFilter<"ExecutionLog"> | Date | string
    duration?: IntNullableFilter<"ExecutionLog"> | number | null
    job?: XOR<JobScalarRelationFilter, JobWhereInput>
  }

  export type ExecutionLogOrderByWithRelationInput = {
    id?: SortOrder
    jobId?: SortOrder
    stepIndex?: SortOrder
    stepName?: SortOrderInput | SortOrder
    level?: SortOrder
    message?: SortOrder
    metadata?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    duration?: SortOrderInput | SortOrder
    job?: JobOrderByWithRelationInput
  }

  export type ExecutionLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ExecutionLogWhereInput | ExecutionLogWhereInput[]
    OR?: ExecutionLogWhereInput[]
    NOT?: ExecutionLogWhereInput | ExecutionLogWhereInput[]
    jobId?: StringFilter<"ExecutionLog"> | string
    stepIndex?: IntFilter<"ExecutionLog"> | number
    stepName?: StringNullableFilter<"ExecutionLog"> | string | null
    level?: EnumLogLevelFilter<"ExecutionLog"> | $Enums.LogLevel
    message?: StringFilter<"ExecutionLog"> | string
    metadata?: JsonNullableFilter<"ExecutionLog">
    timestamp?: DateTimeFilter<"ExecutionLog"> | Date | string
    duration?: IntNullableFilter<"ExecutionLog"> | number | null
    job?: XOR<JobScalarRelationFilter, JobWhereInput>
  }, "id">

  export type ExecutionLogOrderByWithAggregationInput = {
    id?: SortOrder
    jobId?: SortOrder
    stepIndex?: SortOrder
    stepName?: SortOrderInput | SortOrder
    level?: SortOrder
    message?: SortOrder
    metadata?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    duration?: SortOrderInput | SortOrder
    _count?: ExecutionLogCountOrderByAggregateInput
    _avg?: ExecutionLogAvgOrderByAggregateInput
    _max?: ExecutionLogMaxOrderByAggregateInput
    _min?: ExecutionLogMinOrderByAggregateInput
    _sum?: ExecutionLogSumOrderByAggregateInput
  }

  export type ExecutionLogScalarWhereWithAggregatesInput = {
    AND?: ExecutionLogScalarWhereWithAggregatesInput | ExecutionLogScalarWhereWithAggregatesInput[]
    OR?: ExecutionLogScalarWhereWithAggregatesInput[]
    NOT?: ExecutionLogScalarWhereWithAggregatesInput | ExecutionLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ExecutionLog"> | string
    jobId?: StringWithAggregatesFilter<"ExecutionLog"> | string
    stepIndex?: IntWithAggregatesFilter<"ExecutionLog"> | number
    stepName?: StringNullableWithAggregatesFilter<"ExecutionLog"> | string | null
    level?: EnumLogLevelWithAggregatesFilter<"ExecutionLog"> | $Enums.LogLevel
    message?: StringWithAggregatesFilter<"ExecutionLog"> | string
    metadata?: JsonNullableWithAggregatesFilter<"ExecutionLog">
    timestamp?: DateTimeWithAggregatesFilter<"ExecutionLog"> | Date | string
    duration?: IntNullableWithAggregatesFilter<"ExecutionLog"> | number | null
  }

  export type ExecutionScreenshotWhereInput = {
    AND?: ExecutionScreenshotWhereInput | ExecutionScreenshotWhereInput[]
    OR?: ExecutionScreenshotWhereInput[]
    NOT?: ExecutionScreenshotWhereInput | ExecutionScreenshotWhereInput[]
    id?: StringFilter<"ExecutionScreenshot"> | string
    jobId?: StringFilter<"ExecutionScreenshot"> | string
    stepIndex?: IntFilter<"ExecutionScreenshot"> | number
    stepName?: StringNullableFilter<"ExecutionScreenshot"> | string | null
    screenshotType?: EnumScreenshotTypeFilter<"ExecutionScreenshot"> | $Enums.ScreenshotType
    blobUrl?: StringFilter<"ExecutionScreenshot"> | string
    signedUrl?: StringNullableFilter<"ExecutionScreenshot"> | string | null
    size?: IntFilter<"ExecutionScreenshot"> | number
    width?: IntFilter<"ExecutionScreenshot"> | number
    height?: IntFilter<"ExecutionScreenshot"> | number
    format?: StringFilter<"ExecutionScreenshot"> | string
    isCompressed?: BoolFilter<"ExecutionScreenshot"> | boolean
    originalSize?: IntNullableFilter<"ExecutionScreenshot"> | number | null
    compressionRatio?: FloatNullableFilter<"ExecutionScreenshot"> | number | null
    metadata?: JsonNullableFilter<"ExecutionScreenshot">
    capturedAt?: DateTimeFilter<"ExecutionScreenshot"> | Date | string
    expiresAt?: DateTimeNullableFilter<"ExecutionScreenshot"> | Date | string | null
    job?: XOR<JobScalarRelationFilter, JobWhereInput>
  }

  export type ExecutionScreenshotOrderByWithRelationInput = {
    id?: SortOrder
    jobId?: SortOrder
    stepIndex?: SortOrder
    stepName?: SortOrderInput | SortOrder
    screenshotType?: SortOrder
    blobUrl?: SortOrder
    signedUrl?: SortOrderInput | SortOrder
    size?: SortOrder
    width?: SortOrder
    height?: SortOrder
    format?: SortOrder
    isCompressed?: SortOrder
    originalSize?: SortOrderInput | SortOrder
    compressionRatio?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    capturedAt?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    job?: JobOrderByWithRelationInput
  }

  export type ExecutionScreenshotWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ExecutionScreenshotWhereInput | ExecutionScreenshotWhereInput[]
    OR?: ExecutionScreenshotWhereInput[]
    NOT?: ExecutionScreenshotWhereInput | ExecutionScreenshotWhereInput[]
    jobId?: StringFilter<"ExecutionScreenshot"> | string
    stepIndex?: IntFilter<"ExecutionScreenshot"> | number
    stepName?: StringNullableFilter<"ExecutionScreenshot"> | string | null
    screenshotType?: EnumScreenshotTypeFilter<"ExecutionScreenshot"> | $Enums.ScreenshotType
    blobUrl?: StringFilter<"ExecutionScreenshot"> | string
    signedUrl?: StringNullableFilter<"ExecutionScreenshot"> | string | null
    size?: IntFilter<"ExecutionScreenshot"> | number
    width?: IntFilter<"ExecutionScreenshot"> | number
    height?: IntFilter<"ExecutionScreenshot"> | number
    format?: StringFilter<"ExecutionScreenshot"> | string
    isCompressed?: BoolFilter<"ExecutionScreenshot"> | boolean
    originalSize?: IntNullableFilter<"ExecutionScreenshot"> | number | null
    compressionRatio?: FloatNullableFilter<"ExecutionScreenshot"> | number | null
    metadata?: JsonNullableFilter<"ExecutionScreenshot">
    capturedAt?: DateTimeFilter<"ExecutionScreenshot"> | Date | string
    expiresAt?: DateTimeNullableFilter<"ExecutionScreenshot"> | Date | string | null
    job?: XOR<JobScalarRelationFilter, JobWhereInput>
  }, "id">

  export type ExecutionScreenshotOrderByWithAggregationInput = {
    id?: SortOrder
    jobId?: SortOrder
    stepIndex?: SortOrder
    stepName?: SortOrderInput | SortOrder
    screenshotType?: SortOrder
    blobUrl?: SortOrder
    signedUrl?: SortOrderInput | SortOrder
    size?: SortOrder
    width?: SortOrder
    height?: SortOrder
    format?: SortOrder
    isCompressed?: SortOrder
    originalSize?: SortOrderInput | SortOrder
    compressionRatio?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    capturedAt?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    _count?: ExecutionScreenshotCountOrderByAggregateInput
    _avg?: ExecutionScreenshotAvgOrderByAggregateInput
    _max?: ExecutionScreenshotMaxOrderByAggregateInput
    _min?: ExecutionScreenshotMinOrderByAggregateInput
    _sum?: ExecutionScreenshotSumOrderByAggregateInput
  }

  export type ExecutionScreenshotScalarWhereWithAggregatesInput = {
    AND?: ExecutionScreenshotScalarWhereWithAggregatesInput | ExecutionScreenshotScalarWhereWithAggregatesInput[]
    OR?: ExecutionScreenshotScalarWhereWithAggregatesInput[]
    NOT?: ExecutionScreenshotScalarWhereWithAggregatesInput | ExecutionScreenshotScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ExecutionScreenshot"> | string
    jobId?: StringWithAggregatesFilter<"ExecutionScreenshot"> | string
    stepIndex?: IntWithAggregatesFilter<"ExecutionScreenshot"> | number
    stepName?: StringNullableWithAggregatesFilter<"ExecutionScreenshot"> | string | null
    screenshotType?: EnumScreenshotTypeWithAggregatesFilter<"ExecutionScreenshot"> | $Enums.ScreenshotType
    blobUrl?: StringWithAggregatesFilter<"ExecutionScreenshot"> | string
    signedUrl?: StringNullableWithAggregatesFilter<"ExecutionScreenshot"> | string | null
    size?: IntWithAggregatesFilter<"ExecutionScreenshot"> | number
    width?: IntWithAggregatesFilter<"ExecutionScreenshot"> | number
    height?: IntWithAggregatesFilter<"ExecutionScreenshot"> | number
    format?: StringWithAggregatesFilter<"ExecutionScreenshot"> | string
    isCompressed?: BoolWithAggregatesFilter<"ExecutionScreenshot"> | boolean
    originalSize?: IntNullableWithAggregatesFilter<"ExecutionScreenshot"> | number | null
    compressionRatio?: FloatNullableWithAggregatesFilter<"ExecutionScreenshot"> | number | null
    metadata?: JsonNullableWithAggregatesFilter<"ExecutionScreenshot">
    capturedAt?: DateTimeWithAggregatesFilter<"ExecutionScreenshot"> | Date | string
    expiresAt?: DateTimeNullableWithAggregatesFilter<"ExecutionScreenshot"> | Date | string | null
  }

  export type CredentialWhereInput = {
    AND?: CredentialWhereInput | CredentialWhereInput[]
    OR?: CredentialWhereInput[]
    NOT?: CredentialWhereInput | CredentialWhereInput[]
    id?: StringFilter<"Credential"> | string
    name?: StringFilter<"Credential"> | string
    description?: StringNullableFilter<"Credential"> | string | null
    type?: EnumCredentialTypeFilter<"Credential"> | $Enums.CredentialType
    encryptedValue?: StringFilter<"Credential"> | string
    iv?: StringFilter<"Credential"> | string
    authTag?: StringFilter<"Credential"> | string
    keyVaultId?: StringNullableFilter<"Credential"> | string | null
    keyVersion?: IntFilter<"Credential"> | number
    rotationDays?: IntFilter<"Credential"> | number
    lastRotatedAt?: DateTimeFilter<"Credential"> | Date | string
    nextRotationAt?: DateTimeFilter<"Credential"> | Date | string
    lastAccessedAt?: DateTimeNullableFilter<"Credential"> | Date | string | null
    accessCount?: IntFilter<"Credential"> | number
    createdAt?: DateTimeFilter<"Credential"> | Date | string
    updatedAt?: DateTimeFilter<"Credential"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Credential"> | Date | string | null
    auditLogs?: CredentialAuditLogListRelationFilter
  }

  export type CredentialOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    type?: SortOrder
    encryptedValue?: SortOrder
    iv?: SortOrder
    authTag?: SortOrder
    keyVaultId?: SortOrderInput | SortOrder
    keyVersion?: SortOrder
    rotationDays?: SortOrder
    lastRotatedAt?: SortOrder
    nextRotationAt?: SortOrder
    lastAccessedAt?: SortOrderInput | SortOrder
    accessCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    auditLogs?: CredentialAuditLogOrderByRelationAggregateInput
  }

  export type CredentialWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CredentialWhereInput | CredentialWhereInput[]
    OR?: CredentialWhereInput[]
    NOT?: CredentialWhereInput | CredentialWhereInput[]
    name?: StringFilter<"Credential"> | string
    description?: StringNullableFilter<"Credential"> | string | null
    type?: EnumCredentialTypeFilter<"Credential"> | $Enums.CredentialType
    encryptedValue?: StringFilter<"Credential"> | string
    iv?: StringFilter<"Credential"> | string
    authTag?: StringFilter<"Credential"> | string
    keyVaultId?: StringNullableFilter<"Credential"> | string | null
    keyVersion?: IntFilter<"Credential"> | number
    rotationDays?: IntFilter<"Credential"> | number
    lastRotatedAt?: DateTimeFilter<"Credential"> | Date | string
    nextRotationAt?: DateTimeFilter<"Credential"> | Date | string
    lastAccessedAt?: DateTimeNullableFilter<"Credential"> | Date | string | null
    accessCount?: IntFilter<"Credential"> | number
    createdAt?: DateTimeFilter<"Credential"> | Date | string
    updatedAt?: DateTimeFilter<"Credential"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Credential"> | Date | string | null
    auditLogs?: CredentialAuditLogListRelationFilter
  }, "id">

  export type CredentialOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    type?: SortOrder
    encryptedValue?: SortOrder
    iv?: SortOrder
    authTag?: SortOrder
    keyVaultId?: SortOrderInput | SortOrder
    keyVersion?: SortOrder
    rotationDays?: SortOrder
    lastRotatedAt?: SortOrder
    nextRotationAt?: SortOrder
    lastAccessedAt?: SortOrderInput | SortOrder
    accessCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: CredentialCountOrderByAggregateInput
    _avg?: CredentialAvgOrderByAggregateInput
    _max?: CredentialMaxOrderByAggregateInput
    _min?: CredentialMinOrderByAggregateInput
    _sum?: CredentialSumOrderByAggregateInput
  }

  export type CredentialScalarWhereWithAggregatesInput = {
    AND?: CredentialScalarWhereWithAggregatesInput | CredentialScalarWhereWithAggregatesInput[]
    OR?: CredentialScalarWhereWithAggregatesInput[]
    NOT?: CredentialScalarWhereWithAggregatesInput | CredentialScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Credential"> | string
    name?: StringWithAggregatesFilter<"Credential"> | string
    description?: StringNullableWithAggregatesFilter<"Credential"> | string | null
    type?: EnumCredentialTypeWithAggregatesFilter<"Credential"> | $Enums.CredentialType
    encryptedValue?: StringWithAggregatesFilter<"Credential"> | string
    iv?: StringWithAggregatesFilter<"Credential"> | string
    authTag?: StringWithAggregatesFilter<"Credential"> | string
    keyVaultId?: StringNullableWithAggregatesFilter<"Credential"> | string | null
    keyVersion?: IntWithAggregatesFilter<"Credential"> | number
    rotationDays?: IntWithAggregatesFilter<"Credential"> | number
    lastRotatedAt?: DateTimeWithAggregatesFilter<"Credential"> | Date | string
    nextRotationAt?: DateTimeWithAggregatesFilter<"Credential"> | Date | string
    lastAccessedAt?: DateTimeNullableWithAggregatesFilter<"Credential"> | Date | string | null
    accessCount?: IntWithAggregatesFilter<"Credential"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Credential"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Credential"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Credential"> | Date | string | null
  }

  export type CredentialAuditLogWhereInput = {
    AND?: CredentialAuditLogWhereInput | CredentialAuditLogWhereInput[]
    OR?: CredentialAuditLogWhereInput[]
    NOT?: CredentialAuditLogWhereInput | CredentialAuditLogWhereInput[]
    id?: StringFilter<"CredentialAuditLog"> | string
    credentialId?: StringFilter<"CredentialAuditLog"> | string
    action?: EnumCredentialActionFilter<"CredentialAuditLog"> | $Enums.CredentialAction
    userId?: StringNullableFilter<"CredentialAuditLog"> | string | null
    jobId?: StringNullableFilter<"CredentialAuditLog"> | string | null
    ipAddress?: StringNullableFilter<"CredentialAuditLog"> | string | null
    userAgent?: StringNullableFilter<"CredentialAuditLog"> | string | null
    success?: BoolFilter<"CredentialAuditLog"> | boolean
    errorMessage?: StringNullableFilter<"CredentialAuditLog"> | string | null
    timestamp?: DateTimeFilter<"CredentialAuditLog"> | Date | string
    credential?: XOR<CredentialScalarRelationFilter, CredentialWhereInput>
  }

  export type CredentialAuditLogOrderByWithRelationInput = {
    id?: SortOrder
    credentialId?: SortOrder
    action?: SortOrder
    userId?: SortOrderInput | SortOrder
    jobId?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    success?: SortOrder
    errorMessage?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    credential?: CredentialOrderByWithRelationInput
  }

  export type CredentialAuditLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CredentialAuditLogWhereInput | CredentialAuditLogWhereInput[]
    OR?: CredentialAuditLogWhereInput[]
    NOT?: CredentialAuditLogWhereInput | CredentialAuditLogWhereInput[]
    credentialId?: StringFilter<"CredentialAuditLog"> | string
    action?: EnumCredentialActionFilter<"CredentialAuditLog"> | $Enums.CredentialAction
    userId?: StringNullableFilter<"CredentialAuditLog"> | string | null
    jobId?: StringNullableFilter<"CredentialAuditLog"> | string | null
    ipAddress?: StringNullableFilter<"CredentialAuditLog"> | string | null
    userAgent?: StringNullableFilter<"CredentialAuditLog"> | string | null
    success?: BoolFilter<"CredentialAuditLog"> | boolean
    errorMessage?: StringNullableFilter<"CredentialAuditLog"> | string | null
    timestamp?: DateTimeFilter<"CredentialAuditLog"> | Date | string
    credential?: XOR<CredentialScalarRelationFilter, CredentialWhereInput>
  }, "id">

  export type CredentialAuditLogOrderByWithAggregationInput = {
    id?: SortOrder
    credentialId?: SortOrder
    action?: SortOrder
    userId?: SortOrderInput | SortOrder
    jobId?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    success?: SortOrder
    errorMessage?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    _count?: CredentialAuditLogCountOrderByAggregateInput
    _max?: CredentialAuditLogMaxOrderByAggregateInput
    _min?: CredentialAuditLogMinOrderByAggregateInput
  }

  export type CredentialAuditLogScalarWhereWithAggregatesInput = {
    AND?: CredentialAuditLogScalarWhereWithAggregatesInput | CredentialAuditLogScalarWhereWithAggregatesInput[]
    OR?: CredentialAuditLogScalarWhereWithAggregatesInput[]
    NOT?: CredentialAuditLogScalarWhereWithAggregatesInput | CredentialAuditLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CredentialAuditLog"> | string
    credentialId?: StringWithAggregatesFilter<"CredentialAuditLog"> | string
    action?: EnumCredentialActionWithAggregatesFilter<"CredentialAuditLog"> | $Enums.CredentialAction
    userId?: StringNullableWithAggregatesFilter<"CredentialAuditLog"> | string | null
    jobId?: StringNullableWithAggregatesFilter<"CredentialAuditLog"> | string | null
    ipAddress?: StringNullableWithAggregatesFilter<"CredentialAuditLog"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"CredentialAuditLog"> | string | null
    success?: BoolWithAggregatesFilter<"CredentialAuditLog"> | boolean
    errorMessage?: StringNullableWithAggregatesFilter<"CredentialAuditLog"> | string | null
    timestamp?: DateTimeWithAggregatesFilter<"CredentialAuditLog"> | Date | string
  }

  export type WebhookWhereInput = {
    AND?: WebhookWhereInput | WebhookWhereInput[]
    OR?: WebhookWhereInput[]
    NOT?: WebhookWhereInput | WebhookWhereInput[]
    id?: StringFilter<"Webhook"> | string
    url?: StringFilter<"Webhook"> | string
    secret?: StringFilter<"Webhook"> | string
    events?: StringNullableListFilter<"Webhook">
    isActive?: BoolFilter<"Webhook"> | boolean
    maxRetries?: IntFilter<"Webhook"> | number
    retryDelay?: IntFilter<"Webhook"> | number
    createdAt?: DateTimeFilter<"Webhook"> | Date | string
    updatedAt?: DateTimeFilter<"Webhook"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Webhook"> | Date | string | null
    deliveries?: WebhookDeliveryListRelationFilter
  }

  export type WebhookOrderByWithRelationInput = {
    id?: SortOrder
    url?: SortOrder
    secret?: SortOrder
    events?: SortOrder
    isActive?: SortOrder
    maxRetries?: SortOrder
    retryDelay?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    deliveries?: WebhookDeliveryOrderByRelationAggregateInput
  }

  export type WebhookWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: WebhookWhereInput | WebhookWhereInput[]
    OR?: WebhookWhereInput[]
    NOT?: WebhookWhereInput | WebhookWhereInput[]
    url?: StringFilter<"Webhook"> | string
    secret?: StringFilter<"Webhook"> | string
    events?: StringNullableListFilter<"Webhook">
    isActive?: BoolFilter<"Webhook"> | boolean
    maxRetries?: IntFilter<"Webhook"> | number
    retryDelay?: IntFilter<"Webhook"> | number
    createdAt?: DateTimeFilter<"Webhook"> | Date | string
    updatedAt?: DateTimeFilter<"Webhook"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Webhook"> | Date | string | null
    deliveries?: WebhookDeliveryListRelationFilter
  }, "id">

  export type WebhookOrderByWithAggregationInput = {
    id?: SortOrder
    url?: SortOrder
    secret?: SortOrder
    events?: SortOrder
    isActive?: SortOrder
    maxRetries?: SortOrder
    retryDelay?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: WebhookCountOrderByAggregateInput
    _avg?: WebhookAvgOrderByAggregateInput
    _max?: WebhookMaxOrderByAggregateInput
    _min?: WebhookMinOrderByAggregateInput
    _sum?: WebhookSumOrderByAggregateInput
  }

  export type WebhookScalarWhereWithAggregatesInput = {
    AND?: WebhookScalarWhereWithAggregatesInput | WebhookScalarWhereWithAggregatesInput[]
    OR?: WebhookScalarWhereWithAggregatesInput[]
    NOT?: WebhookScalarWhereWithAggregatesInput | WebhookScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Webhook"> | string
    url?: StringWithAggregatesFilter<"Webhook"> | string
    secret?: StringWithAggregatesFilter<"Webhook"> | string
    events?: StringNullableListFilter<"Webhook">
    isActive?: BoolWithAggregatesFilter<"Webhook"> | boolean
    maxRetries?: IntWithAggregatesFilter<"Webhook"> | number
    retryDelay?: IntWithAggregatesFilter<"Webhook"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Webhook"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Webhook"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Webhook"> | Date | string | null
  }

  export type WebhookDeliveryWhereInput = {
    AND?: WebhookDeliveryWhereInput | WebhookDeliveryWhereInput[]
    OR?: WebhookDeliveryWhereInput[]
    NOT?: WebhookDeliveryWhereInput | WebhookDeliveryWhereInput[]
    id?: StringFilter<"WebhookDelivery"> | string
    webhookId?: StringFilter<"WebhookDelivery"> | string
    event?: StringFilter<"WebhookDelivery"> | string
    payload?: JsonFilter<"WebhookDelivery">
    attempt?: IntFilter<"WebhookDelivery"> | number
    statusCode?: IntNullableFilter<"WebhookDelivery"> | number | null
    responseBody?: StringNullableFilter<"WebhookDelivery"> | string | null
    responseTime?: IntNullableFilter<"WebhookDelivery"> | number | null
    success?: BoolFilter<"WebhookDelivery"> | boolean
    errorMessage?: StringNullableFilter<"WebhookDelivery"> | string | null
    deliveredAt?: DateTimeFilter<"WebhookDelivery"> | Date | string
    nextRetryAt?: DateTimeNullableFilter<"WebhookDelivery"> | Date | string | null
    webhook?: XOR<WebhookScalarRelationFilter, WebhookWhereInput>
  }

  export type WebhookDeliveryOrderByWithRelationInput = {
    id?: SortOrder
    webhookId?: SortOrder
    event?: SortOrder
    payload?: SortOrder
    attempt?: SortOrder
    statusCode?: SortOrderInput | SortOrder
    responseBody?: SortOrderInput | SortOrder
    responseTime?: SortOrderInput | SortOrder
    success?: SortOrder
    errorMessage?: SortOrderInput | SortOrder
    deliveredAt?: SortOrder
    nextRetryAt?: SortOrderInput | SortOrder
    webhook?: WebhookOrderByWithRelationInput
  }

  export type WebhookDeliveryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: WebhookDeliveryWhereInput | WebhookDeliveryWhereInput[]
    OR?: WebhookDeliveryWhereInput[]
    NOT?: WebhookDeliveryWhereInput | WebhookDeliveryWhereInput[]
    webhookId?: StringFilter<"WebhookDelivery"> | string
    event?: StringFilter<"WebhookDelivery"> | string
    payload?: JsonFilter<"WebhookDelivery">
    attempt?: IntFilter<"WebhookDelivery"> | number
    statusCode?: IntNullableFilter<"WebhookDelivery"> | number | null
    responseBody?: StringNullableFilter<"WebhookDelivery"> | string | null
    responseTime?: IntNullableFilter<"WebhookDelivery"> | number | null
    success?: BoolFilter<"WebhookDelivery"> | boolean
    errorMessage?: StringNullableFilter<"WebhookDelivery"> | string | null
    deliveredAt?: DateTimeFilter<"WebhookDelivery"> | Date | string
    nextRetryAt?: DateTimeNullableFilter<"WebhookDelivery"> | Date | string | null
    webhook?: XOR<WebhookScalarRelationFilter, WebhookWhereInput>
  }, "id">

  export type WebhookDeliveryOrderByWithAggregationInput = {
    id?: SortOrder
    webhookId?: SortOrder
    event?: SortOrder
    payload?: SortOrder
    attempt?: SortOrder
    statusCode?: SortOrderInput | SortOrder
    responseBody?: SortOrderInput | SortOrder
    responseTime?: SortOrderInput | SortOrder
    success?: SortOrder
    errorMessage?: SortOrderInput | SortOrder
    deliveredAt?: SortOrder
    nextRetryAt?: SortOrderInput | SortOrder
    _count?: WebhookDeliveryCountOrderByAggregateInput
    _avg?: WebhookDeliveryAvgOrderByAggregateInput
    _max?: WebhookDeliveryMaxOrderByAggregateInput
    _min?: WebhookDeliveryMinOrderByAggregateInput
    _sum?: WebhookDeliverySumOrderByAggregateInput
  }

  export type WebhookDeliveryScalarWhereWithAggregatesInput = {
    AND?: WebhookDeliveryScalarWhereWithAggregatesInput | WebhookDeliveryScalarWhereWithAggregatesInput[]
    OR?: WebhookDeliveryScalarWhereWithAggregatesInput[]
    NOT?: WebhookDeliveryScalarWhereWithAggregatesInput | WebhookDeliveryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WebhookDelivery"> | string
    webhookId?: StringWithAggregatesFilter<"WebhookDelivery"> | string
    event?: StringWithAggregatesFilter<"WebhookDelivery"> | string
    payload?: JsonWithAggregatesFilter<"WebhookDelivery">
    attempt?: IntWithAggregatesFilter<"WebhookDelivery"> | number
    statusCode?: IntNullableWithAggregatesFilter<"WebhookDelivery"> | number | null
    responseBody?: StringNullableWithAggregatesFilter<"WebhookDelivery"> | string | null
    responseTime?: IntNullableWithAggregatesFilter<"WebhookDelivery"> | number | null
    success?: BoolWithAggregatesFilter<"WebhookDelivery"> | boolean
    errorMessage?: StringNullableWithAggregatesFilter<"WebhookDelivery"> | string | null
    deliveredAt?: DateTimeWithAggregatesFilter<"WebhookDelivery"> | Date | string
    nextRetryAt?: DateTimeNullableWithAggregatesFilter<"WebhookDelivery"> | Date | string | null
  }

  export type ScheduleWhereInput = {
    AND?: ScheduleWhereInput | ScheduleWhereInput[]
    OR?: ScheduleWhereInput[]
    NOT?: ScheduleWhereInput | ScheduleWhereInput[]
    id?: StringFilter<"Schedule"> | string
    organizationId?: StringFilter<"Schedule"> | string
    workflowId?: StringFilter<"Schedule"> | string
    name?: StringFilter<"Schedule"> | string
    description?: StringNullableFilter<"Schedule"> | string | null
    cronExpression?: StringFilter<"Schedule"> | string
    timezone?: StringFilter<"Schedule"> | string
    enabled?: BoolFilter<"Schedule"> | boolean
    nextExecutionTime?: DateTimeNullableFilter<"Schedule"> | Date | string | null
    lastExecutionTime?: DateTimeNullableFilter<"Schedule"> | Date | string | null
    lastExecutionStatus?: StringNullableFilter<"Schedule"> | string | null
    eventBridgeRuleArn?: StringNullableFilter<"Schedule"> | string | null
    eventBridgeRuleName?: StringNullableFilter<"Schedule"> | string | null
    executionWindow?: JsonNullableFilter<"Schedule">
    maxConcurrentRuns?: IntFilter<"Schedule"> | number
    retryPolicy?: JsonNullableFilter<"Schedule">
    dependencies?: JsonNullableFilter<"Schedule">
    notificationConfig?: JsonNullableFilter<"Schedule">
    tags?: StringNullableListFilter<"Schedule">
    metadata?: JsonNullableFilter<"Schedule">
    createdAt?: DateTimeFilter<"Schedule"> | Date | string
    updatedAt?: DateTimeFilter<"Schedule"> | Date | string
    createdBy?: StringFilter<"Schedule"> | string
    updatedBy?: StringNullableFilter<"Schedule"> | string | null
    deletedAt?: DateTimeNullableFilter<"Schedule"> | Date | string | null
    workflow?: XOR<WorkflowScalarRelationFilter, WorkflowWhereInput>
    executions?: ScheduleExecutionListRelationFilter
    auditLogs?: ScheduleAuditLogListRelationFilter
  }

  export type ScheduleOrderByWithRelationInput = {
    id?: SortOrder
    organizationId?: SortOrder
    workflowId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    cronExpression?: SortOrder
    timezone?: SortOrder
    enabled?: SortOrder
    nextExecutionTime?: SortOrderInput | SortOrder
    lastExecutionTime?: SortOrderInput | SortOrder
    lastExecutionStatus?: SortOrderInput | SortOrder
    eventBridgeRuleArn?: SortOrderInput | SortOrder
    eventBridgeRuleName?: SortOrderInput | SortOrder
    executionWindow?: SortOrderInput | SortOrder
    maxConcurrentRuns?: SortOrder
    retryPolicy?: SortOrderInput | SortOrder
    dependencies?: SortOrderInput | SortOrder
    notificationConfig?: SortOrderInput | SortOrder
    tags?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrderInput | SortOrder
    deletedAt?: SortOrderInput | SortOrder
    workflow?: WorkflowOrderByWithRelationInput
    executions?: ScheduleExecutionOrderByRelationAggregateInput
    auditLogs?: ScheduleAuditLogOrderByRelationAggregateInput
  }

  export type ScheduleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    eventBridgeRuleName?: string
    AND?: ScheduleWhereInput | ScheduleWhereInput[]
    OR?: ScheduleWhereInput[]
    NOT?: ScheduleWhereInput | ScheduleWhereInput[]
    organizationId?: StringFilter<"Schedule"> | string
    workflowId?: StringFilter<"Schedule"> | string
    name?: StringFilter<"Schedule"> | string
    description?: StringNullableFilter<"Schedule"> | string | null
    cronExpression?: StringFilter<"Schedule"> | string
    timezone?: StringFilter<"Schedule"> | string
    enabled?: BoolFilter<"Schedule"> | boolean
    nextExecutionTime?: DateTimeNullableFilter<"Schedule"> | Date | string | null
    lastExecutionTime?: DateTimeNullableFilter<"Schedule"> | Date | string | null
    lastExecutionStatus?: StringNullableFilter<"Schedule"> | string | null
    eventBridgeRuleArn?: StringNullableFilter<"Schedule"> | string | null
    executionWindow?: JsonNullableFilter<"Schedule">
    maxConcurrentRuns?: IntFilter<"Schedule"> | number
    retryPolicy?: JsonNullableFilter<"Schedule">
    dependencies?: JsonNullableFilter<"Schedule">
    notificationConfig?: JsonNullableFilter<"Schedule">
    tags?: StringNullableListFilter<"Schedule">
    metadata?: JsonNullableFilter<"Schedule">
    createdAt?: DateTimeFilter<"Schedule"> | Date | string
    updatedAt?: DateTimeFilter<"Schedule"> | Date | string
    createdBy?: StringFilter<"Schedule"> | string
    updatedBy?: StringNullableFilter<"Schedule"> | string | null
    deletedAt?: DateTimeNullableFilter<"Schedule"> | Date | string | null
    workflow?: XOR<WorkflowScalarRelationFilter, WorkflowWhereInput>
    executions?: ScheduleExecutionListRelationFilter
    auditLogs?: ScheduleAuditLogListRelationFilter
  }, "id" | "eventBridgeRuleName">

  export type ScheduleOrderByWithAggregationInput = {
    id?: SortOrder
    organizationId?: SortOrder
    workflowId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    cronExpression?: SortOrder
    timezone?: SortOrder
    enabled?: SortOrder
    nextExecutionTime?: SortOrderInput | SortOrder
    lastExecutionTime?: SortOrderInput | SortOrder
    lastExecutionStatus?: SortOrderInput | SortOrder
    eventBridgeRuleArn?: SortOrderInput | SortOrder
    eventBridgeRuleName?: SortOrderInput | SortOrder
    executionWindow?: SortOrderInput | SortOrder
    maxConcurrentRuns?: SortOrder
    retryPolicy?: SortOrderInput | SortOrder
    dependencies?: SortOrderInput | SortOrder
    notificationConfig?: SortOrderInput | SortOrder
    tags?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrderInput | SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: ScheduleCountOrderByAggregateInput
    _avg?: ScheduleAvgOrderByAggregateInput
    _max?: ScheduleMaxOrderByAggregateInput
    _min?: ScheduleMinOrderByAggregateInput
    _sum?: ScheduleSumOrderByAggregateInput
  }

  export type ScheduleScalarWhereWithAggregatesInput = {
    AND?: ScheduleScalarWhereWithAggregatesInput | ScheduleScalarWhereWithAggregatesInput[]
    OR?: ScheduleScalarWhereWithAggregatesInput[]
    NOT?: ScheduleScalarWhereWithAggregatesInput | ScheduleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Schedule"> | string
    organizationId?: StringWithAggregatesFilter<"Schedule"> | string
    workflowId?: StringWithAggregatesFilter<"Schedule"> | string
    name?: StringWithAggregatesFilter<"Schedule"> | string
    description?: StringNullableWithAggregatesFilter<"Schedule"> | string | null
    cronExpression?: StringWithAggregatesFilter<"Schedule"> | string
    timezone?: StringWithAggregatesFilter<"Schedule"> | string
    enabled?: BoolWithAggregatesFilter<"Schedule"> | boolean
    nextExecutionTime?: DateTimeNullableWithAggregatesFilter<"Schedule"> | Date | string | null
    lastExecutionTime?: DateTimeNullableWithAggregatesFilter<"Schedule"> | Date | string | null
    lastExecutionStatus?: StringNullableWithAggregatesFilter<"Schedule"> | string | null
    eventBridgeRuleArn?: StringNullableWithAggregatesFilter<"Schedule"> | string | null
    eventBridgeRuleName?: StringNullableWithAggregatesFilter<"Schedule"> | string | null
    executionWindow?: JsonNullableWithAggregatesFilter<"Schedule">
    maxConcurrentRuns?: IntWithAggregatesFilter<"Schedule"> | number
    retryPolicy?: JsonNullableWithAggregatesFilter<"Schedule">
    dependencies?: JsonNullableWithAggregatesFilter<"Schedule">
    notificationConfig?: JsonNullableWithAggregatesFilter<"Schedule">
    tags?: StringNullableListFilter<"Schedule">
    metadata?: JsonNullableWithAggregatesFilter<"Schedule">
    createdAt?: DateTimeWithAggregatesFilter<"Schedule"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Schedule"> | Date | string
    createdBy?: StringWithAggregatesFilter<"Schedule"> | string
    updatedBy?: StringNullableWithAggregatesFilter<"Schedule"> | string | null
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Schedule"> | Date | string | null
  }

  export type ScheduleExecutionWhereInput = {
    AND?: ScheduleExecutionWhereInput | ScheduleExecutionWhereInput[]
    OR?: ScheduleExecutionWhereInput[]
    NOT?: ScheduleExecutionWhereInput | ScheduleExecutionWhereInput[]
    id?: StringFilter<"ScheduleExecution"> | string
    organizationId?: StringFilter<"ScheduleExecution"> | string
    scheduleId?: StringFilter<"ScheduleExecution"> | string
    jobId?: StringNullableFilter<"ScheduleExecution"> | string | null
    scheduledTime?: DateTimeFilter<"ScheduleExecution"> | Date | string
    startedAt?: DateTimeNullableFilter<"ScheduleExecution"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"ScheduleExecution"> | Date | string | null
    duration?: IntNullableFilter<"ScheduleExecution"> | number | null
    status?: StringFilter<"ScheduleExecution"> | string
    trigger?: StringFilter<"ScheduleExecution"> | string
    errorMessage?: StringNullableFilter<"ScheduleExecution"> | string | null
    errorStack?: StringNullableFilter<"ScheduleExecution"> | string | null
    errorCode?: StringNullableFilter<"ScheduleExecution"> | string | null
    attemptNumber?: IntFilter<"ScheduleExecution"> | number
    metadata?: JsonNullableFilter<"ScheduleExecution">
    createdAt?: DateTimeFilter<"ScheduleExecution"> | Date | string
    updatedAt?: DateTimeFilter<"ScheduleExecution"> | Date | string
    schedule?: XOR<ScheduleScalarRelationFilter, ScheduleWhereInput>
    job?: XOR<JobNullableScalarRelationFilter, JobWhereInput> | null
  }

  export type ScheduleExecutionOrderByWithRelationInput = {
    id?: SortOrder
    organizationId?: SortOrder
    scheduleId?: SortOrder
    jobId?: SortOrderInput | SortOrder
    scheduledTime?: SortOrder
    startedAt?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    duration?: SortOrderInput | SortOrder
    status?: SortOrder
    trigger?: SortOrder
    errorMessage?: SortOrderInput | SortOrder
    errorStack?: SortOrderInput | SortOrder
    errorCode?: SortOrderInput | SortOrder
    attemptNumber?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    schedule?: ScheduleOrderByWithRelationInput
    job?: JobOrderByWithRelationInput
  }

  export type ScheduleExecutionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    jobId?: string
    AND?: ScheduleExecutionWhereInput | ScheduleExecutionWhereInput[]
    OR?: ScheduleExecutionWhereInput[]
    NOT?: ScheduleExecutionWhereInput | ScheduleExecutionWhereInput[]
    organizationId?: StringFilter<"ScheduleExecution"> | string
    scheduleId?: StringFilter<"ScheduleExecution"> | string
    scheduledTime?: DateTimeFilter<"ScheduleExecution"> | Date | string
    startedAt?: DateTimeNullableFilter<"ScheduleExecution"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"ScheduleExecution"> | Date | string | null
    duration?: IntNullableFilter<"ScheduleExecution"> | number | null
    status?: StringFilter<"ScheduleExecution"> | string
    trigger?: StringFilter<"ScheduleExecution"> | string
    errorMessage?: StringNullableFilter<"ScheduleExecution"> | string | null
    errorStack?: StringNullableFilter<"ScheduleExecution"> | string | null
    errorCode?: StringNullableFilter<"ScheduleExecution"> | string | null
    attemptNumber?: IntFilter<"ScheduleExecution"> | number
    metadata?: JsonNullableFilter<"ScheduleExecution">
    createdAt?: DateTimeFilter<"ScheduleExecution"> | Date | string
    updatedAt?: DateTimeFilter<"ScheduleExecution"> | Date | string
    schedule?: XOR<ScheduleScalarRelationFilter, ScheduleWhereInput>
    job?: XOR<JobNullableScalarRelationFilter, JobWhereInput> | null
  }, "id" | "jobId">

  export type ScheduleExecutionOrderByWithAggregationInput = {
    id?: SortOrder
    organizationId?: SortOrder
    scheduleId?: SortOrder
    jobId?: SortOrderInput | SortOrder
    scheduledTime?: SortOrder
    startedAt?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    duration?: SortOrderInput | SortOrder
    status?: SortOrder
    trigger?: SortOrder
    errorMessage?: SortOrderInput | SortOrder
    errorStack?: SortOrderInput | SortOrder
    errorCode?: SortOrderInput | SortOrder
    attemptNumber?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ScheduleExecutionCountOrderByAggregateInput
    _avg?: ScheduleExecutionAvgOrderByAggregateInput
    _max?: ScheduleExecutionMaxOrderByAggregateInput
    _min?: ScheduleExecutionMinOrderByAggregateInput
    _sum?: ScheduleExecutionSumOrderByAggregateInput
  }

  export type ScheduleExecutionScalarWhereWithAggregatesInput = {
    AND?: ScheduleExecutionScalarWhereWithAggregatesInput | ScheduleExecutionScalarWhereWithAggregatesInput[]
    OR?: ScheduleExecutionScalarWhereWithAggregatesInput[]
    NOT?: ScheduleExecutionScalarWhereWithAggregatesInput | ScheduleExecutionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ScheduleExecution"> | string
    organizationId?: StringWithAggregatesFilter<"ScheduleExecution"> | string
    scheduleId?: StringWithAggregatesFilter<"ScheduleExecution"> | string
    jobId?: StringNullableWithAggregatesFilter<"ScheduleExecution"> | string | null
    scheduledTime?: DateTimeWithAggregatesFilter<"ScheduleExecution"> | Date | string
    startedAt?: DateTimeNullableWithAggregatesFilter<"ScheduleExecution"> | Date | string | null
    completedAt?: DateTimeNullableWithAggregatesFilter<"ScheduleExecution"> | Date | string | null
    duration?: IntNullableWithAggregatesFilter<"ScheduleExecution"> | number | null
    status?: StringWithAggregatesFilter<"ScheduleExecution"> | string
    trigger?: StringWithAggregatesFilter<"ScheduleExecution"> | string
    errorMessage?: StringNullableWithAggregatesFilter<"ScheduleExecution"> | string | null
    errorStack?: StringNullableWithAggregatesFilter<"ScheduleExecution"> | string | null
    errorCode?: StringNullableWithAggregatesFilter<"ScheduleExecution"> | string | null
    attemptNumber?: IntWithAggregatesFilter<"ScheduleExecution"> | number
    metadata?: JsonNullableWithAggregatesFilter<"ScheduleExecution">
    createdAt?: DateTimeWithAggregatesFilter<"ScheduleExecution"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ScheduleExecution"> | Date | string
  }

  export type ScheduleAuditLogWhereInput = {
    AND?: ScheduleAuditLogWhereInput | ScheduleAuditLogWhereInput[]
    OR?: ScheduleAuditLogWhereInput[]
    NOT?: ScheduleAuditLogWhereInput | ScheduleAuditLogWhereInput[]
    id?: StringFilter<"ScheduleAuditLog"> | string
    scheduleId?: StringNullableFilter<"ScheduleAuditLog"> | string | null
    organizationId?: StringFilter<"ScheduleAuditLog"> | string
    action?: StringFilter<"ScheduleAuditLog"> | string
    resource?: StringFilter<"ScheduleAuditLog"> | string
    userId?: StringFilter<"ScheduleAuditLog"> | string
    userEmail?: StringNullableFilter<"ScheduleAuditLog"> | string | null
    ipAddress?: StringNullableFilter<"ScheduleAuditLog"> | string | null
    userAgent?: StringNullableFilter<"ScheduleAuditLog"> | string | null
    requestId?: StringNullableFilter<"ScheduleAuditLog"> | string | null
    previousValue?: JsonNullableFilter<"ScheduleAuditLog">
    newValue?: JsonNullableFilter<"ScheduleAuditLog">
    changedFields?: StringNullableListFilter<"ScheduleAuditLog">
    status?: StringFilter<"ScheduleAuditLog"> | string
    errorMessage?: StringNullableFilter<"ScheduleAuditLog"> | string | null
    errorCode?: StringNullableFilter<"ScheduleAuditLog"> | string | null
    durationMs?: IntNullableFilter<"ScheduleAuditLog"> | number | null
    metadata?: JsonNullableFilter<"ScheduleAuditLog">
    timestamp?: DateTimeFilter<"ScheduleAuditLog"> | Date | string
    retainUntil?: DateTimeFilter<"ScheduleAuditLog"> | Date | string
    schedule?: XOR<ScheduleNullableScalarRelationFilter, ScheduleWhereInput> | null
  }

  export type ScheduleAuditLogOrderByWithRelationInput = {
    id?: SortOrder
    scheduleId?: SortOrderInput | SortOrder
    organizationId?: SortOrder
    action?: SortOrder
    resource?: SortOrder
    userId?: SortOrder
    userEmail?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    requestId?: SortOrderInput | SortOrder
    previousValue?: SortOrderInput | SortOrder
    newValue?: SortOrderInput | SortOrder
    changedFields?: SortOrder
    status?: SortOrder
    errorMessage?: SortOrderInput | SortOrder
    errorCode?: SortOrderInput | SortOrder
    durationMs?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    retainUntil?: SortOrder
    schedule?: ScheduleOrderByWithRelationInput
  }

  export type ScheduleAuditLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ScheduleAuditLogWhereInput | ScheduleAuditLogWhereInput[]
    OR?: ScheduleAuditLogWhereInput[]
    NOT?: ScheduleAuditLogWhereInput | ScheduleAuditLogWhereInput[]
    scheduleId?: StringNullableFilter<"ScheduleAuditLog"> | string | null
    organizationId?: StringFilter<"ScheduleAuditLog"> | string
    action?: StringFilter<"ScheduleAuditLog"> | string
    resource?: StringFilter<"ScheduleAuditLog"> | string
    userId?: StringFilter<"ScheduleAuditLog"> | string
    userEmail?: StringNullableFilter<"ScheduleAuditLog"> | string | null
    ipAddress?: StringNullableFilter<"ScheduleAuditLog"> | string | null
    userAgent?: StringNullableFilter<"ScheduleAuditLog"> | string | null
    requestId?: StringNullableFilter<"ScheduleAuditLog"> | string | null
    previousValue?: JsonNullableFilter<"ScheduleAuditLog">
    newValue?: JsonNullableFilter<"ScheduleAuditLog">
    changedFields?: StringNullableListFilter<"ScheduleAuditLog">
    status?: StringFilter<"ScheduleAuditLog"> | string
    errorMessage?: StringNullableFilter<"ScheduleAuditLog"> | string | null
    errorCode?: StringNullableFilter<"ScheduleAuditLog"> | string | null
    durationMs?: IntNullableFilter<"ScheduleAuditLog"> | number | null
    metadata?: JsonNullableFilter<"ScheduleAuditLog">
    timestamp?: DateTimeFilter<"ScheduleAuditLog"> | Date | string
    retainUntil?: DateTimeFilter<"ScheduleAuditLog"> | Date | string
    schedule?: XOR<ScheduleNullableScalarRelationFilter, ScheduleWhereInput> | null
  }, "id">

  export type ScheduleAuditLogOrderByWithAggregationInput = {
    id?: SortOrder
    scheduleId?: SortOrderInput | SortOrder
    organizationId?: SortOrder
    action?: SortOrder
    resource?: SortOrder
    userId?: SortOrder
    userEmail?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    requestId?: SortOrderInput | SortOrder
    previousValue?: SortOrderInput | SortOrder
    newValue?: SortOrderInput | SortOrder
    changedFields?: SortOrder
    status?: SortOrder
    errorMessage?: SortOrderInput | SortOrder
    errorCode?: SortOrderInput | SortOrder
    durationMs?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    retainUntil?: SortOrder
    _count?: ScheduleAuditLogCountOrderByAggregateInput
    _avg?: ScheduleAuditLogAvgOrderByAggregateInput
    _max?: ScheduleAuditLogMaxOrderByAggregateInput
    _min?: ScheduleAuditLogMinOrderByAggregateInput
    _sum?: ScheduleAuditLogSumOrderByAggregateInput
  }

  export type ScheduleAuditLogScalarWhereWithAggregatesInput = {
    AND?: ScheduleAuditLogScalarWhereWithAggregatesInput | ScheduleAuditLogScalarWhereWithAggregatesInput[]
    OR?: ScheduleAuditLogScalarWhereWithAggregatesInput[]
    NOT?: ScheduleAuditLogScalarWhereWithAggregatesInput | ScheduleAuditLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ScheduleAuditLog"> | string
    scheduleId?: StringNullableWithAggregatesFilter<"ScheduleAuditLog"> | string | null
    organizationId?: StringWithAggregatesFilter<"ScheduleAuditLog"> | string
    action?: StringWithAggregatesFilter<"ScheduleAuditLog"> | string
    resource?: StringWithAggregatesFilter<"ScheduleAuditLog"> | string
    userId?: StringWithAggregatesFilter<"ScheduleAuditLog"> | string
    userEmail?: StringNullableWithAggregatesFilter<"ScheduleAuditLog"> | string | null
    ipAddress?: StringNullableWithAggregatesFilter<"ScheduleAuditLog"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"ScheduleAuditLog"> | string | null
    requestId?: StringNullableWithAggregatesFilter<"ScheduleAuditLog"> | string | null
    previousValue?: JsonNullableWithAggregatesFilter<"ScheduleAuditLog">
    newValue?: JsonNullableWithAggregatesFilter<"ScheduleAuditLog">
    changedFields?: StringNullableListFilter<"ScheduleAuditLog">
    status?: StringWithAggregatesFilter<"ScheduleAuditLog"> | string
    errorMessage?: StringNullableWithAggregatesFilter<"ScheduleAuditLog"> | string | null
    errorCode?: StringNullableWithAggregatesFilter<"ScheduleAuditLog"> | string | null
    durationMs?: IntNullableWithAggregatesFilter<"ScheduleAuditLog"> | number | null
    metadata?: JsonNullableWithAggregatesFilter<"ScheduleAuditLog">
    timestamp?: DateTimeWithAggregatesFilter<"ScheduleAuditLog"> | Date | string
    retainUntil?: DateTimeWithAggregatesFilter<"ScheduleAuditLog"> | Date | string
  }

  export type WorkflowCreateInput = {
    id?: string
    organizationId: string
    name: string
    description?: string | null
    version?: number
    isActive?: boolean
    definition: JsonNullValueInput | InputJsonValue
    eventsCount: number
    estimatedDuration?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    jobs?: JobCreateNestedManyWithoutWorkflowInput
    schedules?: ScheduleCreateNestedManyWithoutWorkflowInput
  }

  export type WorkflowUncheckedCreateInput = {
    id?: string
    organizationId: string
    name: string
    description?: string | null
    version?: number
    isActive?: boolean
    definition: JsonNullValueInput | InputJsonValue
    eventsCount: number
    estimatedDuration?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    jobs?: JobUncheckedCreateNestedManyWithoutWorkflowInput
    schedules?: ScheduleUncheckedCreateNestedManyWithoutWorkflowInput
  }

  export type WorkflowUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    definition?: JsonNullValueInput | InputJsonValue
    eventsCount?: IntFieldUpdateOperationsInput | number
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jobs?: JobUpdateManyWithoutWorkflowNestedInput
    schedules?: ScheduleUpdateManyWithoutWorkflowNestedInput
  }

  export type WorkflowUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    definition?: JsonNullValueInput | InputJsonValue
    eventsCount?: IntFieldUpdateOperationsInput | number
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jobs?: JobUncheckedUpdateManyWithoutWorkflowNestedInput
    schedules?: ScheduleUncheckedUpdateManyWithoutWorkflowNestedInput
  }

  export type WorkflowCreateManyInput = {
    id?: string
    organizationId: string
    name: string
    description?: string | null
    version?: number
    isActive?: boolean
    definition: JsonNullValueInput | InputJsonValue
    eventsCount: number
    estimatedDuration?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type WorkflowUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    definition?: JsonNullValueInput | InputJsonValue
    eventsCount?: IntFieldUpdateOperationsInput | number
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WorkflowUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    definition?: JsonNullValueInput | InputJsonValue
    eventsCount?: IntFieldUpdateOperationsInput | number
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type JobCreateInput = {
    id?: string
    userId: string
    priority?: number
    status?: $Enums.JobStatus
    currentStep?: number
    totalSteps: number
    progressPercent?: number
    estimatedTimeRemaining?: number | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    failedAt?: Date | string | null
    errorCode?: string | null
    errorMessage?: string | null
    isRecoverable?: boolean
    retryCount?: number
    maxRetries?: number
    lastRetryAt?: Date | string | null
    result?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    workflow: WorkflowCreateNestedOneWithoutJobsInput
    executionLogs?: ExecutionLogCreateNestedManyWithoutJobInput
    screenshots?: ExecutionScreenshotCreateNestedManyWithoutJobInput
    scheduleExecution?: ScheduleExecutionCreateNestedOneWithoutJobInput
  }

  export type JobUncheckedCreateInput = {
    id?: string
    workflowId: string
    userId: string
    priority?: number
    status?: $Enums.JobStatus
    currentStep?: number
    totalSteps: number
    progressPercent?: number
    estimatedTimeRemaining?: number | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    failedAt?: Date | string | null
    errorCode?: string | null
    errorMessage?: string | null
    isRecoverable?: boolean
    retryCount?: number
    maxRetries?: number
    lastRetryAt?: Date | string | null
    result?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    executionLogs?: ExecutionLogUncheckedCreateNestedManyWithoutJobInput
    screenshots?: ExecutionScreenshotUncheckedCreateNestedManyWithoutJobInput
    scheduleExecution?: ScheduleExecutionUncheckedCreateNestedOneWithoutJobInput
  }

  export type JobUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
    status?: EnumJobStatusFieldUpdateOperationsInput | $Enums.JobStatus
    currentStep?: IntFieldUpdateOperationsInput | number
    totalSteps?: IntFieldUpdateOperationsInput | number
    progressPercent?: FloatFieldUpdateOperationsInput | number
    estimatedTimeRemaining?: NullableIntFieldUpdateOperationsInput | number | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorCode?: NullableStringFieldUpdateOperationsInput | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    isRecoverable?: BoolFieldUpdateOperationsInput | boolean
    retryCount?: IntFieldUpdateOperationsInput | number
    maxRetries?: IntFieldUpdateOperationsInput | number
    lastRetryAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    result?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    workflow?: WorkflowUpdateOneRequiredWithoutJobsNestedInput
    executionLogs?: ExecutionLogUpdateManyWithoutJobNestedInput
    screenshots?: ExecutionScreenshotUpdateManyWithoutJobNestedInput
    scheduleExecution?: ScheduleExecutionUpdateOneWithoutJobNestedInput
  }

  export type JobUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    workflowId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
    status?: EnumJobStatusFieldUpdateOperationsInput | $Enums.JobStatus
    currentStep?: IntFieldUpdateOperationsInput | number
    totalSteps?: IntFieldUpdateOperationsInput | number
    progressPercent?: FloatFieldUpdateOperationsInput | number
    estimatedTimeRemaining?: NullableIntFieldUpdateOperationsInput | number | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorCode?: NullableStringFieldUpdateOperationsInput | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    isRecoverable?: BoolFieldUpdateOperationsInput | boolean
    retryCount?: IntFieldUpdateOperationsInput | number
    maxRetries?: IntFieldUpdateOperationsInput | number
    lastRetryAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    result?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    executionLogs?: ExecutionLogUncheckedUpdateManyWithoutJobNestedInput
    screenshots?: ExecutionScreenshotUncheckedUpdateManyWithoutJobNestedInput
    scheduleExecution?: ScheduleExecutionUncheckedUpdateOneWithoutJobNestedInput
  }

  export type JobCreateManyInput = {
    id?: string
    workflowId: string
    userId: string
    priority?: number
    status?: $Enums.JobStatus
    currentStep?: number
    totalSteps: number
    progressPercent?: number
    estimatedTimeRemaining?: number | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    failedAt?: Date | string | null
    errorCode?: string | null
    errorMessage?: string | null
    isRecoverable?: boolean
    retryCount?: number
    maxRetries?: number
    lastRetryAt?: Date | string | null
    result?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type JobUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
    status?: EnumJobStatusFieldUpdateOperationsInput | $Enums.JobStatus
    currentStep?: IntFieldUpdateOperationsInput | number
    totalSteps?: IntFieldUpdateOperationsInput | number
    progressPercent?: FloatFieldUpdateOperationsInput | number
    estimatedTimeRemaining?: NullableIntFieldUpdateOperationsInput | number | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorCode?: NullableStringFieldUpdateOperationsInput | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    isRecoverable?: BoolFieldUpdateOperationsInput | boolean
    retryCount?: IntFieldUpdateOperationsInput | number
    maxRetries?: IntFieldUpdateOperationsInput | number
    lastRetryAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    result?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type JobUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    workflowId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
    status?: EnumJobStatusFieldUpdateOperationsInput | $Enums.JobStatus
    currentStep?: IntFieldUpdateOperationsInput | number
    totalSteps?: IntFieldUpdateOperationsInput | number
    progressPercent?: FloatFieldUpdateOperationsInput | number
    estimatedTimeRemaining?: NullableIntFieldUpdateOperationsInput | number | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorCode?: NullableStringFieldUpdateOperationsInput | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    isRecoverable?: BoolFieldUpdateOperationsInput | boolean
    retryCount?: IntFieldUpdateOperationsInput | number
    maxRetries?: IntFieldUpdateOperationsInput | number
    lastRetryAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    result?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ExecutionLogCreateInput = {
    id?: string
    stepIndex: number
    stepName?: string | null
    level: $Enums.LogLevel
    message: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: Date | string
    duration?: number | null
    job: JobCreateNestedOneWithoutExecutionLogsInput
  }

  export type ExecutionLogUncheckedCreateInput = {
    id?: string
    jobId: string
    stepIndex: number
    stepName?: string | null
    level: $Enums.LogLevel
    message: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: Date | string
    duration?: number | null
  }

  export type ExecutionLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    stepIndex?: IntFieldUpdateOperationsInput | number
    stepName?: NullableStringFieldUpdateOperationsInput | string | null
    level?: EnumLogLevelFieldUpdateOperationsInput | $Enums.LogLevel
    message?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    job?: JobUpdateOneRequiredWithoutExecutionLogsNestedInput
  }

  export type ExecutionLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobId?: StringFieldUpdateOperationsInput | string
    stepIndex?: IntFieldUpdateOperationsInput | number
    stepName?: NullableStringFieldUpdateOperationsInput | string | null
    level?: EnumLogLevelFieldUpdateOperationsInput | $Enums.LogLevel
    message?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ExecutionLogCreateManyInput = {
    id?: string
    jobId: string
    stepIndex: number
    stepName?: string | null
    level: $Enums.LogLevel
    message: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: Date | string
    duration?: number | null
  }

  export type ExecutionLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    stepIndex?: IntFieldUpdateOperationsInput | number
    stepName?: NullableStringFieldUpdateOperationsInput | string | null
    level?: EnumLogLevelFieldUpdateOperationsInput | $Enums.LogLevel
    message?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ExecutionLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobId?: StringFieldUpdateOperationsInput | string
    stepIndex?: IntFieldUpdateOperationsInput | number
    stepName?: NullableStringFieldUpdateOperationsInput | string | null
    level?: EnumLogLevelFieldUpdateOperationsInput | $Enums.LogLevel
    message?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ExecutionScreenshotCreateInput = {
    id?: string
    stepIndex: number
    stepName?: string | null
    screenshotType: $Enums.ScreenshotType
    blobUrl: string
    signedUrl?: string | null
    size: number
    width: number
    height: number
    format: string
    isCompressed?: boolean
    originalSize?: number | null
    compressionRatio?: number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    capturedAt?: Date | string
    expiresAt?: Date | string | null
    job: JobCreateNestedOneWithoutScreenshotsInput
  }

  export type ExecutionScreenshotUncheckedCreateInput = {
    id?: string
    jobId: string
    stepIndex: number
    stepName?: string | null
    screenshotType: $Enums.ScreenshotType
    blobUrl: string
    signedUrl?: string | null
    size: number
    width: number
    height: number
    format: string
    isCompressed?: boolean
    originalSize?: number | null
    compressionRatio?: number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    capturedAt?: Date | string
    expiresAt?: Date | string | null
  }

  export type ExecutionScreenshotUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    stepIndex?: IntFieldUpdateOperationsInput | number
    stepName?: NullableStringFieldUpdateOperationsInput | string | null
    screenshotType?: EnumScreenshotTypeFieldUpdateOperationsInput | $Enums.ScreenshotType
    blobUrl?: StringFieldUpdateOperationsInput | string
    signedUrl?: NullableStringFieldUpdateOperationsInput | string | null
    size?: IntFieldUpdateOperationsInput | number
    width?: IntFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    format?: StringFieldUpdateOperationsInput | string
    isCompressed?: BoolFieldUpdateOperationsInput | boolean
    originalSize?: NullableIntFieldUpdateOperationsInput | number | null
    compressionRatio?: NullableFloatFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    capturedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    job?: JobUpdateOneRequiredWithoutScreenshotsNestedInput
  }

  export type ExecutionScreenshotUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobId?: StringFieldUpdateOperationsInput | string
    stepIndex?: IntFieldUpdateOperationsInput | number
    stepName?: NullableStringFieldUpdateOperationsInput | string | null
    screenshotType?: EnumScreenshotTypeFieldUpdateOperationsInput | $Enums.ScreenshotType
    blobUrl?: StringFieldUpdateOperationsInput | string
    signedUrl?: NullableStringFieldUpdateOperationsInput | string | null
    size?: IntFieldUpdateOperationsInput | number
    width?: IntFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    format?: StringFieldUpdateOperationsInput | string
    isCompressed?: BoolFieldUpdateOperationsInput | boolean
    originalSize?: NullableIntFieldUpdateOperationsInput | number | null
    compressionRatio?: NullableFloatFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    capturedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ExecutionScreenshotCreateManyInput = {
    id?: string
    jobId: string
    stepIndex: number
    stepName?: string | null
    screenshotType: $Enums.ScreenshotType
    blobUrl: string
    signedUrl?: string | null
    size: number
    width: number
    height: number
    format: string
    isCompressed?: boolean
    originalSize?: number | null
    compressionRatio?: number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    capturedAt?: Date | string
    expiresAt?: Date | string | null
  }

  export type ExecutionScreenshotUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    stepIndex?: IntFieldUpdateOperationsInput | number
    stepName?: NullableStringFieldUpdateOperationsInput | string | null
    screenshotType?: EnumScreenshotTypeFieldUpdateOperationsInput | $Enums.ScreenshotType
    blobUrl?: StringFieldUpdateOperationsInput | string
    signedUrl?: NullableStringFieldUpdateOperationsInput | string | null
    size?: IntFieldUpdateOperationsInput | number
    width?: IntFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    format?: StringFieldUpdateOperationsInput | string
    isCompressed?: BoolFieldUpdateOperationsInput | boolean
    originalSize?: NullableIntFieldUpdateOperationsInput | number | null
    compressionRatio?: NullableFloatFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    capturedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ExecutionScreenshotUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobId?: StringFieldUpdateOperationsInput | string
    stepIndex?: IntFieldUpdateOperationsInput | number
    stepName?: NullableStringFieldUpdateOperationsInput | string | null
    screenshotType?: EnumScreenshotTypeFieldUpdateOperationsInput | $Enums.ScreenshotType
    blobUrl?: StringFieldUpdateOperationsInput | string
    signedUrl?: NullableStringFieldUpdateOperationsInput | string | null
    size?: IntFieldUpdateOperationsInput | number
    width?: IntFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    format?: StringFieldUpdateOperationsInput | string
    isCompressed?: BoolFieldUpdateOperationsInput | boolean
    originalSize?: NullableIntFieldUpdateOperationsInput | number | null
    compressionRatio?: NullableFloatFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    capturedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CredentialCreateInput = {
    id?: string
    name: string
    description?: string | null
    type: $Enums.CredentialType
    encryptedValue: string
    iv: string
    authTag: string
    keyVaultId?: string | null
    keyVersion?: number
    rotationDays?: number
    lastRotatedAt?: Date | string
    nextRotationAt: Date | string
    lastAccessedAt?: Date | string | null
    accessCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    auditLogs?: CredentialAuditLogCreateNestedManyWithoutCredentialInput
  }

  export type CredentialUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    type: $Enums.CredentialType
    encryptedValue: string
    iv: string
    authTag: string
    keyVaultId?: string | null
    keyVersion?: number
    rotationDays?: number
    lastRotatedAt?: Date | string
    nextRotationAt: Date | string
    lastAccessedAt?: Date | string | null
    accessCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    auditLogs?: CredentialAuditLogUncheckedCreateNestedManyWithoutCredentialInput
  }

  export type CredentialUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumCredentialTypeFieldUpdateOperationsInput | $Enums.CredentialType
    encryptedValue?: StringFieldUpdateOperationsInput | string
    iv?: StringFieldUpdateOperationsInput | string
    authTag?: StringFieldUpdateOperationsInput | string
    keyVaultId?: NullableStringFieldUpdateOperationsInput | string | null
    keyVersion?: IntFieldUpdateOperationsInput | number
    rotationDays?: IntFieldUpdateOperationsInput | number
    lastRotatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nextRotationAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastAccessedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accessCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    auditLogs?: CredentialAuditLogUpdateManyWithoutCredentialNestedInput
  }

  export type CredentialUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumCredentialTypeFieldUpdateOperationsInput | $Enums.CredentialType
    encryptedValue?: StringFieldUpdateOperationsInput | string
    iv?: StringFieldUpdateOperationsInput | string
    authTag?: StringFieldUpdateOperationsInput | string
    keyVaultId?: NullableStringFieldUpdateOperationsInput | string | null
    keyVersion?: IntFieldUpdateOperationsInput | number
    rotationDays?: IntFieldUpdateOperationsInput | number
    lastRotatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nextRotationAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastAccessedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accessCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    auditLogs?: CredentialAuditLogUncheckedUpdateManyWithoutCredentialNestedInput
  }

  export type CredentialCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    type: $Enums.CredentialType
    encryptedValue: string
    iv: string
    authTag: string
    keyVaultId?: string | null
    keyVersion?: number
    rotationDays?: number
    lastRotatedAt?: Date | string
    nextRotationAt: Date | string
    lastAccessedAt?: Date | string | null
    accessCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type CredentialUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumCredentialTypeFieldUpdateOperationsInput | $Enums.CredentialType
    encryptedValue?: StringFieldUpdateOperationsInput | string
    iv?: StringFieldUpdateOperationsInput | string
    authTag?: StringFieldUpdateOperationsInput | string
    keyVaultId?: NullableStringFieldUpdateOperationsInput | string | null
    keyVersion?: IntFieldUpdateOperationsInput | number
    rotationDays?: IntFieldUpdateOperationsInput | number
    lastRotatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nextRotationAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastAccessedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accessCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CredentialUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumCredentialTypeFieldUpdateOperationsInput | $Enums.CredentialType
    encryptedValue?: StringFieldUpdateOperationsInput | string
    iv?: StringFieldUpdateOperationsInput | string
    authTag?: StringFieldUpdateOperationsInput | string
    keyVaultId?: NullableStringFieldUpdateOperationsInput | string | null
    keyVersion?: IntFieldUpdateOperationsInput | number
    rotationDays?: IntFieldUpdateOperationsInput | number
    lastRotatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nextRotationAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastAccessedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accessCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CredentialAuditLogCreateInput = {
    id?: string
    action: $Enums.CredentialAction
    userId?: string | null
    jobId?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    success: boolean
    errorMessage?: string | null
    timestamp?: Date | string
    credential: CredentialCreateNestedOneWithoutAuditLogsInput
  }

  export type CredentialAuditLogUncheckedCreateInput = {
    id?: string
    credentialId: string
    action: $Enums.CredentialAction
    userId?: string | null
    jobId?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    success: boolean
    errorMessage?: string | null
    timestamp?: Date | string
  }

  export type CredentialAuditLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: EnumCredentialActionFieldUpdateOperationsInput | $Enums.CredentialAction
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    jobId?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    success?: BoolFieldUpdateOperationsInput | boolean
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    credential?: CredentialUpdateOneRequiredWithoutAuditLogsNestedInput
  }

  export type CredentialAuditLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    credentialId?: StringFieldUpdateOperationsInput | string
    action?: EnumCredentialActionFieldUpdateOperationsInput | $Enums.CredentialAction
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    jobId?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    success?: BoolFieldUpdateOperationsInput | boolean
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CredentialAuditLogCreateManyInput = {
    id?: string
    credentialId: string
    action: $Enums.CredentialAction
    userId?: string | null
    jobId?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    success: boolean
    errorMessage?: string | null
    timestamp?: Date | string
  }

  export type CredentialAuditLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: EnumCredentialActionFieldUpdateOperationsInput | $Enums.CredentialAction
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    jobId?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    success?: BoolFieldUpdateOperationsInput | boolean
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CredentialAuditLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    credentialId?: StringFieldUpdateOperationsInput | string
    action?: EnumCredentialActionFieldUpdateOperationsInput | $Enums.CredentialAction
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    jobId?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    success?: BoolFieldUpdateOperationsInput | boolean
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WebhookCreateInput = {
    id?: string
    url: string
    secret: string
    events?: WebhookCreateeventsInput | string[]
    isActive?: boolean
    maxRetries?: number
    retryDelay?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    deliveries?: WebhookDeliveryCreateNestedManyWithoutWebhookInput
  }

  export type WebhookUncheckedCreateInput = {
    id?: string
    url: string
    secret: string
    events?: WebhookCreateeventsInput | string[]
    isActive?: boolean
    maxRetries?: number
    retryDelay?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    deliveries?: WebhookDeliveryUncheckedCreateNestedManyWithoutWebhookInput
  }

  export type WebhookUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    secret?: StringFieldUpdateOperationsInput | string
    events?: WebhookUpdateeventsInput | string[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    maxRetries?: IntFieldUpdateOperationsInput | number
    retryDelay?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveries?: WebhookDeliveryUpdateManyWithoutWebhookNestedInput
  }

  export type WebhookUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    secret?: StringFieldUpdateOperationsInput | string
    events?: WebhookUpdateeventsInput | string[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    maxRetries?: IntFieldUpdateOperationsInput | number
    retryDelay?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveries?: WebhookDeliveryUncheckedUpdateManyWithoutWebhookNestedInput
  }

  export type WebhookCreateManyInput = {
    id?: string
    url: string
    secret: string
    events?: WebhookCreateeventsInput | string[]
    isActive?: boolean
    maxRetries?: number
    retryDelay?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type WebhookUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    secret?: StringFieldUpdateOperationsInput | string
    events?: WebhookUpdateeventsInput | string[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    maxRetries?: IntFieldUpdateOperationsInput | number
    retryDelay?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WebhookUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    secret?: StringFieldUpdateOperationsInput | string
    events?: WebhookUpdateeventsInput | string[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    maxRetries?: IntFieldUpdateOperationsInput | number
    retryDelay?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WebhookDeliveryCreateInput = {
    id?: string
    event: string
    payload: JsonNullValueInput | InputJsonValue
    attempt?: number
    statusCode?: number | null
    responseBody?: string | null
    responseTime?: number | null
    success: boolean
    errorMessage?: string | null
    deliveredAt?: Date | string
    nextRetryAt?: Date | string | null
    webhook: WebhookCreateNestedOneWithoutDeliveriesInput
  }

  export type WebhookDeliveryUncheckedCreateInput = {
    id?: string
    webhookId: string
    event: string
    payload: JsonNullValueInput | InputJsonValue
    attempt?: number
    statusCode?: number | null
    responseBody?: string | null
    responseTime?: number | null
    success: boolean
    errorMessage?: string | null
    deliveredAt?: Date | string
    nextRetryAt?: Date | string | null
  }

  export type WebhookDeliveryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    event?: StringFieldUpdateOperationsInput | string
    payload?: JsonNullValueInput | InputJsonValue
    attempt?: IntFieldUpdateOperationsInput | number
    statusCode?: NullableIntFieldUpdateOperationsInput | number | null
    responseBody?: NullableStringFieldUpdateOperationsInput | string | null
    responseTime?: NullableIntFieldUpdateOperationsInput | number | null
    success?: BoolFieldUpdateOperationsInput | boolean
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    deliveredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nextRetryAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    webhook?: WebhookUpdateOneRequiredWithoutDeliveriesNestedInput
  }

  export type WebhookDeliveryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    webhookId?: StringFieldUpdateOperationsInput | string
    event?: StringFieldUpdateOperationsInput | string
    payload?: JsonNullValueInput | InputJsonValue
    attempt?: IntFieldUpdateOperationsInput | number
    statusCode?: NullableIntFieldUpdateOperationsInput | number | null
    responseBody?: NullableStringFieldUpdateOperationsInput | string | null
    responseTime?: NullableIntFieldUpdateOperationsInput | number | null
    success?: BoolFieldUpdateOperationsInput | boolean
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    deliveredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nextRetryAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WebhookDeliveryCreateManyInput = {
    id?: string
    webhookId: string
    event: string
    payload: JsonNullValueInput | InputJsonValue
    attempt?: number
    statusCode?: number | null
    responseBody?: string | null
    responseTime?: number | null
    success: boolean
    errorMessage?: string | null
    deliveredAt?: Date | string
    nextRetryAt?: Date | string | null
  }

  export type WebhookDeliveryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    event?: StringFieldUpdateOperationsInput | string
    payload?: JsonNullValueInput | InputJsonValue
    attempt?: IntFieldUpdateOperationsInput | number
    statusCode?: NullableIntFieldUpdateOperationsInput | number | null
    responseBody?: NullableStringFieldUpdateOperationsInput | string | null
    responseTime?: NullableIntFieldUpdateOperationsInput | number | null
    success?: BoolFieldUpdateOperationsInput | boolean
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    deliveredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nextRetryAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WebhookDeliveryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    webhookId?: StringFieldUpdateOperationsInput | string
    event?: StringFieldUpdateOperationsInput | string
    payload?: JsonNullValueInput | InputJsonValue
    attempt?: IntFieldUpdateOperationsInput | number
    statusCode?: NullableIntFieldUpdateOperationsInput | number | null
    responseBody?: NullableStringFieldUpdateOperationsInput | string | null
    responseTime?: NullableIntFieldUpdateOperationsInput | number | null
    success?: BoolFieldUpdateOperationsInput | boolean
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    deliveredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nextRetryAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ScheduleCreateInput = {
    id?: string
    organizationId: string
    name: string
    description?: string | null
    cronExpression: string
    timezone?: string
    enabled?: boolean
    nextExecutionTime?: Date | string | null
    lastExecutionTime?: Date | string | null
    lastExecutionStatus?: string | null
    eventBridgeRuleArn?: string | null
    eventBridgeRuleName?: string | null
    executionWindow?: NullableJsonNullValueInput | InputJsonValue
    maxConcurrentRuns?: number
    retryPolicy?: NullableJsonNullValueInput | InputJsonValue
    dependencies?: NullableJsonNullValueInput | InputJsonValue
    notificationConfig?: NullableJsonNullValueInput | InputJsonValue
    tags?: ScheduleCreatetagsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    updatedBy?: string | null
    deletedAt?: Date | string | null
    workflow: WorkflowCreateNestedOneWithoutSchedulesInput
    executions?: ScheduleExecutionCreateNestedManyWithoutScheduleInput
    auditLogs?: ScheduleAuditLogCreateNestedManyWithoutScheduleInput
  }

  export type ScheduleUncheckedCreateInput = {
    id?: string
    organizationId: string
    workflowId: string
    name: string
    description?: string | null
    cronExpression: string
    timezone?: string
    enabled?: boolean
    nextExecutionTime?: Date | string | null
    lastExecutionTime?: Date | string | null
    lastExecutionStatus?: string | null
    eventBridgeRuleArn?: string | null
    eventBridgeRuleName?: string | null
    executionWindow?: NullableJsonNullValueInput | InputJsonValue
    maxConcurrentRuns?: number
    retryPolicy?: NullableJsonNullValueInput | InputJsonValue
    dependencies?: NullableJsonNullValueInput | InputJsonValue
    notificationConfig?: NullableJsonNullValueInput | InputJsonValue
    tags?: ScheduleCreatetagsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    updatedBy?: string | null
    deletedAt?: Date | string | null
    executions?: ScheduleExecutionUncheckedCreateNestedManyWithoutScheduleInput
    auditLogs?: ScheduleAuditLogUncheckedCreateNestedManyWithoutScheduleInput
  }

  export type ScheduleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    cronExpression?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    nextExecutionTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastExecutionTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastExecutionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    eventBridgeRuleArn?: NullableStringFieldUpdateOperationsInput | string | null
    eventBridgeRuleName?: NullableStringFieldUpdateOperationsInput | string | null
    executionWindow?: NullableJsonNullValueInput | InputJsonValue
    maxConcurrentRuns?: IntFieldUpdateOperationsInput | number
    retryPolicy?: NullableJsonNullValueInput | InputJsonValue
    dependencies?: NullableJsonNullValueInput | InputJsonValue
    notificationConfig?: NullableJsonNullValueInput | InputJsonValue
    tags?: ScheduleUpdatetagsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    workflow?: WorkflowUpdateOneRequiredWithoutSchedulesNestedInput
    executions?: ScheduleExecutionUpdateManyWithoutScheduleNestedInput
    auditLogs?: ScheduleAuditLogUpdateManyWithoutScheduleNestedInput
  }

  export type ScheduleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    workflowId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    cronExpression?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    nextExecutionTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastExecutionTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastExecutionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    eventBridgeRuleArn?: NullableStringFieldUpdateOperationsInput | string | null
    eventBridgeRuleName?: NullableStringFieldUpdateOperationsInput | string | null
    executionWindow?: NullableJsonNullValueInput | InputJsonValue
    maxConcurrentRuns?: IntFieldUpdateOperationsInput | number
    retryPolicy?: NullableJsonNullValueInput | InputJsonValue
    dependencies?: NullableJsonNullValueInput | InputJsonValue
    notificationConfig?: NullableJsonNullValueInput | InputJsonValue
    tags?: ScheduleUpdatetagsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    executions?: ScheduleExecutionUncheckedUpdateManyWithoutScheduleNestedInput
    auditLogs?: ScheduleAuditLogUncheckedUpdateManyWithoutScheduleNestedInput
  }

  export type ScheduleCreateManyInput = {
    id?: string
    organizationId: string
    workflowId: string
    name: string
    description?: string | null
    cronExpression: string
    timezone?: string
    enabled?: boolean
    nextExecutionTime?: Date | string | null
    lastExecutionTime?: Date | string | null
    lastExecutionStatus?: string | null
    eventBridgeRuleArn?: string | null
    eventBridgeRuleName?: string | null
    executionWindow?: NullableJsonNullValueInput | InputJsonValue
    maxConcurrentRuns?: number
    retryPolicy?: NullableJsonNullValueInput | InputJsonValue
    dependencies?: NullableJsonNullValueInput | InputJsonValue
    notificationConfig?: NullableJsonNullValueInput | InputJsonValue
    tags?: ScheduleCreatetagsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    updatedBy?: string | null
    deletedAt?: Date | string | null
  }

  export type ScheduleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    cronExpression?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    nextExecutionTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastExecutionTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastExecutionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    eventBridgeRuleArn?: NullableStringFieldUpdateOperationsInput | string | null
    eventBridgeRuleName?: NullableStringFieldUpdateOperationsInput | string | null
    executionWindow?: NullableJsonNullValueInput | InputJsonValue
    maxConcurrentRuns?: IntFieldUpdateOperationsInput | number
    retryPolicy?: NullableJsonNullValueInput | InputJsonValue
    dependencies?: NullableJsonNullValueInput | InputJsonValue
    notificationConfig?: NullableJsonNullValueInput | InputJsonValue
    tags?: ScheduleUpdatetagsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ScheduleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    workflowId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    cronExpression?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    nextExecutionTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastExecutionTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastExecutionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    eventBridgeRuleArn?: NullableStringFieldUpdateOperationsInput | string | null
    eventBridgeRuleName?: NullableStringFieldUpdateOperationsInput | string | null
    executionWindow?: NullableJsonNullValueInput | InputJsonValue
    maxConcurrentRuns?: IntFieldUpdateOperationsInput | number
    retryPolicy?: NullableJsonNullValueInput | InputJsonValue
    dependencies?: NullableJsonNullValueInput | InputJsonValue
    notificationConfig?: NullableJsonNullValueInput | InputJsonValue
    tags?: ScheduleUpdatetagsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ScheduleExecutionCreateInput = {
    id?: string
    organizationId: string
    scheduledTime: Date | string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    duration?: number | null
    status: string
    trigger: string
    errorMessage?: string | null
    errorStack?: string | null
    errorCode?: string | null
    attemptNumber?: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    schedule: ScheduleCreateNestedOneWithoutExecutionsInput
    job?: JobCreateNestedOneWithoutScheduleExecutionInput
  }

  export type ScheduleExecutionUncheckedCreateInput = {
    id?: string
    organizationId: string
    scheduleId: string
    jobId?: string | null
    scheduledTime: Date | string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    duration?: number | null
    status: string
    trigger: string
    errorMessage?: string | null
    errorStack?: string | null
    errorCode?: string | null
    attemptNumber?: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ScheduleExecutionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    scheduledTime?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    trigger?: StringFieldUpdateOperationsInput | string
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    errorStack?: NullableStringFieldUpdateOperationsInput | string | null
    errorCode?: NullableStringFieldUpdateOperationsInput | string | null
    attemptNumber?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schedule?: ScheduleUpdateOneRequiredWithoutExecutionsNestedInput
    job?: JobUpdateOneWithoutScheduleExecutionNestedInput
  }

  export type ScheduleExecutionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    scheduleId?: StringFieldUpdateOperationsInput | string
    jobId?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledTime?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    trigger?: StringFieldUpdateOperationsInput | string
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    errorStack?: NullableStringFieldUpdateOperationsInput | string | null
    errorCode?: NullableStringFieldUpdateOperationsInput | string | null
    attemptNumber?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScheduleExecutionCreateManyInput = {
    id?: string
    organizationId: string
    scheduleId: string
    jobId?: string | null
    scheduledTime: Date | string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    duration?: number | null
    status: string
    trigger: string
    errorMessage?: string | null
    errorStack?: string | null
    errorCode?: string | null
    attemptNumber?: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ScheduleExecutionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    scheduledTime?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    trigger?: StringFieldUpdateOperationsInput | string
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    errorStack?: NullableStringFieldUpdateOperationsInput | string | null
    errorCode?: NullableStringFieldUpdateOperationsInput | string | null
    attemptNumber?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScheduleExecutionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    scheduleId?: StringFieldUpdateOperationsInput | string
    jobId?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledTime?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    trigger?: StringFieldUpdateOperationsInput | string
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    errorStack?: NullableStringFieldUpdateOperationsInput | string | null
    errorCode?: NullableStringFieldUpdateOperationsInput | string | null
    attemptNumber?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScheduleAuditLogCreateInput = {
    id?: string
    organizationId: string
    action: string
    resource: string
    userId: string
    userEmail?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    requestId?: string | null
    previousValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    changedFields?: ScheduleAuditLogCreatechangedFieldsInput | string[]
    status: string
    errorMessage?: string | null
    errorCode?: string | null
    durationMs?: number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: Date | string
    retainUntil: Date | string
    schedule?: ScheduleCreateNestedOneWithoutAuditLogsInput
  }

  export type ScheduleAuditLogUncheckedCreateInput = {
    id?: string
    scheduleId?: string | null
    organizationId: string
    action: string
    resource: string
    userId: string
    userEmail?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    requestId?: string | null
    previousValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    changedFields?: ScheduleAuditLogCreatechangedFieldsInput | string[]
    status: string
    errorMessage?: string | null
    errorCode?: string | null
    durationMs?: number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: Date | string
    retainUntil: Date | string
  }

  export type ScheduleAuditLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    resource?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    userEmail?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    requestId?: NullableStringFieldUpdateOperationsInput | string | null
    previousValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    changedFields?: ScheduleAuditLogUpdatechangedFieldsInput | string[]
    status?: StringFieldUpdateOperationsInput | string
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    errorCode?: NullableStringFieldUpdateOperationsInput | string | null
    durationMs?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    retainUntil?: DateTimeFieldUpdateOperationsInput | Date | string
    schedule?: ScheduleUpdateOneWithoutAuditLogsNestedInput
  }

  export type ScheduleAuditLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    scheduleId?: NullableStringFieldUpdateOperationsInput | string | null
    organizationId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    resource?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    userEmail?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    requestId?: NullableStringFieldUpdateOperationsInput | string | null
    previousValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    changedFields?: ScheduleAuditLogUpdatechangedFieldsInput | string[]
    status?: StringFieldUpdateOperationsInput | string
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    errorCode?: NullableStringFieldUpdateOperationsInput | string | null
    durationMs?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    retainUntil?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScheduleAuditLogCreateManyInput = {
    id?: string
    scheduleId?: string | null
    organizationId: string
    action: string
    resource: string
    userId: string
    userEmail?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    requestId?: string | null
    previousValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    changedFields?: ScheduleAuditLogCreatechangedFieldsInput | string[]
    status: string
    errorMessage?: string | null
    errorCode?: string | null
    durationMs?: number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: Date | string
    retainUntil: Date | string
  }

  export type ScheduleAuditLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    resource?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    userEmail?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    requestId?: NullableStringFieldUpdateOperationsInput | string | null
    previousValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    changedFields?: ScheduleAuditLogUpdatechangedFieldsInput | string[]
    status?: StringFieldUpdateOperationsInput | string
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    errorCode?: NullableStringFieldUpdateOperationsInput | string | null
    durationMs?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    retainUntil?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScheduleAuditLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    scheduleId?: NullableStringFieldUpdateOperationsInput | string | null
    organizationId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    resource?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    userEmail?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    requestId?: NullableStringFieldUpdateOperationsInput | string | null
    previousValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    changedFields?: ScheduleAuditLogUpdatechangedFieldsInput | string[]
    status?: StringFieldUpdateOperationsInput | string
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    errorCode?: NullableStringFieldUpdateOperationsInput | string | null
    durationMs?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    retainUntil?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type JobListRelationFilter = {
    every?: JobWhereInput
    some?: JobWhereInput
    none?: JobWhereInput
  }

  export type ScheduleListRelationFilter = {
    every?: ScheduleWhereInput
    some?: ScheduleWhereInput
    none?: ScheduleWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type JobOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ScheduleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WorkflowCountOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    version?: SortOrder
    isActive?: SortOrder
    definition?: SortOrder
    eventsCount?: SortOrder
    estimatedDuration?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type WorkflowAvgOrderByAggregateInput = {
    version?: SortOrder
    eventsCount?: SortOrder
    estimatedDuration?: SortOrder
  }

  export type WorkflowMaxOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    version?: SortOrder
    isActive?: SortOrder
    eventsCount?: SortOrder
    estimatedDuration?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type WorkflowMinOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    version?: SortOrder
    isActive?: SortOrder
    eventsCount?: SortOrder
    estimatedDuration?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type WorkflowSumOrderByAggregateInput = {
    version?: SortOrder
    eventsCount?: SortOrder
    estimatedDuration?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type EnumJobStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.JobStatus | EnumJobStatusFieldRefInput<$PrismaModel>
    in?: $Enums.JobStatus[] | ListEnumJobStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.JobStatus[] | ListEnumJobStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumJobStatusFilter<$PrismaModel> | $Enums.JobStatus
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type WorkflowScalarRelationFilter = {
    is?: WorkflowWhereInput
    isNot?: WorkflowWhereInput
  }

  export type ExecutionLogListRelationFilter = {
    every?: ExecutionLogWhereInput
    some?: ExecutionLogWhereInput
    none?: ExecutionLogWhereInput
  }

  export type ExecutionScreenshotListRelationFilter = {
    every?: ExecutionScreenshotWhereInput
    some?: ExecutionScreenshotWhereInput
    none?: ExecutionScreenshotWhereInput
  }

  export type ScheduleExecutionNullableScalarRelationFilter = {
    is?: ScheduleExecutionWhereInput | null
    isNot?: ScheduleExecutionWhereInput | null
  }

  export type ExecutionLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ExecutionScreenshotOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type JobCountOrderByAggregateInput = {
    id?: SortOrder
    workflowId?: SortOrder
    userId?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    currentStep?: SortOrder
    totalSteps?: SortOrder
    progressPercent?: SortOrder
    estimatedTimeRemaining?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    failedAt?: SortOrder
    errorCode?: SortOrder
    errorMessage?: SortOrder
    isRecoverable?: SortOrder
    retryCount?: SortOrder
    maxRetries?: SortOrder
    lastRetryAt?: SortOrder
    result?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type JobAvgOrderByAggregateInput = {
    priority?: SortOrder
    currentStep?: SortOrder
    totalSteps?: SortOrder
    progressPercent?: SortOrder
    estimatedTimeRemaining?: SortOrder
    retryCount?: SortOrder
    maxRetries?: SortOrder
  }

  export type JobMaxOrderByAggregateInput = {
    id?: SortOrder
    workflowId?: SortOrder
    userId?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    currentStep?: SortOrder
    totalSteps?: SortOrder
    progressPercent?: SortOrder
    estimatedTimeRemaining?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    failedAt?: SortOrder
    errorCode?: SortOrder
    errorMessage?: SortOrder
    isRecoverable?: SortOrder
    retryCount?: SortOrder
    maxRetries?: SortOrder
    lastRetryAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type JobMinOrderByAggregateInput = {
    id?: SortOrder
    workflowId?: SortOrder
    userId?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    currentStep?: SortOrder
    totalSteps?: SortOrder
    progressPercent?: SortOrder
    estimatedTimeRemaining?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    failedAt?: SortOrder
    errorCode?: SortOrder
    errorMessage?: SortOrder
    isRecoverable?: SortOrder
    retryCount?: SortOrder
    maxRetries?: SortOrder
    lastRetryAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type JobSumOrderByAggregateInput = {
    priority?: SortOrder
    currentStep?: SortOrder
    totalSteps?: SortOrder
    progressPercent?: SortOrder
    estimatedTimeRemaining?: SortOrder
    retryCount?: SortOrder
    maxRetries?: SortOrder
  }

  export type EnumJobStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.JobStatus | EnumJobStatusFieldRefInput<$PrismaModel>
    in?: $Enums.JobStatus[] | ListEnumJobStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.JobStatus[] | ListEnumJobStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumJobStatusWithAggregatesFilter<$PrismaModel> | $Enums.JobStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumJobStatusFilter<$PrismaModel>
    _max?: NestedEnumJobStatusFilter<$PrismaModel>
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type EnumLogLevelFilter<$PrismaModel = never> = {
    equals?: $Enums.LogLevel | EnumLogLevelFieldRefInput<$PrismaModel>
    in?: $Enums.LogLevel[] | ListEnumLogLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.LogLevel[] | ListEnumLogLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumLogLevelFilter<$PrismaModel> | $Enums.LogLevel
  }

  export type JobScalarRelationFilter = {
    is?: JobWhereInput
    isNot?: JobWhereInput
  }

  export type ExecutionLogCountOrderByAggregateInput = {
    id?: SortOrder
    jobId?: SortOrder
    stepIndex?: SortOrder
    stepName?: SortOrder
    level?: SortOrder
    message?: SortOrder
    metadata?: SortOrder
    timestamp?: SortOrder
    duration?: SortOrder
  }

  export type ExecutionLogAvgOrderByAggregateInput = {
    stepIndex?: SortOrder
    duration?: SortOrder
  }

  export type ExecutionLogMaxOrderByAggregateInput = {
    id?: SortOrder
    jobId?: SortOrder
    stepIndex?: SortOrder
    stepName?: SortOrder
    level?: SortOrder
    message?: SortOrder
    timestamp?: SortOrder
    duration?: SortOrder
  }

  export type ExecutionLogMinOrderByAggregateInput = {
    id?: SortOrder
    jobId?: SortOrder
    stepIndex?: SortOrder
    stepName?: SortOrder
    level?: SortOrder
    message?: SortOrder
    timestamp?: SortOrder
    duration?: SortOrder
  }

  export type ExecutionLogSumOrderByAggregateInput = {
    stepIndex?: SortOrder
    duration?: SortOrder
  }

  export type EnumLogLevelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LogLevel | EnumLogLevelFieldRefInput<$PrismaModel>
    in?: $Enums.LogLevel[] | ListEnumLogLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.LogLevel[] | ListEnumLogLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumLogLevelWithAggregatesFilter<$PrismaModel> | $Enums.LogLevel
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLogLevelFilter<$PrismaModel>
    _max?: NestedEnumLogLevelFilter<$PrismaModel>
  }

  export type EnumScreenshotTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ScreenshotType | EnumScreenshotTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ScreenshotType[] | ListEnumScreenshotTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ScreenshotType[] | ListEnumScreenshotTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumScreenshotTypeFilter<$PrismaModel> | $Enums.ScreenshotType
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type ExecutionScreenshotCountOrderByAggregateInput = {
    id?: SortOrder
    jobId?: SortOrder
    stepIndex?: SortOrder
    stepName?: SortOrder
    screenshotType?: SortOrder
    blobUrl?: SortOrder
    signedUrl?: SortOrder
    size?: SortOrder
    width?: SortOrder
    height?: SortOrder
    format?: SortOrder
    isCompressed?: SortOrder
    originalSize?: SortOrder
    compressionRatio?: SortOrder
    metadata?: SortOrder
    capturedAt?: SortOrder
    expiresAt?: SortOrder
  }

  export type ExecutionScreenshotAvgOrderByAggregateInput = {
    stepIndex?: SortOrder
    size?: SortOrder
    width?: SortOrder
    height?: SortOrder
    originalSize?: SortOrder
    compressionRatio?: SortOrder
  }

  export type ExecutionScreenshotMaxOrderByAggregateInput = {
    id?: SortOrder
    jobId?: SortOrder
    stepIndex?: SortOrder
    stepName?: SortOrder
    screenshotType?: SortOrder
    blobUrl?: SortOrder
    signedUrl?: SortOrder
    size?: SortOrder
    width?: SortOrder
    height?: SortOrder
    format?: SortOrder
    isCompressed?: SortOrder
    originalSize?: SortOrder
    compressionRatio?: SortOrder
    capturedAt?: SortOrder
    expiresAt?: SortOrder
  }

  export type ExecutionScreenshotMinOrderByAggregateInput = {
    id?: SortOrder
    jobId?: SortOrder
    stepIndex?: SortOrder
    stepName?: SortOrder
    screenshotType?: SortOrder
    blobUrl?: SortOrder
    signedUrl?: SortOrder
    size?: SortOrder
    width?: SortOrder
    height?: SortOrder
    format?: SortOrder
    isCompressed?: SortOrder
    originalSize?: SortOrder
    compressionRatio?: SortOrder
    capturedAt?: SortOrder
    expiresAt?: SortOrder
  }

  export type ExecutionScreenshotSumOrderByAggregateInput = {
    stepIndex?: SortOrder
    size?: SortOrder
    width?: SortOrder
    height?: SortOrder
    originalSize?: SortOrder
    compressionRatio?: SortOrder
  }

  export type EnumScreenshotTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ScreenshotType | EnumScreenshotTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ScreenshotType[] | ListEnumScreenshotTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ScreenshotType[] | ListEnumScreenshotTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumScreenshotTypeWithAggregatesFilter<$PrismaModel> | $Enums.ScreenshotType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumScreenshotTypeFilter<$PrismaModel>
    _max?: NestedEnumScreenshotTypeFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type EnumCredentialTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.CredentialType | EnumCredentialTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CredentialType[] | ListEnumCredentialTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CredentialType[] | ListEnumCredentialTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCredentialTypeFilter<$PrismaModel> | $Enums.CredentialType
  }

  export type CredentialAuditLogListRelationFilter = {
    every?: CredentialAuditLogWhereInput
    some?: CredentialAuditLogWhereInput
    none?: CredentialAuditLogWhereInput
  }

  export type CredentialAuditLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CredentialCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    encryptedValue?: SortOrder
    iv?: SortOrder
    authTag?: SortOrder
    keyVaultId?: SortOrder
    keyVersion?: SortOrder
    rotationDays?: SortOrder
    lastRotatedAt?: SortOrder
    nextRotationAt?: SortOrder
    lastAccessedAt?: SortOrder
    accessCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type CredentialAvgOrderByAggregateInput = {
    keyVersion?: SortOrder
    rotationDays?: SortOrder
    accessCount?: SortOrder
  }

  export type CredentialMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    encryptedValue?: SortOrder
    iv?: SortOrder
    authTag?: SortOrder
    keyVaultId?: SortOrder
    keyVersion?: SortOrder
    rotationDays?: SortOrder
    lastRotatedAt?: SortOrder
    nextRotationAt?: SortOrder
    lastAccessedAt?: SortOrder
    accessCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type CredentialMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    encryptedValue?: SortOrder
    iv?: SortOrder
    authTag?: SortOrder
    keyVaultId?: SortOrder
    keyVersion?: SortOrder
    rotationDays?: SortOrder
    lastRotatedAt?: SortOrder
    nextRotationAt?: SortOrder
    lastAccessedAt?: SortOrder
    accessCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type CredentialSumOrderByAggregateInput = {
    keyVersion?: SortOrder
    rotationDays?: SortOrder
    accessCount?: SortOrder
  }

  export type EnumCredentialTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CredentialType | EnumCredentialTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CredentialType[] | ListEnumCredentialTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CredentialType[] | ListEnumCredentialTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCredentialTypeWithAggregatesFilter<$PrismaModel> | $Enums.CredentialType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCredentialTypeFilter<$PrismaModel>
    _max?: NestedEnumCredentialTypeFilter<$PrismaModel>
  }

  export type EnumCredentialActionFilter<$PrismaModel = never> = {
    equals?: $Enums.CredentialAction | EnumCredentialActionFieldRefInput<$PrismaModel>
    in?: $Enums.CredentialAction[] | ListEnumCredentialActionFieldRefInput<$PrismaModel>
    notIn?: $Enums.CredentialAction[] | ListEnumCredentialActionFieldRefInput<$PrismaModel>
    not?: NestedEnumCredentialActionFilter<$PrismaModel> | $Enums.CredentialAction
  }

  export type CredentialScalarRelationFilter = {
    is?: CredentialWhereInput
    isNot?: CredentialWhereInput
  }

  export type CredentialAuditLogCountOrderByAggregateInput = {
    id?: SortOrder
    credentialId?: SortOrder
    action?: SortOrder
    userId?: SortOrder
    jobId?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    success?: SortOrder
    errorMessage?: SortOrder
    timestamp?: SortOrder
  }

  export type CredentialAuditLogMaxOrderByAggregateInput = {
    id?: SortOrder
    credentialId?: SortOrder
    action?: SortOrder
    userId?: SortOrder
    jobId?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    success?: SortOrder
    errorMessage?: SortOrder
    timestamp?: SortOrder
  }

  export type CredentialAuditLogMinOrderByAggregateInput = {
    id?: SortOrder
    credentialId?: SortOrder
    action?: SortOrder
    userId?: SortOrder
    jobId?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    success?: SortOrder
    errorMessage?: SortOrder
    timestamp?: SortOrder
  }

  export type EnumCredentialActionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CredentialAction | EnumCredentialActionFieldRefInput<$PrismaModel>
    in?: $Enums.CredentialAction[] | ListEnumCredentialActionFieldRefInput<$PrismaModel>
    notIn?: $Enums.CredentialAction[] | ListEnumCredentialActionFieldRefInput<$PrismaModel>
    not?: NestedEnumCredentialActionWithAggregatesFilter<$PrismaModel> | $Enums.CredentialAction
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCredentialActionFilter<$PrismaModel>
    _max?: NestedEnumCredentialActionFilter<$PrismaModel>
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type WebhookDeliveryListRelationFilter = {
    every?: WebhookDeliveryWhereInput
    some?: WebhookDeliveryWhereInput
    none?: WebhookDeliveryWhereInput
  }

  export type WebhookDeliveryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WebhookCountOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    secret?: SortOrder
    events?: SortOrder
    isActive?: SortOrder
    maxRetries?: SortOrder
    retryDelay?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type WebhookAvgOrderByAggregateInput = {
    maxRetries?: SortOrder
    retryDelay?: SortOrder
  }

  export type WebhookMaxOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    secret?: SortOrder
    isActive?: SortOrder
    maxRetries?: SortOrder
    retryDelay?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type WebhookMinOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    secret?: SortOrder
    isActive?: SortOrder
    maxRetries?: SortOrder
    retryDelay?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type WebhookSumOrderByAggregateInput = {
    maxRetries?: SortOrder
    retryDelay?: SortOrder
  }

  export type WebhookScalarRelationFilter = {
    is?: WebhookWhereInput
    isNot?: WebhookWhereInput
  }

  export type WebhookDeliveryCountOrderByAggregateInput = {
    id?: SortOrder
    webhookId?: SortOrder
    event?: SortOrder
    payload?: SortOrder
    attempt?: SortOrder
    statusCode?: SortOrder
    responseBody?: SortOrder
    responseTime?: SortOrder
    success?: SortOrder
    errorMessage?: SortOrder
    deliveredAt?: SortOrder
    nextRetryAt?: SortOrder
  }

  export type WebhookDeliveryAvgOrderByAggregateInput = {
    attempt?: SortOrder
    statusCode?: SortOrder
    responseTime?: SortOrder
  }

  export type WebhookDeliveryMaxOrderByAggregateInput = {
    id?: SortOrder
    webhookId?: SortOrder
    event?: SortOrder
    attempt?: SortOrder
    statusCode?: SortOrder
    responseBody?: SortOrder
    responseTime?: SortOrder
    success?: SortOrder
    errorMessage?: SortOrder
    deliveredAt?: SortOrder
    nextRetryAt?: SortOrder
  }

  export type WebhookDeliveryMinOrderByAggregateInput = {
    id?: SortOrder
    webhookId?: SortOrder
    event?: SortOrder
    attempt?: SortOrder
    statusCode?: SortOrder
    responseBody?: SortOrder
    responseTime?: SortOrder
    success?: SortOrder
    errorMessage?: SortOrder
    deliveredAt?: SortOrder
    nextRetryAt?: SortOrder
  }

  export type WebhookDeliverySumOrderByAggregateInput = {
    attempt?: SortOrder
    statusCode?: SortOrder
    responseTime?: SortOrder
  }

  export type ScheduleExecutionListRelationFilter = {
    every?: ScheduleExecutionWhereInput
    some?: ScheduleExecutionWhereInput
    none?: ScheduleExecutionWhereInput
  }

  export type ScheduleAuditLogListRelationFilter = {
    every?: ScheduleAuditLogWhereInput
    some?: ScheduleAuditLogWhereInput
    none?: ScheduleAuditLogWhereInput
  }

  export type ScheduleExecutionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ScheduleAuditLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ScheduleCountOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    workflowId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    cronExpression?: SortOrder
    timezone?: SortOrder
    enabled?: SortOrder
    nextExecutionTime?: SortOrder
    lastExecutionTime?: SortOrder
    lastExecutionStatus?: SortOrder
    eventBridgeRuleArn?: SortOrder
    eventBridgeRuleName?: SortOrder
    executionWindow?: SortOrder
    maxConcurrentRuns?: SortOrder
    retryPolicy?: SortOrder
    dependencies?: SortOrder
    notificationConfig?: SortOrder
    tags?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
    deletedAt?: SortOrder
  }

  export type ScheduleAvgOrderByAggregateInput = {
    maxConcurrentRuns?: SortOrder
  }

  export type ScheduleMaxOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    workflowId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    cronExpression?: SortOrder
    timezone?: SortOrder
    enabled?: SortOrder
    nextExecutionTime?: SortOrder
    lastExecutionTime?: SortOrder
    lastExecutionStatus?: SortOrder
    eventBridgeRuleArn?: SortOrder
    eventBridgeRuleName?: SortOrder
    maxConcurrentRuns?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
    deletedAt?: SortOrder
  }

  export type ScheduleMinOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    workflowId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    cronExpression?: SortOrder
    timezone?: SortOrder
    enabled?: SortOrder
    nextExecutionTime?: SortOrder
    lastExecutionTime?: SortOrder
    lastExecutionStatus?: SortOrder
    eventBridgeRuleArn?: SortOrder
    eventBridgeRuleName?: SortOrder
    maxConcurrentRuns?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
    deletedAt?: SortOrder
  }

  export type ScheduleSumOrderByAggregateInput = {
    maxConcurrentRuns?: SortOrder
  }

  export type ScheduleScalarRelationFilter = {
    is?: ScheduleWhereInput
    isNot?: ScheduleWhereInput
  }

  export type JobNullableScalarRelationFilter = {
    is?: JobWhereInput | null
    isNot?: JobWhereInput | null
  }

  export type ScheduleExecutionCountOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    scheduleId?: SortOrder
    jobId?: SortOrder
    scheduledTime?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    duration?: SortOrder
    status?: SortOrder
    trigger?: SortOrder
    errorMessage?: SortOrder
    errorStack?: SortOrder
    errorCode?: SortOrder
    attemptNumber?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ScheduleExecutionAvgOrderByAggregateInput = {
    duration?: SortOrder
    attemptNumber?: SortOrder
  }

  export type ScheduleExecutionMaxOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    scheduleId?: SortOrder
    jobId?: SortOrder
    scheduledTime?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    duration?: SortOrder
    status?: SortOrder
    trigger?: SortOrder
    errorMessage?: SortOrder
    errorStack?: SortOrder
    errorCode?: SortOrder
    attemptNumber?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ScheduleExecutionMinOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    scheduleId?: SortOrder
    jobId?: SortOrder
    scheduledTime?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    duration?: SortOrder
    status?: SortOrder
    trigger?: SortOrder
    errorMessage?: SortOrder
    errorStack?: SortOrder
    errorCode?: SortOrder
    attemptNumber?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ScheduleExecutionSumOrderByAggregateInput = {
    duration?: SortOrder
    attemptNumber?: SortOrder
  }

  export type ScheduleNullableScalarRelationFilter = {
    is?: ScheduleWhereInput | null
    isNot?: ScheduleWhereInput | null
  }

  export type ScheduleAuditLogCountOrderByAggregateInput = {
    id?: SortOrder
    scheduleId?: SortOrder
    organizationId?: SortOrder
    action?: SortOrder
    resource?: SortOrder
    userId?: SortOrder
    userEmail?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    requestId?: SortOrder
    previousValue?: SortOrder
    newValue?: SortOrder
    changedFields?: SortOrder
    status?: SortOrder
    errorMessage?: SortOrder
    errorCode?: SortOrder
    durationMs?: SortOrder
    metadata?: SortOrder
    timestamp?: SortOrder
    retainUntil?: SortOrder
  }

  export type ScheduleAuditLogAvgOrderByAggregateInput = {
    durationMs?: SortOrder
  }

  export type ScheduleAuditLogMaxOrderByAggregateInput = {
    id?: SortOrder
    scheduleId?: SortOrder
    organizationId?: SortOrder
    action?: SortOrder
    resource?: SortOrder
    userId?: SortOrder
    userEmail?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    requestId?: SortOrder
    status?: SortOrder
    errorMessage?: SortOrder
    errorCode?: SortOrder
    durationMs?: SortOrder
    timestamp?: SortOrder
    retainUntil?: SortOrder
  }

  export type ScheduleAuditLogMinOrderByAggregateInput = {
    id?: SortOrder
    scheduleId?: SortOrder
    organizationId?: SortOrder
    action?: SortOrder
    resource?: SortOrder
    userId?: SortOrder
    userEmail?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    requestId?: SortOrder
    status?: SortOrder
    errorMessage?: SortOrder
    errorCode?: SortOrder
    durationMs?: SortOrder
    timestamp?: SortOrder
    retainUntil?: SortOrder
  }

  export type ScheduleAuditLogSumOrderByAggregateInput = {
    durationMs?: SortOrder
  }

  export type JobCreateNestedManyWithoutWorkflowInput = {
    create?: XOR<JobCreateWithoutWorkflowInput, JobUncheckedCreateWithoutWorkflowInput> | JobCreateWithoutWorkflowInput[] | JobUncheckedCreateWithoutWorkflowInput[]
    connectOrCreate?: JobCreateOrConnectWithoutWorkflowInput | JobCreateOrConnectWithoutWorkflowInput[]
    createMany?: JobCreateManyWorkflowInputEnvelope
    connect?: JobWhereUniqueInput | JobWhereUniqueInput[]
  }

  export type ScheduleCreateNestedManyWithoutWorkflowInput = {
    create?: XOR<ScheduleCreateWithoutWorkflowInput, ScheduleUncheckedCreateWithoutWorkflowInput> | ScheduleCreateWithoutWorkflowInput[] | ScheduleUncheckedCreateWithoutWorkflowInput[]
    connectOrCreate?: ScheduleCreateOrConnectWithoutWorkflowInput | ScheduleCreateOrConnectWithoutWorkflowInput[]
    createMany?: ScheduleCreateManyWorkflowInputEnvelope
    connect?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
  }

  export type JobUncheckedCreateNestedManyWithoutWorkflowInput = {
    create?: XOR<JobCreateWithoutWorkflowInput, JobUncheckedCreateWithoutWorkflowInput> | JobCreateWithoutWorkflowInput[] | JobUncheckedCreateWithoutWorkflowInput[]
    connectOrCreate?: JobCreateOrConnectWithoutWorkflowInput | JobCreateOrConnectWithoutWorkflowInput[]
    createMany?: JobCreateManyWorkflowInputEnvelope
    connect?: JobWhereUniqueInput | JobWhereUniqueInput[]
  }

  export type ScheduleUncheckedCreateNestedManyWithoutWorkflowInput = {
    create?: XOR<ScheduleCreateWithoutWorkflowInput, ScheduleUncheckedCreateWithoutWorkflowInput> | ScheduleCreateWithoutWorkflowInput[] | ScheduleUncheckedCreateWithoutWorkflowInput[]
    connectOrCreate?: ScheduleCreateOrConnectWithoutWorkflowInput | ScheduleCreateOrConnectWithoutWorkflowInput[]
    createMany?: ScheduleCreateManyWorkflowInputEnvelope
    connect?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type JobUpdateManyWithoutWorkflowNestedInput = {
    create?: XOR<JobCreateWithoutWorkflowInput, JobUncheckedCreateWithoutWorkflowInput> | JobCreateWithoutWorkflowInput[] | JobUncheckedCreateWithoutWorkflowInput[]
    connectOrCreate?: JobCreateOrConnectWithoutWorkflowInput | JobCreateOrConnectWithoutWorkflowInput[]
    upsert?: JobUpsertWithWhereUniqueWithoutWorkflowInput | JobUpsertWithWhereUniqueWithoutWorkflowInput[]
    createMany?: JobCreateManyWorkflowInputEnvelope
    set?: JobWhereUniqueInput | JobWhereUniqueInput[]
    disconnect?: JobWhereUniqueInput | JobWhereUniqueInput[]
    delete?: JobWhereUniqueInput | JobWhereUniqueInput[]
    connect?: JobWhereUniqueInput | JobWhereUniqueInput[]
    update?: JobUpdateWithWhereUniqueWithoutWorkflowInput | JobUpdateWithWhereUniqueWithoutWorkflowInput[]
    updateMany?: JobUpdateManyWithWhereWithoutWorkflowInput | JobUpdateManyWithWhereWithoutWorkflowInput[]
    deleteMany?: JobScalarWhereInput | JobScalarWhereInput[]
  }

  export type ScheduleUpdateManyWithoutWorkflowNestedInput = {
    create?: XOR<ScheduleCreateWithoutWorkflowInput, ScheduleUncheckedCreateWithoutWorkflowInput> | ScheduleCreateWithoutWorkflowInput[] | ScheduleUncheckedCreateWithoutWorkflowInput[]
    connectOrCreate?: ScheduleCreateOrConnectWithoutWorkflowInput | ScheduleCreateOrConnectWithoutWorkflowInput[]
    upsert?: ScheduleUpsertWithWhereUniqueWithoutWorkflowInput | ScheduleUpsertWithWhereUniqueWithoutWorkflowInput[]
    createMany?: ScheduleCreateManyWorkflowInputEnvelope
    set?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
    disconnect?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
    delete?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
    connect?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
    update?: ScheduleUpdateWithWhereUniqueWithoutWorkflowInput | ScheduleUpdateWithWhereUniqueWithoutWorkflowInput[]
    updateMany?: ScheduleUpdateManyWithWhereWithoutWorkflowInput | ScheduleUpdateManyWithWhereWithoutWorkflowInput[]
    deleteMany?: ScheduleScalarWhereInput | ScheduleScalarWhereInput[]
  }

  export type JobUncheckedUpdateManyWithoutWorkflowNestedInput = {
    create?: XOR<JobCreateWithoutWorkflowInput, JobUncheckedCreateWithoutWorkflowInput> | JobCreateWithoutWorkflowInput[] | JobUncheckedCreateWithoutWorkflowInput[]
    connectOrCreate?: JobCreateOrConnectWithoutWorkflowInput | JobCreateOrConnectWithoutWorkflowInput[]
    upsert?: JobUpsertWithWhereUniqueWithoutWorkflowInput | JobUpsertWithWhereUniqueWithoutWorkflowInput[]
    createMany?: JobCreateManyWorkflowInputEnvelope
    set?: JobWhereUniqueInput | JobWhereUniqueInput[]
    disconnect?: JobWhereUniqueInput | JobWhereUniqueInput[]
    delete?: JobWhereUniqueInput | JobWhereUniqueInput[]
    connect?: JobWhereUniqueInput | JobWhereUniqueInput[]
    update?: JobUpdateWithWhereUniqueWithoutWorkflowInput | JobUpdateWithWhereUniqueWithoutWorkflowInput[]
    updateMany?: JobUpdateManyWithWhereWithoutWorkflowInput | JobUpdateManyWithWhereWithoutWorkflowInput[]
    deleteMany?: JobScalarWhereInput | JobScalarWhereInput[]
  }

  export type ScheduleUncheckedUpdateManyWithoutWorkflowNestedInput = {
    create?: XOR<ScheduleCreateWithoutWorkflowInput, ScheduleUncheckedCreateWithoutWorkflowInput> | ScheduleCreateWithoutWorkflowInput[] | ScheduleUncheckedCreateWithoutWorkflowInput[]
    connectOrCreate?: ScheduleCreateOrConnectWithoutWorkflowInput | ScheduleCreateOrConnectWithoutWorkflowInput[]
    upsert?: ScheduleUpsertWithWhereUniqueWithoutWorkflowInput | ScheduleUpsertWithWhereUniqueWithoutWorkflowInput[]
    createMany?: ScheduleCreateManyWorkflowInputEnvelope
    set?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
    disconnect?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
    delete?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
    connect?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
    update?: ScheduleUpdateWithWhereUniqueWithoutWorkflowInput | ScheduleUpdateWithWhereUniqueWithoutWorkflowInput[]
    updateMany?: ScheduleUpdateManyWithWhereWithoutWorkflowInput | ScheduleUpdateManyWithWhereWithoutWorkflowInput[]
    deleteMany?: ScheduleScalarWhereInput | ScheduleScalarWhereInput[]
  }

  export type WorkflowCreateNestedOneWithoutJobsInput = {
    create?: XOR<WorkflowCreateWithoutJobsInput, WorkflowUncheckedCreateWithoutJobsInput>
    connectOrCreate?: WorkflowCreateOrConnectWithoutJobsInput
    connect?: WorkflowWhereUniqueInput
  }

  export type ExecutionLogCreateNestedManyWithoutJobInput = {
    create?: XOR<ExecutionLogCreateWithoutJobInput, ExecutionLogUncheckedCreateWithoutJobInput> | ExecutionLogCreateWithoutJobInput[] | ExecutionLogUncheckedCreateWithoutJobInput[]
    connectOrCreate?: ExecutionLogCreateOrConnectWithoutJobInput | ExecutionLogCreateOrConnectWithoutJobInput[]
    createMany?: ExecutionLogCreateManyJobInputEnvelope
    connect?: ExecutionLogWhereUniqueInput | ExecutionLogWhereUniqueInput[]
  }

  export type ExecutionScreenshotCreateNestedManyWithoutJobInput = {
    create?: XOR<ExecutionScreenshotCreateWithoutJobInput, ExecutionScreenshotUncheckedCreateWithoutJobInput> | ExecutionScreenshotCreateWithoutJobInput[] | ExecutionScreenshotUncheckedCreateWithoutJobInput[]
    connectOrCreate?: ExecutionScreenshotCreateOrConnectWithoutJobInput | ExecutionScreenshotCreateOrConnectWithoutJobInput[]
    createMany?: ExecutionScreenshotCreateManyJobInputEnvelope
    connect?: ExecutionScreenshotWhereUniqueInput | ExecutionScreenshotWhereUniqueInput[]
  }

  export type ScheduleExecutionCreateNestedOneWithoutJobInput = {
    create?: XOR<ScheduleExecutionCreateWithoutJobInput, ScheduleExecutionUncheckedCreateWithoutJobInput>
    connectOrCreate?: ScheduleExecutionCreateOrConnectWithoutJobInput
    connect?: ScheduleExecutionWhereUniqueInput
  }

  export type ExecutionLogUncheckedCreateNestedManyWithoutJobInput = {
    create?: XOR<ExecutionLogCreateWithoutJobInput, ExecutionLogUncheckedCreateWithoutJobInput> | ExecutionLogCreateWithoutJobInput[] | ExecutionLogUncheckedCreateWithoutJobInput[]
    connectOrCreate?: ExecutionLogCreateOrConnectWithoutJobInput | ExecutionLogCreateOrConnectWithoutJobInput[]
    createMany?: ExecutionLogCreateManyJobInputEnvelope
    connect?: ExecutionLogWhereUniqueInput | ExecutionLogWhereUniqueInput[]
  }

  export type ExecutionScreenshotUncheckedCreateNestedManyWithoutJobInput = {
    create?: XOR<ExecutionScreenshotCreateWithoutJobInput, ExecutionScreenshotUncheckedCreateWithoutJobInput> | ExecutionScreenshotCreateWithoutJobInput[] | ExecutionScreenshotUncheckedCreateWithoutJobInput[]
    connectOrCreate?: ExecutionScreenshotCreateOrConnectWithoutJobInput | ExecutionScreenshotCreateOrConnectWithoutJobInput[]
    createMany?: ExecutionScreenshotCreateManyJobInputEnvelope
    connect?: ExecutionScreenshotWhereUniqueInput | ExecutionScreenshotWhereUniqueInput[]
  }

  export type ScheduleExecutionUncheckedCreateNestedOneWithoutJobInput = {
    create?: XOR<ScheduleExecutionCreateWithoutJobInput, ScheduleExecutionUncheckedCreateWithoutJobInput>
    connectOrCreate?: ScheduleExecutionCreateOrConnectWithoutJobInput
    connect?: ScheduleExecutionWhereUniqueInput
  }

  export type EnumJobStatusFieldUpdateOperationsInput = {
    set?: $Enums.JobStatus
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type WorkflowUpdateOneRequiredWithoutJobsNestedInput = {
    create?: XOR<WorkflowCreateWithoutJobsInput, WorkflowUncheckedCreateWithoutJobsInput>
    connectOrCreate?: WorkflowCreateOrConnectWithoutJobsInput
    upsert?: WorkflowUpsertWithoutJobsInput
    connect?: WorkflowWhereUniqueInput
    update?: XOR<XOR<WorkflowUpdateToOneWithWhereWithoutJobsInput, WorkflowUpdateWithoutJobsInput>, WorkflowUncheckedUpdateWithoutJobsInput>
  }

  export type ExecutionLogUpdateManyWithoutJobNestedInput = {
    create?: XOR<ExecutionLogCreateWithoutJobInput, ExecutionLogUncheckedCreateWithoutJobInput> | ExecutionLogCreateWithoutJobInput[] | ExecutionLogUncheckedCreateWithoutJobInput[]
    connectOrCreate?: ExecutionLogCreateOrConnectWithoutJobInput | ExecutionLogCreateOrConnectWithoutJobInput[]
    upsert?: ExecutionLogUpsertWithWhereUniqueWithoutJobInput | ExecutionLogUpsertWithWhereUniqueWithoutJobInput[]
    createMany?: ExecutionLogCreateManyJobInputEnvelope
    set?: ExecutionLogWhereUniqueInput | ExecutionLogWhereUniqueInput[]
    disconnect?: ExecutionLogWhereUniqueInput | ExecutionLogWhereUniqueInput[]
    delete?: ExecutionLogWhereUniqueInput | ExecutionLogWhereUniqueInput[]
    connect?: ExecutionLogWhereUniqueInput | ExecutionLogWhereUniqueInput[]
    update?: ExecutionLogUpdateWithWhereUniqueWithoutJobInput | ExecutionLogUpdateWithWhereUniqueWithoutJobInput[]
    updateMany?: ExecutionLogUpdateManyWithWhereWithoutJobInput | ExecutionLogUpdateManyWithWhereWithoutJobInput[]
    deleteMany?: ExecutionLogScalarWhereInput | ExecutionLogScalarWhereInput[]
  }

  export type ExecutionScreenshotUpdateManyWithoutJobNestedInput = {
    create?: XOR<ExecutionScreenshotCreateWithoutJobInput, ExecutionScreenshotUncheckedCreateWithoutJobInput> | ExecutionScreenshotCreateWithoutJobInput[] | ExecutionScreenshotUncheckedCreateWithoutJobInput[]
    connectOrCreate?: ExecutionScreenshotCreateOrConnectWithoutJobInput | ExecutionScreenshotCreateOrConnectWithoutJobInput[]
    upsert?: ExecutionScreenshotUpsertWithWhereUniqueWithoutJobInput | ExecutionScreenshotUpsertWithWhereUniqueWithoutJobInput[]
    createMany?: ExecutionScreenshotCreateManyJobInputEnvelope
    set?: ExecutionScreenshotWhereUniqueInput | ExecutionScreenshotWhereUniqueInput[]
    disconnect?: ExecutionScreenshotWhereUniqueInput | ExecutionScreenshotWhereUniqueInput[]
    delete?: ExecutionScreenshotWhereUniqueInput | ExecutionScreenshotWhereUniqueInput[]
    connect?: ExecutionScreenshotWhereUniqueInput | ExecutionScreenshotWhereUniqueInput[]
    update?: ExecutionScreenshotUpdateWithWhereUniqueWithoutJobInput | ExecutionScreenshotUpdateWithWhereUniqueWithoutJobInput[]
    updateMany?: ExecutionScreenshotUpdateManyWithWhereWithoutJobInput | ExecutionScreenshotUpdateManyWithWhereWithoutJobInput[]
    deleteMany?: ExecutionScreenshotScalarWhereInput | ExecutionScreenshotScalarWhereInput[]
  }

  export type ScheduleExecutionUpdateOneWithoutJobNestedInput = {
    create?: XOR<ScheduleExecutionCreateWithoutJobInput, ScheduleExecutionUncheckedCreateWithoutJobInput>
    connectOrCreate?: ScheduleExecutionCreateOrConnectWithoutJobInput
    upsert?: ScheduleExecutionUpsertWithoutJobInput
    disconnect?: ScheduleExecutionWhereInput | boolean
    delete?: ScheduleExecutionWhereInput | boolean
    connect?: ScheduleExecutionWhereUniqueInput
    update?: XOR<XOR<ScheduleExecutionUpdateToOneWithWhereWithoutJobInput, ScheduleExecutionUpdateWithoutJobInput>, ScheduleExecutionUncheckedUpdateWithoutJobInput>
  }

  export type ExecutionLogUncheckedUpdateManyWithoutJobNestedInput = {
    create?: XOR<ExecutionLogCreateWithoutJobInput, ExecutionLogUncheckedCreateWithoutJobInput> | ExecutionLogCreateWithoutJobInput[] | ExecutionLogUncheckedCreateWithoutJobInput[]
    connectOrCreate?: ExecutionLogCreateOrConnectWithoutJobInput | ExecutionLogCreateOrConnectWithoutJobInput[]
    upsert?: ExecutionLogUpsertWithWhereUniqueWithoutJobInput | ExecutionLogUpsertWithWhereUniqueWithoutJobInput[]
    createMany?: ExecutionLogCreateManyJobInputEnvelope
    set?: ExecutionLogWhereUniqueInput | ExecutionLogWhereUniqueInput[]
    disconnect?: ExecutionLogWhereUniqueInput | ExecutionLogWhereUniqueInput[]
    delete?: ExecutionLogWhereUniqueInput | ExecutionLogWhereUniqueInput[]
    connect?: ExecutionLogWhereUniqueInput | ExecutionLogWhereUniqueInput[]
    update?: ExecutionLogUpdateWithWhereUniqueWithoutJobInput | ExecutionLogUpdateWithWhereUniqueWithoutJobInput[]
    updateMany?: ExecutionLogUpdateManyWithWhereWithoutJobInput | ExecutionLogUpdateManyWithWhereWithoutJobInput[]
    deleteMany?: ExecutionLogScalarWhereInput | ExecutionLogScalarWhereInput[]
  }

  export type ExecutionScreenshotUncheckedUpdateManyWithoutJobNestedInput = {
    create?: XOR<ExecutionScreenshotCreateWithoutJobInput, ExecutionScreenshotUncheckedCreateWithoutJobInput> | ExecutionScreenshotCreateWithoutJobInput[] | ExecutionScreenshotUncheckedCreateWithoutJobInput[]
    connectOrCreate?: ExecutionScreenshotCreateOrConnectWithoutJobInput | ExecutionScreenshotCreateOrConnectWithoutJobInput[]
    upsert?: ExecutionScreenshotUpsertWithWhereUniqueWithoutJobInput | ExecutionScreenshotUpsertWithWhereUniqueWithoutJobInput[]
    createMany?: ExecutionScreenshotCreateManyJobInputEnvelope
    set?: ExecutionScreenshotWhereUniqueInput | ExecutionScreenshotWhereUniqueInput[]
    disconnect?: ExecutionScreenshotWhereUniqueInput | ExecutionScreenshotWhereUniqueInput[]
    delete?: ExecutionScreenshotWhereUniqueInput | ExecutionScreenshotWhereUniqueInput[]
    connect?: ExecutionScreenshotWhereUniqueInput | ExecutionScreenshotWhereUniqueInput[]
    update?: ExecutionScreenshotUpdateWithWhereUniqueWithoutJobInput | ExecutionScreenshotUpdateWithWhereUniqueWithoutJobInput[]
    updateMany?: ExecutionScreenshotUpdateManyWithWhereWithoutJobInput | ExecutionScreenshotUpdateManyWithWhereWithoutJobInput[]
    deleteMany?: ExecutionScreenshotScalarWhereInput | ExecutionScreenshotScalarWhereInput[]
  }

  export type ScheduleExecutionUncheckedUpdateOneWithoutJobNestedInput = {
    create?: XOR<ScheduleExecutionCreateWithoutJobInput, ScheduleExecutionUncheckedCreateWithoutJobInput>
    connectOrCreate?: ScheduleExecutionCreateOrConnectWithoutJobInput
    upsert?: ScheduleExecutionUpsertWithoutJobInput
    disconnect?: ScheduleExecutionWhereInput | boolean
    delete?: ScheduleExecutionWhereInput | boolean
    connect?: ScheduleExecutionWhereUniqueInput
    update?: XOR<XOR<ScheduleExecutionUpdateToOneWithWhereWithoutJobInput, ScheduleExecutionUpdateWithoutJobInput>, ScheduleExecutionUncheckedUpdateWithoutJobInput>
  }

  export type JobCreateNestedOneWithoutExecutionLogsInput = {
    create?: XOR<JobCreateWithoutExecutionLogsInput, JobUncheckedCreateWithoutExecutionLogsInput>
    connectOrCreate?: JobCreateOrConnectWithoutExecutionLogsInput
    connect?: JobWhereUniqueInput
  }

  export type EnumLogLevelFieldUpdateOperationsInput = {
    set?: $Enums.LogLevel
  }

  export type JobUpdateOneRequiredWithoutExecutionLogsNestedInput = {
    create?: XOR<JobCreateWithoutExecutionLogsInput, JobUncheckedCreateWithoutExecutionLogsInput>
    connectOrCreate?: JobCreateOrConnectWithoutExecutionLogsInput
    upsert?: JobUpsertWithoutExecutionLogsInput
    connect?: JobWhereUniqueInput
    update?: XOR<XOR<JobUpdateToOneWithWhereWithoutExecutionLogsInput, JobUpdateWithoutExecutionLogsInput>, JobUncheckedUpdateWithoutExecutionLogsInput>
  }

  export type JobCreateNestedOneWithoutScreenshotsInput = {
    create?: XOR<JobCreateWithoutScreenshotsInput, JobUncheckedCreateWithoutScreenshotsInput>
    connectOrCreate?: JobCreateOrConnectWithoutScreenshotsInput
    connect?: JobWhereUniqueInput
  }

  export type EnumScreenshotTypeFieldUpdateOperationsInput = {
    set?: $Enums.ScreenshotType
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type JobUpdateOneRequiredWithoutScreenshotsNestedInput = {
    create?: XOR<JobCreateWithoutScreenshotsInput, JobUncheckedCreateWithoutScreenshotsInput>
    connectOrCreate?: JobCreateOrConnectWithoutScreenshotsInput
    upsert?: JobUpsertWithoutScreenshotsInput
    connect?: JobWhereUniqueInput
    update?: XOR<XOR<JobUpdateToOneWithWhereWithoutScreenshotsInput, JobUpdateWithoutScreenshotsInput>, JobUncheckedUpdateWithoutScreenshotsInput>
  }

  export type CredentialAuditLogCreateNestedManyWithoutCredentialInput = {
    create?: XOR<CredentialAuditLogCreateWithoutCredentialInput, CredentialAuditLogUncheckedCreateWithoutCredentialInput> | CredentialAuditLogCreateWithoutCredentialInput[] | CredentialAuditLogUncheckedCreateWithoutCredentialInput[]
    connectOrCreate?: CredentialAuditLogCreateOrConnectWithoutCredentialInput | CredentialAuditLogCreateOrConnectWithoutCredentialInput[]
    createMany?: CredentialAuditLogCreateManyCredentialInputEnvelope
    connect?: CredentialAuditLogWhereUniqueInput | CredentialAuditLogWhereUniqueInput[]
  }

  export type CredentialAuditLogUncheckedCreateNestedManyWithoutCredentialInput = {
    create?: XOR<CredentialAuditLogCreateWithoutCredentialInput, CredentialAuditLogUncheckedCreateWithoutCredentialInput> | CredentialAuditLogCreateWithoutCredentialInput[] | CredentialAuditLogUncheckedCreateWithoutCredentialInput[]
    connectOrCreate?: CredentialAuditLogCreateOrConnectWithoutCredentialInput | CredentialAuditLogCreateOrConnectWithoutCredentialInput[]
    createMany?: CredentialAuditLogCreateManyCredentialInputEnvelope
    connect?: CredentialAuditLogWhereUniqueInput | CredentialAuditLogWhereUniqueInput[]
  }

  export type EnumCredentialTypeFieldUpdateOperationsInput = {
    set?: $Enums.CredentialType
  }

  export type CredentialAuditLogUpdateManyWithoutCredentialNestedInput = {
    create?: XOR<CredentialAuditLogCreateWithoutCredentialInput, CredentialAuditLogUncheckedCreateWithoutCredentialInput> | CredentialAuditLogCreateWithoutCredentialInput[] | CredentialAuditLogUncheckedCreateWithoutCredentialInput[]
    connectOrCreate?: CredentialAuditLogCreateOrConnectWithoutCredentialInput | CredentialAuditLogCreateOrConnectWithoutCredentialInput[]
    upsert?: CredentialAuditLogUpsertWithWhereUniqueWithoutCredentialInput | CredentialAuditLogUpsertWithWhereUniqueWithoutCredentialInput[]
    createMany?: CredentialAuditLogCreateManyCredentialInputEnvelope
    set?: CredentialAuditLogWhereUniqueInput | CredentialAuditLogWhereUniqueInput[]
    disconnect?: CredentialAuditLogWhereUniqueInput | CredentialAuditLogWhereUniqueInput[]
    delete?: CredentialAuditLogWhereUniqueInput | CredentialAuditLogWhereUniqueInput[]
    connect?: CredentialAuditLogWhereUniqueInput | CredentialAuditLogWhereUniqueInput[]
    update?: CredentialAuditLogUpdateWithWhereUniqueWithoutCredentialInput | CredentialAuditLogUpdateWithWhereUniqueWithoutCredentialInput[]
    updateMany?: CredentialAuditLogUpdateManyWithWhereWithoutCredentialInput | CredentialAuditLogUpdateManyWithWhereWithoutCredentialInput[]
    deleteMany?: CredentialAuditLogScalarWhereInput | CredentialAuditLogScalarWhereInput[]
  }

  export type CredentialAuditLogUncheckedUpdateManyWithoutCredentialNestedInput = {
    create?: XOR<CredentialAuditLogCreateWithoutCredentialInput, CredentialAuditLogUncheckedCreateWithoutCredentialInput> | CredentialAuditLogCreateWithoutCredentialInput[] | CredentialAuditLogUncheckedCreateWithoutCredentialInput[]
    connectOrCreate?: CredentialAuditLogCreateOrConnectWithoutCredentialInput | CredentialAuditLogCreateOrConnectWithoutCredentialInput[]
    upsert?: CredentialAuditLogUpsertWithWhereUniqueWithoutCredentialInput | CredentialAuditLogUpsertWithWhereUniqueWithoutCredentialInput[]
    createMany?: CredentialAuditLogCreateManyCredentialInputEnvelope
    set?: CredentialAuditLogWhereUniqueInput | CredentialAuditLogWhereUniqueInput[]
    disconnect?: CredentialAuditLogWhereUniqueInput | CredentialAuditLogWhereUniqueInput[]
    delete?: CredentialAuditLogWhereUniqueInput | CredentialAuditLogWhereUniqueInput[]
    connect?: CredentialAuditLogWhereUniqueInput | CredentialAuditLogWhereUniqueInput[]
    update?: CredentialAuditLogUpdateWithWhereUniqueWithoutCredentialInput | CredentialAuditLogUpdateWithWhereUniqueWithoutCredentialInput[]
    updateMany?: CredentialAuditLogUpdateManyWithWhereWithoutCredentialInput | CredentialAuditLogUpdateManyWithWhereWithoutCredentialInput[]
    deleteMany?: CredentialAuditLogScalarWhereInput | CredentialAuditLogScalarWhereInput[]
  }

  export type CredentialCreateNestedOneWithoutAuditLogsInput = {
    create?: XOR<CredentialCreateWithoutAuditLogsInput, CredentialUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: CredentialCreateOrConnectWithoutAuditLogsInput
    connect?: CredentialWhereUniqueInput
  }

  export type EnumCredentialActionFieldUpdateOperationsInput = {
    set?: $Enums.CredentialAction
  }

  export type CredentialUpdateOneRequiredWithoutAuditLogsNestedInput = {
    create?: XOR<CredentialCreateWithoutAuditLogsInput, CredentialUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: CredentialCreateOrConnectWithoutAuditLogsInput
    upsert?: CredentialUpsertWithoutAuditLogsInput
    connect?: CredentialWhereUniqueInput
    update?: XOR<XOR<CredentialUpdateToOneWithWhereWithoutAuditLogsInput, CredentialUpdateWithoutAuditLogsInput>, CredentialUncheckedUpdateWithoutAuditLogsInput>
  }

  export type WebhookCreateeventsInput = {
    set: string[]
  }

  export type WebhookDeliveryCreateNestedManyWithoutWebhookInput = {
    create?: XOR<WebhookDeliveryCreateWithoutWebhookInput, WebhookDeliveryUncheckedCreateWithoutWebhookInput> | WebhookDeliveryCreateWithoutWebhookInput[] | WebhookDeliveryUncheckedCreateWithoutWebhookInput[]
    connectOrCreate?: WebhookDeliveryCreateOrConnectWithoutWebhookInput | WebhookDeliveryCreateOrConnectWithoutWebhookInput[]
    createMany?: WebhookDeliveryCreateManyWebhookInputEnvelope
    connect?: WebhookDeliveryWhereUniqueInput | WebhookDeliveryWhereUniqueInput[]
  }

  export type WebhookDeliveryUncheckedCreateNestedManyWithoutWebhookInput = {
    create?: XOR<WebhookDeliveryCreateWithoutWebhookInput, WebhookDeliveryUncheckedCreateWithoutWebhookInput> | WebhookDeliveryCreateWithoutWebhookInput[] | WebhookDeliveryUncheckedCreateWithoutWebhookInput[]
    connectOrCreate?: WebhookDeliveryCreateOrConnectWithoutWebhookInput | WebhookDeliveryCreateOrConnectWithoutWebhookInput[]
    createMany?: WebhookDeliveryCreateManyWebhookInputEnvelope
    connect?: WebhookDeliveryWhereUniqueInput | WebhookDeliveryWhereUniqueInput[]
  }

  export type WebhookUpdateeventsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type WebhookDeliveryUpdateManyWithoutWebhookNestedInput = {
    create?: XOR<WebhookDeliveryCreateWithoutWebhookInput, WebhookDeliveryUncheckedCreateWithoutWebhookInput> | WebhookDeliveryCreateWithoutWebhookInput[] | WebhookDeliveryUncheckedCreateWithoutWebhookInput[]
    connectOrCreate?: WebhookDeliveryCreateOrConnectWithoutWebhookInput | WebhookDeliveryCreateOrConnectWithoutWebhookInput[]
    upsert?: WebhookDeliveryUpsertWithWhereUniqueWithoutWebhookInput | WebhookDeliveryUpsertWithWhereUniqueWithoutWebhookInput[]
    createMany?: WebhookDeliveryCreateManyWebhookInputEnvelope
    set?: WebhookDeliveryWhereUniqueInput | WebhookDeliveryWhereUniqueInput[]
    disconnect?: WebhookDeliveryWhereUniqueInput | WebhookDeliveryWhereUniqueInput[]
    delete?: WebhookDeliveryWhereUniqueInput | WebhookDeliveryWhereUniqueInput[]
    connect?: WebhookDeliveryWhereUniqueInput | WebhookDeliveryWhereUniqueInput[]
    update?: WebhookDeliveryUpdateWithWhereUniqueWithoutWebhookInput | WebhookDeliveryUpdateWithWhereUniqueWithoutWebhookInput[]
    updateMany?: WebhookDeliveryUpdateManyWithWhereWithoutWebhookInput | WebhookDeliveryUpdateManyWithWhereWithoutWebhookInput[]
    deleteMany?: WebhookDeliveryScalarWhereInput | WebhookDeliveryScalarWhereInput[]
  }

  export type WebhookDeliveryUncheckedUpdateManyWithoutWebhookNestedInput = {
    create?: XOR<WebhookDeliveryCreateWithoutWebhookInput, WebhookDeliveryUncheckedCreateWithoutWebhookInput> | WebhookDeliveryCreateWithoutWebhookInput[] | WebhookDeliveryUncheckedCreateWithoutWebhookInput[]
    connectOrCreate?: WebhookDeliveryCreateOrConnectWithoutWebhookInput | WebhookDeliveryCreateOrConnectWithoutWebhookInput[]
    upsert?: WebhookDeliveryUpsertWithWhereUniqueWithoutWebhookInput | WebhookDeliveryUpsertWithWhereUniqueWithoutWebhookInput[]
    createMany?: WebhookDeliveryCreateManyWebhookInputEnvelope
    set?: WebhookDeliveryWhereUniqueInput | WebhookDeliveryWhereUniqueInput[]
    disconnect?: WebhookDeliveryWhereUniqueInput | WebhookDeliveryWhereUniqueInput[]
    delete?: WebhookDeliveryWhereUniqueInput | WebhookDeliveryWhereUniqueInput[]
    connect?: WebhookDeliveryWhereUniqueInput | WebhookDeliveryWhereUniqueInput[]
    update?: WebhookDeliveryUpdateWithWhereUniqueWithoutWebhookInput | WebhookDeliveryUpdateWithWhereUniqueWithoutWebhookInput[]
    updateMany?: WebhookDeliveryUpdateManyWithWhereWithoutWebhookInput | WebhookDeliveryUpdateManyWithWhereWithoutWebhookInput[]
    deleteMany?: WebhookDeliveryScalarWhereInput | WebhookDeliveryScalarWhereInput[]
  }

  export type WebhookCreateNestedOneWithoutDeliveriesInput = {
    create?: XOR<WebhookCreateWithoutDeliveriesInput, WebhookUncheckedCreateWithoutDeliveriesInput>
    connectOrCreate?: WebhookCreateOrConnectWithoutDeliveriesInput
    connect?: WebhookWhereUniqueInput
  }

  export type WebhookUpdateOneRequiredWithoutDeliveriesNestedInput = {
    create?: XOR<WebhookCreateWithoutDeliveriesInput, WebhookUncheckedCreateWithoutDeliveriesInput>
    connectOrCreate?: WebhookCreateOrConnectWithoutDeliveriesInput
    upsert?: WebhookUpsertWithoutDeliveriesInput
    connect?: WebhookWhereUniqueInput
    update?: XOR<XOR<WebhookUpdateToOneWithWhereWithoutDeliveriesInput, WebhookUpdateWithoutDeliveriesInput>, WebhookUncheckedUpdateWithoutDeliveriesInput>
  }

  export type ScheduleCreatetagsInput = {
    set: string[]
  }

  export type WorkflowCreateNestedOneWithoutSchedulesInput = {
    create?: XOR<WorkflowCreateWithoutSchedulesInput, WorkflowUncheckedCreateWithoutSchedulesInput>
    connectOrCreate?: WorkflowCreateOrConnectWithoutSchedulesInput
    connect?: WorkflowWhereUniqueInput
  }

  export type ScheduleExecutionCreateNestedManyWithoutScheduleInput = {
    create?: XOR<ScheduleExecutionCreateWithoutScheduleInput, ScheduleExecutionUncheckedCreateWithoutScheduleInput> | ScheduleExecutionCreateWithoutScheduleInput[] | ScheduleExecutionUncheckedCreateWithoutScheduleInput[]
    connectOrCreate?: ScheduleExecutionCreateOrConnectWithoutScheduleInput | ScheduleExecutionCreateOrConnectWithoutScheduleInput[]
    createMany?: ScheduleExecutionCreateManyScheduleInputEnvelope
    connect?: ScheduleExecutionWhereUniqueInput | ScheduleExecutionWhereUniqueInput[]
  }

  export type ScheduleAuditLogCreateNestedManyWithoutScheduleInput = {
    create?: XOR<ScheduleAuditLogCreateWithoutScheduleInput, ScheduleAuditLogUncheckedCreateWithoutScheduleInput> | ScheduleAuditLogCreateWithoutScheduleInput[] | ScheduleAuditLogUncheckedCreateWithoutScheduleInput[]
    connectOrCreate?: ScheduleAuditLogCreateOrConnectWithoutScheduleInput | ScheduleAuditLogCreateOrConnectWithoutScheduleInput[]
    createMany?: ScheduleAuditLogCreateManyScheduleInputEnvelope
    connect?: ScheduleAuditLogWhereUniqueInput | ScheduleAuditLogWhereUniqueInput[]
  }

  export type ScheduleExecutionUncheckedCreateNestedManyWithoutScheduleInput = {
    create?: XOR<ScheduleExecutionCreateWithoutScheduleInput, ScheduleExecutionUncheckedCreateWithoutScheduleInput> | ScheduleExecutionCreateWithoutScheduleInput[] | ScheduleExecutionUncheckedCreateWithoutScheduleInput[]
    connectOrCreate?: ScheduleExecutionCreateOrConnectWithoutScheduleInput | ScheduleExecutionCreateOrConnectWithoutScheduleInput[]
    createMany?: ScheduleExecutionCreateManyScheduleInputEnvelope
    connect?: ScheduleExecutionWhereUniqueInput | ScheduleExecutionWhereUniqueInput[]
  }

  export type ScheduleAuditLogUncheckedCreateNestedManyWithoutScheduleInput = {
    create?: XOR<ScheduleAuditLogCreateWithoutScheduleInput, ScheduleAuditLogUncheckedCreateWithoutScheduleInput> | ScheduleAuditLogCreateWithoutScheduleInput[] | ScheduleAuditLogUncheckedCreateWithoutScheduleInput[]
    connectOrCreate?: ScheduleAuditLogCreateOrConnectWithoutScheduleInput | ScheduleAuditLogCreateOrConnectWithoutScheduleInput[]
    createMany?: ScheduleAuditLogCreateManyScheduleInputEnvelope
    connect?: ScheduleAuditLogWhereUniqueInput | ScheduleAuditLogWhereUniqueInput[]
  }

  export type ScheduleUpdatetagsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type WorkflowUpdateOneRequiredWithoutSchedulesNestedInput = {
    create?: XOR<WorkflowCreateWithoutSchedulesInput, WorkflowUncheckedCreateWithoutSchedulesInput>
    connectOrCreate?: WorkflowCreateOrConnectWithoutSchedulesInput
    upsert?: WorkflowUpsertWithoutSchedulesInput
    connect?: WorkflowWhereUniqueInput
    update?: XOR<XOR<WorkflowUpdateToOneWithWhereWithoutSchedulesInput, WorkflowUpdateWithoutSchedulesInput>, WorkflowUncheckedUpdateWithoutSchedulesInput>
  }

  export type ScheduleExecutionUpdateManyWithoutScheduleNestedInput = {
    create?: XOR<ScheduleExecutionCreateWithoutScheduleInput, ScheduleExecutionUncheckedCreateWithoutScheduleInput> | ScheduleExecutionCreateWithoutScheduleInput[] | ScheduleExecutionUncheckedCreateWithoutScheduleInput[]
    connectOrCreate?: ScheduleExecutionCreateOrConnectWithoutScheduleInput | ScheduleExecutionCreateOrConnectWithoutScheduleInput[]
    upsert?: ScheduleExecutionUpsertWithWhereUniqueWithoutScheduleInput | ScheduleExecutionUpsertWithWhereUniqueWithoutScheduleInput[]
    createMany?: ScheduleExecutionCreateManyScheduleInputEnvelope
    set?: ScheduleExecutionWhereUniqueInput | ScheduleExecutionWhereUniqueInput[]
    disconnect?: ScheduleExecutionWhereUniqueInput | ScheduleExecutionWhereUniqueInput[]
    delete?: ScheduleExecutionWhereUniqueInput | ScheduleExecutionWhereUniqueInput[]
    connect?: ScheduleExecutionWhereUniqueInput | ScheduleExecutionWhereUniqueInput[]
    update?: ScheduleExecutionUpdateWithWhereUniqueWithoutScheduleInput | ScheduleExecutionUpdateWithWhereUniqueWithoutScheduleInput[]
    updateMany?: ScheduleExecutionUpdateManyWithWhereWithoutScheduleInput | ScheduleExecutionUpdateManyWithWhereWithoutScheduleInput[]
    deleteMany?: ScheduleExecutionScalarWhereInput | ScheduleExecutionScalarWhereInput[]
  }

  export type ScheduleAuditLogUpdateManyWithoutScheduleNestedInput = {
    create?: XOR<ScheduleAuditLogCreateWithoutScheduleInput, ScheduleAuditLogUncheckedCreateWithoutScheduleInput> | ScheduleAuditLogCreateWithoutScheduleInput[] | ScheduleAuditLogUncheckedCreateWithoutScheduleInput[]
    connectOrCreate?: ScheduleAuditLogCreateOrConnectWithoutScheduleInput | ScheduleAuditLogCreateOrConnectWithoutScheduleInput[]
    upsert?: ScheduleAuditLogUpsertWithWhereUniqueWithoutScheduleInput | ScheduleAuditLogUpsertWithWhereUniqueWithoutScheduleInput[]
    createMany?: ScheduleAuditLogCreateManyScheduleInputEnvelope
    set?: ScheduleAuditLogWhereUniqueInput | ScheduleAuditLogWhereUniqueInput[]
    disconnect?: ScheduleAuditLogWhereUniqueInput | ScheduleAuditLogWhereUniqueInput[]
    delete?: ScheduleAuditLogWhereUniqueInput | ScheduleAuditLogWhereUniqueInput[]
    connect?: ScheduleAuditLogWhereUniqueInput | ScheduleAuditLogWhereUniqueInput[]
    update?: ScheduleAuditLogUpdateWithWhereUniqueWithoutScheduleInput | ScheduleAuditLogUpdateWithWhereUniqueWithoutScheduleInput[]
    updateMany?: ScheduleAuditLogUpdateManyWithWhereWithoutScheduleInput | ScheduleAuditLogUpdateManyWithWhereWithoutScheduleInput[]
    deleteMany?: ScheduleAuditLogScalarWhereInput | ScheduleAuditLogScalarWhereInput[]
  }

  export type ScheduleExecutionUncheckedUpdateManyWithoutScheduleNestedInput = {
    create?: XOR<ScheduleExecutionCreateWithoutScheduleInput, ScheduleExecutionUncheckedCreateWithoutScheduleInput> | ScheduleExecutionCreateWithoutScheduleInput[] | ScheduleExecutionUncheckedCreateWithoutScheduleInput[]
    connectOrCreate?: ScheduleExecutionCreateOrConnectWithoutScheduleInput | ScheduleExecutionCreateOrConnectWithoutScheduleInput[]
    upsert?: ScheduleExecutionUpsertWithWhereUniqueWithoutScheduleInput | ScheduleExecutionUpsertWithWhereUniqueWithoutScheduleInput[]
    createMany?: ScheduleExecutionCreateManyScheduleInputEnvelope
    set?: ScheduleExecutionWhereUniqueInput | ScheduleExecutionWhereUniqueInput[]
    disconnect?: ScheduleExecutionWhereUniqueInput | ScheduleExecutionWhereUniqueInput[]
    delete?: ScheduleExecutionWhereUniqueInput | ScheduleExecutionWhereUniqueInput[]
    connect?: ScheduleExecutionWhereUniqueInput | ScheduleExecutionWhereUniqueInput[]
    update?: ScheduleExecutionUpdateWithWhereUniqueWithoutScheduleInput | ScheduleExecutionUpdateWithWhereUniqueWithoutScheduleInput[]
    updateMany?: ScheduleExecutionUpdateManyWithWhereWithoutScheduleInput | ScheduleExecutionUpdateManyWithWhereWithoutScheduleInput[]
    deleteMany?: ScheduleExecutionScalarWhereInput | ScheduleExecutionScalarWhereInput[]
  }

  export type ScheduleAuditLogUncheckedUpdateManyWithoutScheduleNestedInput = {
    create?: XOR<ScheduleAuditLogCreateWithoutScheduleInput, ScheduleAuditLogUncheckedCreateWithoutScheduleInput> | ScheduleAuditLogCreateWithoutScheduleInput[] | ScheduleAuditLogUncheckedCreateWithoutScheduleInput[]
    connectOrCreate?: ScheduleAuditLogCreateOrConnectWithoutScheduleInput | ScheduleAuditLogCreateOrConnectWithoutScheduleInput[]
    upsert?: ScheduleAuditLogUpsertWithWhereUniqueWithoutScheduleInput | ScheduleAuditLogUpsertWithWhereUniqueWithoutScheduleInput[]
    createMany?: ScheduleAuditLogCreateManyScheduleInputEnvelope
    set?: ScheduleAuditLogWhereUniqueInput | ScheduleAuditLogWhereUniqueInput[]
    disconnect?: ScheduleAuditLogWhereUniqueInput | ScheduleAuditLogWhereUniqueInput[]
    delete?: ScheduleAuditLogWhereUniqueInput | ScheduleAuditLogWhereUniqueInput[]
    connect?: ScheduleAuditLogWhereUniqueInput | ScheduleAuditLogWhereUniqueInput[]
    update?: ScheduleAuditLogUpdateWithWhereUniqueWithoutScheduleInput | ScheduleAuditLogUpdateWithWhereUniqueWithoutScheduleInput[]
    updateMany?: ScheduleAuditLogUpdateManyWithWhereWithoutScheduleInput | ScheduleAuditLogUpdateManyWithWhereWithoutScheduleInput[]
    deleteMany?: ScheduleAuditLogScalarWhereInput | ScheduleAuditLogScalarWhereInput[]
  }

  export type ScheduleCreateNestedOneWithoutExecutionsInput = {
    create?: XOR<ScheduleCreateWithoutExecutionsInput, ScheduleUncheckedCreateWithoutExecutionsInput>
    connectOrCreate?: ScheduleCreateOrConnectWithoutExecutionsInput
    connect?: ScheduleWhereUniqueInput
  }

  export type JobCreateNestedOneWithoutScheduleExecutionInput = {
    create?: XOR<JobCreateWithoutScheduleExecutionInput, JobUncheckedCreateWithoutScheduleExecutionInput>
    connectOrCreate?: JobCreateOrConnectWithoutScheduleExecutionInput
    connect?: JobWhereUniqueInput
  }

  export type ScheduleUpdateOneRequiredWithoutExecutionsNestedInput = {
    create?: XOR<ScheduleCreateWithoutExecutionsInput, ScheduleUncheckedCreateWithoutExecutionsInput>
    connectOrCreate?: ScheduleCreateOrConnectWithoutExecutionsInput
    upsert?: ScheduleUpsertWithoutExecutionsInput
    connect?: ScheduleWhereUniqueInput
    update?: XOR<XOR<ScheduleUpdateToOneWithWhereWithoutExecutionsInput, ScheduleUpdateWithoutExecutionsInput>, ScheduleUncheckedUpdateWithoutExecutionsInput>
  }

  export type JobUpdateOneWithoutScheduleExecutionNestedInput = {
    create?: XOR<JobCreateWithoutScheduleExecutionInput, JobUncheckedCreateWithoutScheduleExecutionInput>
    connectOrCreate?: JobCreateOrConnectWithoutScheduleExecutionInput
    upsert?: JobUpsertWithoutScheduleExecutionInput
    disconnect?: JobWhereInput | boolean
    delete?: JobWhereInput | boolean
    connect?: JobWhereUniqueInput
    update?: XOR<XOR<JobUpdateToOneWithWhereWithoutScheduleExecutionInput, JobUpdateWithoutScheduleExecutionInput>, JobUncheckedUpdateWithoutScheduleExecutionInput>
  }

  export type ScheduleAuditLogCreatechangedFieldsInput = {
    set: string[]
  }

  export type ScheduleCreateNestedOneWithoutAuditLogsInput = {
    create?: XOR<ScheduleCreateWithoutAuditLogsInput, ScheduleUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: ScheduleCreateOrConnectWithoutAuditLogsInput
    connect?: ScheduleWhereUniqueInput
  }

  export type ScheduleAuditLogUpdatechangedFieldsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type ScheduleUpdateOneWithoutAuditLogsNestedInput = {
    create?: XOR<ScheduleCreateWithoutAuditLogsInput, ScheduleUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: ScheduleCreateOrConnectWithoutAuditLogsInput
    upsert?: ScheduleUpsertWithoutAuditLogsInput
    disconnect?: ScheduleWhereInput | boolean
    delete?: ScheduleWhereInput | boolean
    connect?: ScheduleWhereUniqueInput
    update?: XOR<XOR<ScheduleUpdateToOneWithWhereWithoutAuditLogsInput, ScheduleUpdateWithoutAuditLogsInput>, ScheduleUncheckedUpdateWithoutAuditLogsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumJobStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.JobStatus | EnumJobStatusFieldRefInput<$PrismaModel>
    in?: $Enums.JobStatus[] | ListEnumJobStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.JobStatus[] | ListEnumJobStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumJobStatusFilter<$PrismaModel> | $Enums.JobStatus
  }

  export type NestedEnumJobStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.JobStatus | EnumJobStatusFieldRefInput<$PrismaModel>
    in?: $Enums.JobStatus[] | ListEnumJobStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.JobStatus[] | ListEnumJobStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumJobStatusWithAggregatesFilter<$PrismaModel> | $Enums.JobStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumJobStatusFilter<$PrismaModel>
    _max?: NestedEnumJobStatusFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumLogLevelFilter<$PrismaModel = never> = {
    equals?: $Enums.LogLevel | EnumLogLevelFieldRefInput<$PrismaModel>
    in?: $Enums.LogLevel[] | ListEnumLogLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.LogLevel[] | ListEnumLogLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumLogLevelFilter<$PrismaModel> | $Enums.LogLevel
  }

  export type NestedEnumLogLevelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LogLevel | EnumLogLevelFieldRefInput<$PrismaModel>
    in?: $Enums.LogLevel[] | ListEnumLogLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.LogLevel[] | ListEnumLogLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumLogLevelWithAggregatesFilter<$PrismaModel> | $Enums.LogLevel
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLogLevelFilter<$PrismaModel>
    _max?: NestedEnumLogLevelFilter<$PrismaModel>
  }

  export type NestedEnumScreenshotTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ScreenshotType | EnumScreenshotTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ScreenshotType[] | ListEnumScreenshotTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ScreenshotType[] | ListEnumScreenshotTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumScreenshotTypeFilter<$PrismaModel> | $Enums.ScreenshotType
  }

  export type NestedEnumScreenshotTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ScreenshotType | EnumScreenshotTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ScreenshotType[] | ListEnumScreenshotTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ScreenshotType[] | ListEnumScreenshotTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumScreenshotTypeWithAggregatesFilter<$PrismaModel> | $Enums.ScreenshotType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumScreenshotTypeFilter<$PrismaModel>
    _max?: NestedEnumScreenshotTypeFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedEnumCredentialTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.CredentialType | EnumCredentialTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CredentialType[] | ListEnumCredentialTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CredentialType[] | ListEnumCredentialTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCredentialTypeFilter<$PrismaModel> | $Enums.CredentialType
  }

  export type NestedEnumCredentialTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CredentialType | EnumCredentialTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CredentialType[] | ListEnumCredentialTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CredentialType[] | ListEnumCredentialTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCredentialTypeWithAggregatesFilter<$PrismaModel> | $Enums.CredentialType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCredentialTypeFilter<$PrismaModel>
    _max?: NestedEnumCredentialTypeFilter<$PrismaModel>
  }

  export type NestedEnumCredentialActionFilter<$PrismaModel = never> = {
    equals?: $Enums.CredentialAction | EnumCredentialActionFieldRefInput<$PrismaModel>
    in?: $Enums.CredentialAction[] | ListEnumCredentialActionFieldRefInput<$PrismaModel>
    notIn?: $Enums.CredentialAction[] | ListEnumCredentialActionFieldRefInput<$PrismaModel>
    not?: NestedEnumCredentialActionFilter<$PrismaModel> | $Enums.CredentialAction
  }

  export type NestedEnumCredentialActionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CredentialAction | EnumCredentialActionFieldRefInput<$PrismaModel>
    in?: $Enums.CredentialAction[] | ListEnumCredentialActionFieldRefInput<$PrismaModel>
    notIn?: $Enums.CredentialAction[] | ListEnumCredentialActionFieldRefInput<$PrismaModel>
    not?: NestedEnumCredentialActionWithAggregatesFilter<$PrismaModel> | $Enums.CredentialAction
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCredentialActionFilter<$PrismaModel>
    _max?: NestedEnumCredentialActionFilter<$PrismaModel>
  }

  export type JobCreateWithoutWorkflowInput = {
    id?: string
    userId: string
    priority?: number
    status?: $Enums.JobStatus
    currentStep?: number
    totalSteps: number
    progressPercent?: number
    estimatedTimeRemaining?: number | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    failedAt?: Date | string | null
    errorCode?: string | null
    errorMessage?: string | null
    isRecoverable?: boolean
    retryCount?: number
    maxRetries?: number
    lastRetryAt?: Date | string | null
    result?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    executionLogs?: ExecutionLogCreateNestedManyWithoutJobInput
    screenshots?: ExecutionScreenshotCreateNestedManyWithoutJobInput
    scheduleExecution?: ScheduleExecutionCreateNestedOneWithoutJobInput
  }

  export type JobUncheckedCreateWithoutWorkflowInput = {
    id?: string
    userId: string
    priority?: number
    status?: $Enums.JobStatus
    currentStep?: number
    totalSteps: number
    progressPercent?: number
    estimatedTimeRemaining?: number | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    failedAt?: Date | string | null
    errorCode?: string | null
    errorMessage?: string | null
    isRecoverable?: boolean
    retryCount?: number
    maxRetries?: number
    lastRetryAt?: Date | string | null
    result?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    executionLogs?: ExecutionLogUncheckedCreateNestedManyWithoutJobInput
    screenshots?: ExecutionScreenshotUncheckedCreateNestedManyWithoutJobInput
    scheduleExecution?: ScheduleExecutionUncheckedCreateNestedOneWithoutJobInput
  }

  export type JobCreateOrConnectWithoutWorkflowInput = {
    where: JobWhereUniqueInput
    create: XOR<JobCreateWithoutWorkflowInput, JobUncheckedCreateWithoutWorkflowInput>
  }

  export type JobCreateManyWorkflowInputEnvelope = {
    data: JobCreateManyWorkflowInput | JobCreateManyWorkflowInput[]
    skipDuplicates?: boolean
  }

  export type ScheduleCreateWithoutWorkflowInput = {
    id?: string
    organizationId: string
    name: string
    description?: string | null
    cronExpression: string
    timezone?: string
    enabled?: boolean
    nextExecutionTime?: Date | string | null
    lastExecutionTime?: Date | string | null
    lastExecutionStatus?: string | null
    eventBridgeRuleArn?: string | null
    eventBridgeRuleName?: string | null
    executionWindow?: NullableJsonNullValueInput | InputJsonValue
    maxConcurrentRuns?: number
    retryPolicy?: NullableJsonNullValueInput | InputJsonValue
    dependencies?: NullableJsonNullValueInput | InputJsonValue
    notificationConfig?: NullableJsonNullValueInput | InputJsonValue
    tags?: ScheduleCreatetagsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    updatedBy?: string | null
    deletedAt?: Date | string | null
    executions?: ScheduleExecutionCreateNestedManyWithoutScheduleInput
    auditLogs?: ScheduleAuditLogCreateNestedManyWithoutScheduleInput
  }

  export type ScheduleUncheckedCreateWithoutWorkflowInput = {
    id?: string
    organizationId: string
    name: string
    description?: string | null
    cronExpression: string
    timezone?: string
    enabled?: boolean
    nextExecutionTime?: Date | string | null
    lastExecutionTime?: Date | string | null
    lastExecutionStatus?: string | null
    eventBridgeRuleArn?: string | null
    eventBridgeRuleName?: string | null
    executionWindow?: NullableJsonNullValueInput | InputJsonValue
    maxConcurrentRuns?: number
    retryPolicy?: NullableJsonNullValueInput | InputJsonValue
    dependencies?: NullableJsonNullValueInput | InputJsonValue
    notificationConfig?: NullableJsonNullValueInput | InputJsonValue
    tags?: ScheduleCreatetagsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    updatedBy?: string | null
    deletedAt?: Date | string | null
    executions?: ScheduleExecutionUncheckedCreateNestedManyWithoutScheduleInput
    auditLogs?: ScheduleAuditLogUncheckedCreateNestedManyWithoutScheduleInput
  }

  export type ScheduleCreateOrConnectWithoutWorkflowInput = {
    where: ScheduleWhereUniqueInput
    create: XOR<ScheduleCreateWithoutWorkflowInput, ScheduleUncheckedCreateWithoutWorkflowInput>
  }

  export type ScheduleCreateManyWorkflowInputEnvelope = {
    data: ScheduleCreateManyWorkflowInput | ScheduleCreateManyWorkflowInput[]
    skipDuplicates?: boolean
  }

  export type JobUpsertWithWhereUniqueWithoutWorkflowInput = {
    where: JobWhereUniqueInput
    update: XOR<JobUpdateWithoutWorkflowInput, JobUncheckedUpdateWithoutWorkflowInput>
    create: XOR<JobCreateWithoutWorkflowInput, JobUncheckedCreateWithoutWorkflowInput>
  }

  export type JobUpdateWithWhereUniqueWithoutWorkflowInput = {
    where: JobWhereUniqueInput
    data: XOR<JobUpdateWithoutWorkflowInput, JobUncheckedUpdateWithoutWorkflowInput>
  }

  export type JobUpdateManyWithWhereWithoutWorkflowInput = {
    where: JobScalarWhereInput
    data: XOR<JobUpdateManyMutationInput, JobUncheckedUpdateManyWithoutWorkflowInput>
  }

  export type JobScalarWhereInput = {
    AND?: JobScalarWhereInput | JobScalarWhereInput[]
    OR?: JobScalarWhereInput[]
    NOT?: JobScalarWhereInput | JobScalarWhereInput[]
    id?: StringFilter<"Job"> | string
    workflowId?: StringFilter<"Job"> | string
    userId?: StringFilter<"Job"> | string
    priority?: IntFilter<"Job"> | number
    status?: EnumJobStatusFilter<"Job"> | $Enums.JobStatus
    currentStep?: IntFilter<"Job"> | number
    totalSteps?: IntFilter<"Job"> | number
    progressPercent?: FloatFilter<"Job"> | number
    estimatedTimeRemaining?: IntNullableFilter<"Job"> | number | null
    startedAt?: DateTimeNullableFilter<"Job"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"Job"> | Date | string | null
    failedAt?: DateTimeNullableFilter<"Job"> | Date | string | null
    errorCode?: StringNullableFilter<"Job"> | string | null
    errorMessage?: StringNullableFilter<"Job"> | string | null
    isRecoverable?: BoolFilter<"Job"> | boolean
    retryCount?: IntFilter<"Job"> | number
    maxRetries?: IntFilter<"Job"> | number
    lastRetryAt?: DateTimeNullableFilter<"Job"> | Date | string | null
    result?: JsonNullableFilter<"Job">
    createdAt?: DateTimeFilter<"Job"> | Date | string
    updatedAt?: DateTimeFilter<"Job"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Job"> | Date | string | null
  }

  export type ScheduleUpsertWithWhereUniqueWithoutWorkflowInput = {
    where: ScheduleWhereUniqueInput
    update: XOR<ScheduleUpdateWithoutWorkflowInput, ScheduleUncheckedUpdateWithoutWorkflowInput>
    create: XOR<ScheduleCreateWithoutWorkflowInput, ScheduleUncheckedCreateWithoutWorkflowInput>
  }

  export type ScheduleUpdateWithWhereUniqueWithoutWorkflowInput = {
    where: ScheduleWhereUniqueInput
    data: XOR<ScheduleUpdateWithoutWorkflowInput, ScheduleUncheckedUpdateWithoutWorkflowInput>
  }

  export type ScheduleUpdateManyWithWhereWithoutWorkflowInput = {
    where: ScheduleScalarWhereInput
    data: XOR<ScheduleUpdateManyMutationInput, ScheduleUncheckedUpdateManyWithoutWorkflowInput>
  }

  export type ScheduleScalarWhereInput = {
    AND?: ScheduleScalarWhereInput | ScheduleScalarWhereInput[]
    OR?: ScheduleScalarWhereInput[]
    NOT?: ScheduleScalarWhereInput | ScheduleScalarWhereInput[]
    id?: StringFilter<"Schedule"> | string
    organizationId?: StringFilter<"Schedule"> | string
    workflowId?: StringFilter<"Schedule"> | string
    name?: StringFilter<"Schedule"> | string
    description?: StringNullableFilter<"Schedule"> | string | null
    cronExpression?: StringFilter<"Schedule"> | string
    timezone?: StringFilter<"Schedule"> | string
    enabled?: BoolFilter<"Schedule"> | boolean
    nextExecutionTime?: DateTimeNullableFilter<"Schedule"> | Date | string | null
    lastExecutionTime?: DateTimeNullableFilter<"Schedule"> | Date | string | null
    lastExecutionStatus?: StringNullableFilter<"Schedule"> | string | null
    eventBridgeRuleArn?: StringNullableFilter<"Schedule"> | string | null
    eventBridgeRuleName?: StringNullableFilter<"Schedule"> | string | null
    executionWindow?: JsonNullableFilter<"Schedule">
    maxConcurrentRuns?: IntFilter<"Schedule"> | number
    retryPolicy?: JsonNullableFilter<"Schedule">
    dependencies?: JsonNullableFilter<"Schedule">
    notificationConfig?: JsonNullableFilter<"Schedule">
    tags?: StringNullableListFilter<"Schedule">
    metadata?: JsonNullableFilter<"Schedule">
    createdAt?: DateTimeFilter<"Schedule"> | Date | string
    updatedAt?: DateTimeFilter<"Schedule"> | Date | string
    createdBy?: StringFilter<"Schedule"> | string
    updatedBy?: StringNullableFilter<"Schedule"> | string | null
    deletedAt?: DateTimeNullableFilter<"Schedule"> | Date | string | null
  }

  export type WorkflowCreateWithoutJobsInput = {
    id?: string
    organizationId: string
    name: string
    description?: string | null
    version?: number
    isActive?: boolean
    definition: JsonNullValueInput | InputJsonValue
    eventsCount: number
    estimatedDuration?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    schedules?: ScheduleCreateNestedManyWithoutWorkflowInput
  }

  export type WorkflowUncheckedCreateWithoutJobsInput = {
    id?: string
    organizationId: string
    name: string
    description?: string | null
    version?: number
    isActive?: boolean
    definition: JsonNullValueInput | InputJsonValue
    eventsCount: number
    estimatedDuration?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    schedules?: ScheduleUncheckedCreateNestedManyWithoutWorkflowInput
  }

  export type WorkflowCreateOrConnectWithoutJobsInput = {
    where: WorkflowWhereUniqueInput
    create: XOR<WorkflowCreateWithoutJobsInput, WorkflowUncheckedCreateWithoutJobsInput>
  }

  export type ExecutionLogCreateWithoutJobInput = {
    id?: string
    stepIndex: number
    stepName?: string | null
    level: $Enums.LogLevel
    message: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: Date | string
    duration?: number | null
  }

  export type ExecutionLogUncheckedCreateWithoutJobInput = {
    id?: string
    stepIndex: number
    stepName?: string | null
    level: $Enums.LogLevel
    message: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: Date | string
    duration?: number | null
  }

  export type ExecutionLogCreateOrConnectWithoutJobInput = {
    where: ExecutionLogWhereUniqueInput
    create: XOR<ExecutionLogCreateWithoutJobInput, ExecutionLogUncheckedCreateWithoutJobInput>
  }

  export type ExecutionLogCreateManyJobInputEnvelope = {
    data: ExecutionLogCreateManyJobInput | ExecutionLogCreateManyJobInput[]
    skipDuplicates?: boolean
  }

  export type ExecutionScreenshotCreateWithoutJobInput = {
    id?: string
    stepIndex: number
    stepName?: string | null
    screenshotType: $Enums.ScreenshotType
    blobUrl: string
    signedUrl?: string | null
    size: number
    width: number
    height: number
    format: string
    isCompressed?: boolean
    originalSize?: number | null
    compressionRatio?: number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    capturedAt?: Date | string
    expiresAt?: Date | string | null
  }

  export type ExecutionScreenshotUncheckedCreateWithoutJobInput = {
    id?: string
    stepIndex: number
    stepName?: string | null
    screenshotType: $Enums.ScreenshotType
    blobUrl: string
    signedUrl?: string | null
    size: number
    width: number
    height: number
    format: string
    isCompressed?: boolean
    originalSize?: number | null
    compressionRatio?: number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    capturedAt?: Date | string
    expiresAt?: Date | string | null
  }

  export type ExecutionScreenshotCreateOrConnectWithoutJobInput = {
    where: ExecutionScreenshotWhereUniqueInput
    create: XOR<ExecutionScreenshotCreateWithoutJobInput, ExecutionScreenshotUncheckedCreateWithoutJobInput>
  }

  export type ExecutionScreenshotCreateManyJobInputEnvelope = {
    data: ExecutionScreenshotCreateManyJobInput | ExecutionScreenshotCreateManyJobInput[]
    skipDuplicates?: boolean
  }

  export type ScheduleExecutionCreateWithoutJobInput = {
    id?: string
    organizationId: string
    scheduledTime: Date | string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    duration?: number | null
    status: string
    trigger: string
    errorMessage?: string | null
    errorStack?: string | null
    errorCode?: string | null
    attemptNumber?: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    schedule: ScheduleCreateNestedOneWithoutExecutionsInput
  }

  export type ScheduleExecutionUncheckedCreateWithoutJobInput = {
    id?: string
    organizationId: string
    scheduleId: string
    scheduledTime: Date | string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    duration?: number | null
    status: string
    trigger: string
    errorMessage?: string | null
    errorStack?: string | null
    errorCode?: string | null
    attemptNumber?: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ScheduleExecutionCreateOrConnectWithoutJobInput = {
    where: ScheduleExecutionWhereUniqueInput
    create: XOR<ScheduleExecutionCreateWithoutJobInput, ScheduleExecutionUncheckedCreateWithoutJobInput>
  }

  export type WorkflowUpsertWithoutJobsInput = {
    update: XOR<WorkflowUpdateWithoutJobsInput, WorkflowUncheckedUpdateWithoutJobsInput>
    create: XOR<WorkflowCreateWithoutJobsInput, WorkflowUncheckedCreateWithoutJobsInput>
    where?: WorkflowWhereInput
  }

  export type WorkflowUpdateToOneWithWhereWithoutJobsInput = {
    where?: WorkflowWhereInput
    data: XOR<WorkflowUpdateWithoutJobsInput, WorkflowUncheckedUpdateWithoutJobsInput>
  }

  export type WorkflowUpdateWithoutJobsInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    definition?: JsonNullValueInput | InputJsonValue
    eventsCount?: IntFieldUpdateOperationsInput | number
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    schedules?: ScheduleUpdateManyWithoutWorkflowNestedInput
  }

  export type WorkflowUncheckedUpdateWithoutJobsInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    definition?: JsonNullValueInput | InputJsonValue
    eventsCount?: IntFieldUpdateOperationsInput | number
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    schedules?: ScheduleUncheckedUpdateManyWithoutWorkflowNestedInput
  }

  export type ExecutionLogUpsertWithWhereUniqueWithoutJobInput = {
    where: ExecutionLogWhereUniqueInput
    update: XOR<ExecutionLogUpdateWithoutJobInput, ExecutionLogUncheckedUpdateWithoutJobInput>
    create: XOR<ExecutionLogCreateWithoutJobInput, ExecutionLogUncheckedCreateWithoutJobInput>
  }

  export type ExecutionLogUpdateWithWhereUniqueWithoutJobInput = {
    where: ExecutionLogWhereUniqueInput
    data: XOR<ExecutionLogUpdateWithoutJobInput, ExecutionLogUncheckedUpdateWithoutJobInput>
  }

  export type ExecutionLogUpdateManyWithWhereWithoutJobInput = {
    where: ExecutionLogScalarWhereInput
    data: XOR<ExecutionLogUpdateManyMutationInput, ExecutionLogUncheckedUpdateManyWithoutJobInput>
  }

  export type ExecutionLogScalarWhereInput = {
    AND?: ExecutionLogScalarWhereInput | ExecutionLogScalarWhereInput[]
    OR?: ExecutionLogScalarWhereInput[]
    NOT?: ExecutionLogScalarWhereInput | ExecutionLogScalarWhereInput[]
    id?: StringFilter<"ExecutionLog"> | string
    jobId?: StringFilter<"ExecutionLog"> | string
    stepIndex?: IntFilter<"ExecutionLog"> | number
    stepName?: StringNullableFilter<"ExecutionLog"> | string | null
    level?: EnumLogLevelFilter<"ExecutionLog"> | $Enums.LogLevel
    message?: StringFilter<"ExecutionLog"> | string
    metadata?: JsonNullableFilter<"ExecutionLog">
    timestamp?: DateTimeFilter<"ExecutionLog"> | Date | string
    duration?: IntNullableFilter<"ExecutionLog"> | number | null
  }

  export type ExecutionScreenshotUpsertWithWhereUniqueWithoutJobInput = {
    where: ExecutionScreenshotWhereUniqueInput
    update: XOR<ExecutionScreenshotUpdateWithoutJobInput, ExecutionScreenshotUncheckedUpdateWithoutJobInput>
    create: XOR<ExecutionScreenshotCreateWithoutJobInput, ExecutionScreenshotUncheckedCreateWithoutJobInput>
  }

  export type ExecutionScreenshotUpdateWithWhereUniqueWithoutJobInput = {
    where: ExecutionScreenshotWhereUniqueInput
    data: XOR<ExecutionScreenshotUpdateWithoutJobInput, ExecutionScreenshotUncheckedUpdateWithoutJobInput>
  }

  export type ExecutionScreenshotUpdateManyWithWhereWithoutJobInput = {
    where: ExecutionScreenshotScalarWhereInput
    data: XOR<ExecutionScreenshotUpdateManyMutationInput, ExecutionScreenshotUncheckedUpdateManyWithoutJobInput>
  }

  export type ExecutionScreenshotScalarWhereInput = {
    AND?: ExecutionScreenshotScalarWhereInput | ExecutionScreenshotScalarWhereInput[]
    OR?: ExecutionScreenshotScalarWhereInput[]
    NOT?: ExecutionScreenshotScalarWhereInput | ExecutionScreenshotScalarWhereInput[]
    id?: StringFilter<"ExecutionScreenshot"> | string
    jobId?: StringFilter<"ExecutionScreenshot"> | string
    stepIndex?: IntFilter<"ExecutionScreenshot"> | number
    stepName?: StringNullableFilter<"ExecutionScreenshot"> | string | null
    screenshotType?: EnumScreenshotTypeFilter<"ExecutionScreenshot"> | $Enums.ScreenshotType
    blobUrl?: StringFilter<"ExecutionScreenshot"> | string
    signedUrl?: StringNullableFilter<"ExecutionScreenshot"> | string | null
    size?: IntFilter<"ExecutionScreenshot"> | number
    width?: IntFilter<"ExecutionScreenshot"> | number
    height?: IntFilter<"ExecutionScreenshot"> | number
    format?: StringFilter<"ExecutionScreenshot"> | string
    isCompressed?: BoolFilter<"ExecutionScreenshot"> | boolean
    originalSize?: IntNullableFilter<"ExecutionScreenshot"> | number | null
    compressionRatio?: FloatNullableFilter<"ExecutionScreenshot"> | number | null
    metadata?: JsonNullableFilter<"ExecutionScreenshot">
    capturedAt?: DateTimeFilter<"ExecutionScreenshot"> | Date | string
    expiresAt?: DateTimeNullableFilter<"ExecutionScreenshot"> | Date | string | null
  }

  export type ScheduleExecutionUpsertWithoutJobInput = {
    update: XOR<ScheduleExecutionUpdateWithoutJobInput, ScheduleExecutionUncheckedUpdateWithoutJobInput>
    create: XOR<ScheduleExecutionCreateWithoutJobInput, ScheduleExecutionUncheckedCreateWithoutJobInput>
    where?: ScheduleExecutionWhereInput
  }

  export type ScheduleExecutionUpdateToOneWithWhereWithoutJobInput = {
    where?: ScheduleExecutionWhereInput
    data: XOR<ScheduleExecutionUpdateWithoutJobInput, ScheduleExecutionUncheckedUpdateWithoutJobInput>
  }

  export type ScheduleExecutionUpdateWithoutJobInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    scheduledTime?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    trigger?: StringFieldUpdateOperationsInput | string
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    errorStack?: NullableStringFieldUpdateOperationsInput | string | null
    errorCode?: NullableStringFieldUpdateOperationsInput | string | null
    attemptNumber?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schedule?: ScheduleUpdateOneRequiredWithoutExecutionsNestedInput
  }

  export type ScheduleExecutionUncheckedUpdateWithoutJobInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    scheduleId?: StringFieldUpdateOperationsInput | string
    scheduledTime?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    trigger?: StringFieldUpdateOperationsInput | string
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    errorStack?: NullableStringFieldUpdateOperationsInput | string | null
    errorCode?: NullableStringFieldUpdateOperationsInput | string | null
    attemptNumber?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JobCreateWithoutExecutionLogsInput = {
    id?: string
    userId: string
    priority?: number
    status?: $Enums.JobStatus
    currentStep?: number
    totalSteps: number
    progressPercent?: number
    estimatedTimeRemaining?: number | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    failedAt?: Date | string | null
    errorCode?: string | null
    errorMessage?: string | null
    isRecoverable?: boolean
    retryCount?: number
    maxRetries?: number
    lastRetryAt?: Date | string | null
    result?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    workflow: WorkflowCreateNestedOneWithoutJobsInput
    screenshots?: ExecutionScreenshotCreateNestedManyWithoutJobInput
    scheduleExecution?: ScheduleExecutionCreateNestedOneWithoutJobInput
  }

  export type JobUncheckedCreateWithoutExecutionLogsInput = {
    id?: string
    workflowId: string
    userId: string
    priority?: number
    status?: $Enums.JobStatus
    currentStep?: number
    totalSteps: number
    progressPercent?: number
    estimatedTimeRemaining?: number | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    failedAt?: Date | string | null
    errorCode?: string | null
    errorMessage?: string | null
    isRecoverable?: boolean
    retryCount?: number
    maxRetries?: number
    lastRetryAt?: Date | string | null
    result?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    screenshots?: ExecutionScreenshotUncheckedCreateNestedManyWithoutJobInput
    scheduleExecution?: ScheduleExecutionUncheckedCreateNestedOneWithoutJobInput
  }

  export type JobCreateOrConnectWithoutExecutionLogsInput = {
    where: JobWhereUniqueInput
    create: XOR<JobCreateWithoutExecutionLogsInput, JobUncheckedCreateWithoutExecutionLogsInput>
  }

  export type JobUpsertWithoutExecutionLogsInput = {
    update: XOR<JobUpdateWithoutExecutionLogsInput, JobUncheckedUpdateWithoutExecutionLogsInput>
    create: XOR<JobCreateWithoutExecutionLogsInput, JobUncheckedCreateWithoutExecutionLogsInput>
    where?: JobWhereInput
  }

  export type JobUpdateToOneWithWhereWithoutExecutionLogsInput = {
    where?: JobWhereInput
    data: XOR<JobUpdateWithoutExecutionLogsInput, JobUncheckedUpdateWithoutExecutionLogsInput>
  }

  export type JobUpdateWithoutExecutionLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
    status?: EnumJobStatusFieldUpdateOperationsInput | $Enums.JobStatus
    currentStep?: IntFieldUpdateOperationsInput | number
    totalSteps?: IntFieldUpdateOperationsInput | number
    progressPercent?: FloatFieldUpdateOperationsInput | number
    estimatedTimeRemaining?: NullableIntFieldUpdateOperationsInput | number | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorCode?: NullableStringFieldUpdateOperationsInput | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    isRecoverable?: BoolFieldUpdateOperationsInput | boolean
    retryCount?: IntFieldUpdateOperationsInput | number
    maxRetries?: IntFieldUpdateOperationsInput | number
    lastRetryAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    result?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    workflow?: WorkflowUpdateOneRequiredWithoutJobsNestedInput
    screenshots?: ExecutionScreenshotUpdateManyWithoutJobNestedInput
    scheduleExecution?: ScheduleExecutionUpdateOneWithoutJobNestedInput
  }

  export type JobUncheckedUpdateWithoutExecutionLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    workflowId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
    status?: EnumJobStatusFieldUpdateOperationsInput | $Enums.JobStatus
    currentStep?: IntFieldUpdateOperationsInput | number
    totalSteps?: IntFieldUpdateOperationsInput | number
    progressPercent?: FloatFieldUpdateOperationsInput | number
    estimatedTimeRemaining?: NullableIntFieldUpdateOperationsInput | number | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorCode?: NullableStringFieldUpdateOperationsInput | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    isRecoverable?: BoolFieldUpdateOperationsInput | boolean
    retryCount?: IntFieldUpdateOperationsInput | number
    maxRetries?: IntFieldUpdateOperationsInput | number
    lastRetryAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    result?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    screenshots?: ExecutionScreenshotUncheckedUpdateManyWithoutJobNestedInput
    scheduleExecution?: ScheduleExecutionUncheckedUpdateOneWithoutJobNestedInput
  }

  export type JobCreateWithoutScreenshotsInput = {
    id?: string
    userId: string
    priority?: number
    status?: $Enums.JobStatus
    currentStep?: number
    totalSteps: number
    progressPercent?: number
    estimatedTimeRemaining?: number | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    failedAt?: Date | string | null
    errorCode?: string | null
    errorMessage?: string | null
    isRecoverable?: boolean
    retryCount?: number
    maxRetries?: number
    lastRetryAt?: Date | string | null
    result?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    workflow: WorkflowCreateNestedOneWithoutJobsInput
    executionLogs?: ExecutionLogCreateNestedManyWithoutJobInput
    scheduleExecution?: ScheduleExecutionCreateNestedOneWithoutJobInput
  }

  export type JobUncheckedCreateWithoutScreenshotsInput = {
    id?: string
    workflowId: string
    userId: string
    priority?: number
    status?: $Enums.JobStatus
    currentStep?: number
    totalSteps: number
    progressPercent?: number
    estimatedTimeRemaining?: number | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    failedAt?: Date | string | null
    errorCode?: string | null
    errorMessage?: string | null
    isRecoverable?: boolean
    retryCount?: number
    maxRetries?: number
    lastRetryAt?: Date | string | null
    result?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    executionLogs?: ExecutionLogUncheckedCreateNestedManyWithoutJobInput
    scheduleExecution?: ScheduleExecutionUncheckedCreateNestedOneWithoutJobInput
  }

  export type JobCreateOrConnectWithoutScreenshotsInput = {
    where: JobWhereUniqueInput
    create: XOR<JobCreateWithoutScreenshotsInput, JobUncheckedCreateWithoutScreenshotsInput>
  }

  export type JobUpsertWithoutScreenshotsInput = {
    update: XOR<JobUpdateWithoutScreenshotsInput, JobUncheckedUpdateWithoutScreenshotsInput>
    create: XOR<JobCreateWithoutScreenshotsInput, JobUncheckedCreateWithoutScreenshotsInput>
    where?: JobWhereInput
  }

  export type JobUpdateToOneWithWhereWithoutScreenshotsInput = {
    where?: JobWhereInput
    data: XOR<JobUpdateWithoutScreenshotsInput, JobUncheckedUpdateWithoutScreenshotsInput>
  }

  export type JobUpdateWithoutScreenshotsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
    status?: EnumJobStatusFieldUpdateOperationsInput | $Enums.JobStatus
    currentStep?: IntFieldUpdateOperationsInput | number
    totalSteps?: IntFieldUpdateOperationsInput | number
    progressPercent?: FloatFieldUpdateOperationsInput | number
    estimatedTimeRemaining?: NullableIntFieldUpdateOperationsInput | number | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorCode?: NullableStringFieldUpdateOperationsInput | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    isRecoverable?: BoolFieldUpdateOperationsInput | boolean
    retryCount?: IntFieldUpdateOperationsInput | number
    maxRetries?: IntFieldUpdateOperationsInput | number
    lastRetryAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    result?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    workflow?: WorkflowUpdateOneRequiredWithoutJobsNestedInput
    executionLogs?: ExecutionLogUpdateManyWithoutJobNestedInput
    scheduleExecution?: ScheduleExecutionUpdateOneWithoutJobNestedInput
  }

  export type JobUncheckedUpdateWithoutScreenshotsInput = {
    id?: StringFieldUpdateOperationsInput | string
    workflowId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
    status?: EnumJobStatusFieldUpdateOperationsInput | $Enums.JobStatus
    currentStep?: IntFieldUpdateOperationsInput | number
    totalSteps?: IntFieldUpdateOperationsInput | number
    progressPercent?: FloatFieldUpdateOperationsInput | number
    estimatedTimeRemaining?: NullableIntFieldUpdateOperationsInput | number | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorCode?: NullableStringFieldUpdateOperationsInput | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    isRecoverable?: BoolFieldUpdateOperationsInput | boolean
    retryCount?: IntFieldUpdateOperationsInput | number
    maxRetries?: IntFieldUpdateOperationsInput | number
    lastRetryAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    result?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    executionLogs?: ExecutionLogUncheckedUpdateManyWithoutJobNestedInput
    scheduleExecution?: ScheduleExecutionUncheckedUpdateOneWithoutJobNestedInput
  }

  export type CredentialAuditLogCreateWithoutCredentialInput = {
    id?: string
    action: $Enums.CredentialAction
    userId?: string | null
    jobId?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    success: boolean
    errorMessage?: string | null
    timestamp?: Date | string
  }

  export type CredentialAuditLogUncheckedCreateWithoutCredentialInput = {
    id?: string
    action: $Enums.CredentialAction
    userId?: string | null
    jobId?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    success: boolean
    errorMessage?: string | null
    timestamp?: Date | string
  }

  export type CredentialAuditLogCreateOrConnectWithoutCredentialInput = {
    where: CredentialAuditLogWhereUniqueInput
    create: XOR<CredentialAuditLogCreateWithoutCredentialInput, CredentialAuditLogUncheckedCreateWithoutCredentialInput>
  }

  export type CredentialAuditLogCreateManyCredentialInputEnvelope = {
    data: CredentialAuditLogCreateManyCredentialInput | CredentialAuditLogCreateManyCredentialInput[]
    skipDuplicates?: boolean
  }

  export type CredentialAuditLogUpsertWithWhereUniqueWithoutCredentialInput = {
    where: CredentialAuditLogWhereUniqueInput
    update: XOR<CredentialAuditLogUpdateWithoutCredentialInput, CredentialAuditLogUncheckedUpdateWithoutCredentialInput>
    create: XOR<CredentialAuditLogCreateWithoutCredentialInput, CredentialAuditLogUncheckedCreateWithoutCredentialInput>
  }

  export type CredentialAuditLogUpdateWithWhereUniqueWithoutCredentialInput = {
    where: CredentialAuditLogWhereUniqueInput
    data: XOR<CredentialAuditLogUpdateWithoutCredentialInput, CredentialAuditLogUncheckedUpdateWithoutCredentialInput>
  }

  export type CredentialAuditLogUpdateManyWithWhereWithoutCredentialInput = {
    where: CredentialAuditLogScalarWhereInput
    data: XOR<CredentialAuditLogUpdateManyMutationInput, CredentialAuditLogUncheckedUpdateManyWithoutCredentialInput>
  }

  export type CredentialAuditLogScalarWhereInput = {
    AND?: CredentialAuditLogScalarWhereInput | CredentialAuditLogScalarWhereInput[]
    OR?: CredentialAuditLogScalarWhereInput[]
    NOT?: CredentialAuditLogScalarWhereInput | CredentialAuditLogScalarWhereInput[]
    id?: StringFilter<"CredentialAuditLog"> | string
    credentialId?: StringFilter<"CredentialAuditLog"> | string
    action?: EnumCredentialActionFilter<"CredentialAuditLog"> | $Enums.CredentialAction
    userId?: StringNullableFilter<"CredentialAuditLog"> | string | null
    jobId?: StringNullableFilter<"CredentialAuditLog"> | string | null
    ipAddress?: StringNullableFilter<"CredentialAuditLog"> | string | null
    userAgent?: StringNullableFilter<"CredentialAuditLog"> | string | null
    success?: BoolFilter<"CredentialAuditLog"> | boolean
    errorMessage?: StringNullableFilter<"CredentialAuditLog"> | string | null
    timestamp?: DateTimeFilter<"CredentialAuditLog"> | Date | string
  }

  export type CredentialCreateWithoutAuditLogsInput = {
    id?: string
    name: string
    description?: string | null
    type: $Enums.CredentialType
    encryptedValue: string
    iv: string
    authTag: string
    keyVaultId?: string | null
    keyVersion?: number
    rotationDays?: number
    lastRotatedAt?: Date | string
    nextRotationAt: Date | string
    lastAccessedAt?: Date | string | null
    accessCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type CredentialUncheckedCreateWithoutAuditLogsInput = {
    id?: string
    name: string
    description?: string | null
    type: $Enums.CredentialType
    encryptedValue: string
    iv: string
    authTag: string
    keyVaultId?: string | null
    keyVersion?: number
    rotationDays?: number
    lastRotatedAt?: Date | string
    nextRotationAt: Date | string
    lastAccessedAt?: Date | string | null
    accessCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type CredentialCreateOrConnectWithoutAuditLogsInput = {
    where: CredentialWhereUniqueInput
    create: XOR<CredentialCreateWithoutAuditLogsInput, CredentialUncheckedCreateWithoutAuditLogsInput>
  }

  export type CredentialUpsertWithoutAuditLogsInput = {
    update: XOR<CredentialUpdateWithoutAuditLogsInput, CredentialUncheckedUpdateWithoutAuditLogsInput>
    create: XOR<CredentialCreateWithoutAuditLogsInput, CredentialUncheckedCreateWithoutAuditLogsInput>
    where?: CredentialWhereInput
  }

  export type CredentialUpdateToOneWithWhereWithoutAuditLogsInput = {
    where?: CredentialWhereInput
    data: XOR<CredentialUpdateWithoutAuditLogsInput, CredentialUncheckedUpdateWithoutAuditLogsInput>
  }

  export type CredentialUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumCredentialTypeFieldUpdateOperationsInput | $Enums.CredentialType
    encryptedValue?: StringFieldUpdateOperationsInput | string
    iv?: StringFieldUpdateOperationsInput | string
    authTag?: StringFieldUpdateOperationsInput | string
    keyVaultId?: NullableStringFieldUpdateOperationsInput | string | null
    keyVersion?: IntFieldUpdateOperationsInput | number
    rotationDays?: IntFieldUpdateOperationsInput | number
    lastRotatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nextRotationAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastAccessedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accessCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CredentialUncheckedUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumCredentialTypeFieldUpdateOperationsInput | $Enums.CredentialType
    encryptedValue?: StringFieldUpdateOperationsInput | string
    iv?: StringFieldUpdateOperationsInput | string
    authTag?: StringFieldUpdateOperationsInput | string
    keyVaultId?: NullableStringFieldUpdateOperationsInput | string | null
    keyVersion?: IntFieldUpdateOperationsInput | number
    rotationDays?: IntFieldUpdateOperationsInput | number
    lastRotatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nextRotationAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastAccessedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accessCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WebhookDeliveryCreateWithoutWebhookInput = {
    id?: string
    event: string
    payload: JsonNullValueInput | InputJsonValue
    attempt?: number
    statusCode?: number | null
    responseBody?: string | null
    responseTime?: number | null
    success: boolean
    errorMessage?: string | null
    deliveredAt?: Date | string
    nextRetryAt?: Date | string | null
  }

  export type WebhookDeliveryUncheckedCreateWithoutWebhookInput = {
    id?: string
    event: string
    payload: JsonNullValueInput | InputJsonValue
    attempt?: number
    statusCode?: number | null
    responseBody?: string | null
    responseTime?: number | null
    success: boolean
    errorMessage?: string | null
    deliveredAt?: Date | string
    nextRetryAt?: Date | string | null
  }

  export type WebhookDeliveryCreateOrConnectWithoutWebhookInput = {
    where: WebhookDeliveryWhereUniqueInput
    create: XOR<WebhookDeliveryCreateWithoutWebhookInput, WebhookDeliveryUncheckedCreateWithoutWebhookInput>
  }

  export type WebhookDeliveryCreateManyWebhookInputEnvelope = {
    data: WebhookDeliveryCreateManyWebhookInput | WebhookDeliveryCreateManyWebhookInput[]
    skipDuplicates?: boolean
  }

  export type WebhookDeliveryUpsertWithWhereUniqueWithoutWebhookInput = {
    where: WebhookDeliveryWhereUniqueInput
    update: XOR<WebhookDeliveryUpdateWithoutWebhookInput, WebhookDeliveryUncheckedUpdateWithoutWebhookInput>
    create: XOR<WebhookDeliveryCreateWithoutWebhookInput, WebhookDeliveryUncheckedCreateWithoutWebhookInput>
  }

  export type WebhookDeliveryUpdateWithWhereUniqueWithoutWebhookInput = {
    where: WebhookDeliveryWhereUniqueInput
    data: XOR<WebhookDeliveryUpdateWithoutWebhookInput, WebhookDeliveryUncheckedUpdateWithoutWebhookInput>
  }

  export type WebhookDeliveryUpdateManyWithWhereWithoutWebhookInput = {
    where: WebhookDeliveryScalarWhereInput
    data: XOR<WebhookDeliveryUpdateManyMutationInput, WebhookDeliveryUncheckedUpdateManyWithoutWebhookInput>
  }

  export type WebhookDeliveryScalarWhereInput = {
    AND?: WebhookDeliveryScalarWhereInput | WebhookDeliveryScalarWhereInput[]
    OR?: WebhookDeliveryScalarWhereInput[]
    NOT?: WebhookDeliveryScalarWhereInput | WebhookDeliveryScalarWhereInput[]
    id?: StringFilter<"WebhookDelivery"> | string
    webhookId?: StringFilter<"WebhookDelivery"> | string
    event?: StringFilter<"WebhookDelivery"> | string
    payload?: JsonFilter<"WebhookDelivery">
    attempt?: IntFilter<"WebhookDelivery"> | number
    statusCode?: IntNullableFilter<"WebhookDelivery"> | number | null
    responseBody?: StringNullableFilter<"WebhookDelivery"> | string | null
    responseTime?: IntNullableFilter<"WebhookDelivery"> | number | null
    success?: BoolFilter<"WebhookDelivery"> | boolean
    errorMessage?: StringNullableFilter<"WebhookDelivery"> | string | null
    deliveredAt?: DateTimeFilter<"WebhookDelivery"> | Date | string
    nextRetryAt?: DateTimeNullableFilter<"WebhookDelivery"> | Date | string | null
  }

  export type WebhookCreateWithoutDeliveriesInput = {
    id?: string
    url: string
    secret: string
    events?: WebhookCreateeventsInput | string[]
    isActive?: boolean
    maxRetries?: number
    retryDelay?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type WebhookUncheckedCreateWithoutDeliveriesInput = {
    id?: string
    url: string
    secret: string
    events?: WebhookCreateeventsInput | string[]
    isActive?: boolean
    maxRetries?: number
    retryDelay?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type WebhookCreateOrConnectWithoutDeliveriesInput = {
    where: WebhookWhereUniqueInput
    create: XOR<WebhookCreateWithoutDeliveriesInput, WebhookUncheckedCreateWithoutDeliveriesInput>
  }

  export type WebhookUpsertWithoutDeliveriesInput = {
    update: XOR<WebhookUpdateWithoutDeliveriesInput, WebhookUncheckedUpdateWithoutDeliveriesInput>
    create: XOR<WebhookCreateWithoutDeliveriesInput, WebhookUncheckedCreateWithoutDeliveriesInput>
    where?: WebhookWhereInput
  }

  export type WebhookUpdateToOneWithWhereWithoutDeliveriesInput = {
    where?: WebhookWhereInput
    data: XOR<WebhookUpdateWithoutDeliveriesInput, WebhookUncheckedUpdateWithoutDeliveriesInput>
  }

  export type WebhookUpdateWithoutDeliveriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    secret?: StringFieldUpdateOperationsInput | string
    events?: WebhookUpdateeventsInput | string[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    maxRetries?: IntFieldUpdateOperationsInput | number
    retryDelay?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WebhookUncheckedUpdateWithoutDeliveriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    secret?: StringFieldUpdateOperationsInput | string
    events?: WebhookUpdateeventsInput | string[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    maxRetries?: IntFieldUpdateOperationsInput | number
    retryDelay?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WorkflowCreateWithoutSchedulesInput = {
    id?: string
    organizationId: string
    name: string
    description?: string | null
    version?: number
    isActive?: boolean
    definition: JsonNullValueInput | InputJsonValue
    eventsCount: number
    estimatedDuration?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    jobs?: JobCreateNestedManyWithoutWorkflowInput
  }

  export type WorkflowUncheckedCreateWithoutSchedulesInput = {
    id?: string
    organizationId: string
    name: string
    description?: string | null
    version?: number
    isActive?: boolean
    definition: JsonNullValueInput | InputJsonValue
    eventsCount: number
    estimatedDuration?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    jobs?: JobUncheckedCreateNestedManyWithoutWorkflowInput
  }

  export type WorkflowCreateOrConnectWithoutSchedulesInput = {
    where: WorkflowWhereUniqueInput
    create: XOR<WorkflowCreateWithoutSchedulesInput, WorkflowUncheckedCreateWithoutSchedulesInput>
  }

  export type ScheduleExecutionCreateWithoutScheduleInput = {
    id?: string
    organizationId: string
    scheduledTime: Date | string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    duration?: number | null
    status: string
    trigger: string
    errorMessage?: string | null
    errorStack?: string | null
    errorCode?: string | null
    attemptNumber?: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    job?: JobCreateNestedOneWithoutScheduleExecutionInput
  }

  export type ScheduleExecutionUncheckedCreateWithoutScheduleInput = {
    id?: string
    organizationId: string
    jobId?: string | null
    scheduledTime: Date | string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    duration?: number | null
    status: string
    trigger: string
    errorMessage?: string | null
    errorStack?: string | null
    errorCode?: string | null
    attemptNumber?: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ScheduleExecutionCreateOrConnectWithoutScheduleInput = {
    where: ScheduleExecutionWhereUniqueInput
    create: XOR<ScheduleExecutionCreateWithoutScheduleInput, ScheduleExecutionUncheckedCreateWithoutScheduleInput>
  }

  export type ScheduleExecutionCreateManyScheduleInputEnvelope = {
    data: ScheduleExecutionCreateManyScheduleInput | ScheduleExecutionCreateManyScheduleInput[]
    skipDuplicates?: boolean
  }

  export type ScheduleAuditLogCreateWithoutScheduleInput = {
    id?: string
    organizationId: string
    action: string
    resource: string
    userId: string
    userEmail?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    requestId?: string | null
    previousValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    changedFields?: ScheduleAuditLogCreatechangedFieldsInput | string[]
    status: string
    errorMessage?: string | null
    errorCode?: string | null
    durationMs?: number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: Date | string
    retainUntil: Date | string
  }

  export type ScheduleAuditLogUncheckedCreateWithoutScheduleInput = {
    id?: string
    organizationId: string
    action: string
    resource: string
    userId: string
    userEmail?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    requestId?: string | null
    previousValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    changedFields?: ScheduleAuditLogCreatechangedFieldsInput | string[]
    status: string
    errorMessage?: string | null
    errorCode?: string | null
    durationMs?: number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: Date | string
    retainUntil: Date | string
  }

  export type ScheduleAuditLogCreateOrConnectWithoutScheduleInput = {
    where: ScheduleAuditLogWhereUniqueInput
    create: XOR<ScheduleAuditLogCreateWithoutScheduleInput, ScheduleAuditLogUncheckedCreateWithoutScheduleInput>
  }

  export type ScheduleAuditLogCreateManyScheduleInputEnvelope = {
    data: ScheduleAuditLogCreateManyScheduleInput | ScheduleAuditLogCreateManyScheduleInput[]
    skipDuplicates?: boolean
  }

  export type WorkflowUpsertWithoutSchedulesInput = {
    update: XOR<WorkflowUpdateWithoutSchedulesInput, WorkflowUncheckedUpdateWithoutSchedulesInput>
    create: XOR<WorkflowCreateWithoutSchedulesInput, WorkflowUncheckedCreateWithoutSchedulesInput>
    where?: WorkflowWhereInput
  }

  export type WorkflowUpdateToOneWithWhereWithoutSchedulesInput = {
    where?: WorkflowWhereInput
    data: XOR<WorkflowUpdateWithoutSchedulesInput, WorkflowUncheckedUpdateWithoutSchedulesInput>
  }

  export type WorkflowUpdateWithoutSchedulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    definition?: JsonNullValueInput | InputJsonValue
    eventsCount?: IntFieldUpdateOperationsInput | number
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jobs?: JobUpdateManyWithoutWorkflowNestedInput
  }

  export type WorkflowUncheckedUpdateWithoutSchedulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    definition?: JsonNullValueInput | InputJsonValue
    eventsCount?: IntFieldUpdateOperationsInput | number
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jobs?: JobUncheckedUpdateManyWithoutWorkflowNestedInput
  }

  export type ScheduleExecutionUpsertWithWhereUniqueWithoutScheduleInput = {
    where: ScheduleExecutionWhereUniqueInput
    update: XOR<ScheduleExecutionUpdateWithoutScheduleInput, ScheduleExecutionUncheckedUpdateWithoutScheduleInput>
    create: XOR<ScheduleExecutionCreateWithoutScheduleInput, ScheduleExecutionUncheckedCreateWithoutScheduleInput>
  }

  export type ScheduleExecutionUpdateWithWhereUniqueWithoutScheduleInput = {
    where: ScheduleExecutionWhereUniqueInput
    data: XOR<ScheduleExecutionUpdateWithoutScheduleInput, ScheduleExecutionUncheckedUpdateWithoutScheduleInput>
  }

  export type ScheduleExecutionUpdateManyWithWhereWithoutScheduleInput = {
    where: ScheduleExecutionScalarWhereInput
    data: XOR<ScheduleExecutionUpdateManyMutationInput, ScheduleExecutionUncheckedUpdateManyWithoutScheduleInput>
  }

  export type ScheduleExecutionScalarWhereInput = {
    AND?: ScheduleExecutionScalarWhereInput | ScheduleExecutionScalarWhereInput[]
    OR?: ScheduleExecutionScalarWhereInput[]
    NOT?: ScheduleExecutionScalarWhereInput | ScheduleExecutionScalarWhereInput[]
    id?: StringFilter<"ScheduleExecution"> | string
    organizationId?: StringFilter<"ScheduleExecution"> | string
    scheduleId?: StringFilter<"ScheduleExecution"> | string
    jobId?: StringNullableFilter<"ScheduleExecution"> | string | null
    scheduledTime?: DateTimeFilter<"ScheduleExecution"> | Date | string
    startedAt?: DateTimeNullableFilter<"ScheduleExecution"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"ScheduleExecution"> | Date | string | null
    duration?: IntNullableFilter<"ScheduleExecution"> | number | null
    status?: StringFilter<"ScheduleExecution"> | string
    trigger?: StringFilter<"ScheduleExecution"> | string
    errorMessage?: StringNullableFilter<"ScheduleExecution"> | string | null
    errorStack?: StringNullableFilter<"ScheduleExecution"> | string | null
    errorCode?: StringNullableFilter<"ScheduleExecution"> | string | null
    attemptNumber?: IntFilter<"ScheduleExecution"> | number
    metadata?: JsonNullableFilter<"ScheduleExecution">
    createdAt?: DateTimeFilter<"ScheduleExecution"> | Date | string
    updatedAt?: DateTimeFilter<"ScheduleExecution"> | Date | string
  }

  export type ScheduleAuditLogUpsertWithWhereUniqueWithoutScheduleInput = {
    where: ScheduleAuditLogWhereUniqueInput
    update: XOR<ScheduleAuditLogUpdateWithoutScheduleInput, ScheduleAuditLogUncheckedUpdateWithoutScheduleInput>
    create: XOR<ScheduleAuditLogCreateWithoutScheduleInput, ScheduleAuditLogUncheckedCreateWithoutScheduleInput>
  }

  export type ScheduleAuditLogUpdateWithWhereUniqueWithoutScheduleInput = {
    where: ScheduleAuditLogWhereUniqueInput
    data: XOR<ScheduleAuditLogUpdateWithoutScheduleInput, ScheduleAuditLogUncheckedUpdateWithoutScheduleInput>
  }

  export type ScheduleAuditLogUpdateManyWithWhereWithoutScheduleInput = {
    where: ScheduleAuditLogScalarWhereInput
    data: XOR<ScheduleAuditLogUpdateManyMutationInput, ScheduleAuditLogUncheckedUpdateManyWithoutScheduleInput>
  }

  export type ScheduleAuditLogScalarWhereInput = {
    AND?: ScheduleAuditLogScalarWhereInput | ScheduleAuditLogScalarWhereInput[]
    OR?: ScheduleAuditLogScalarWhereInput[]
    NOT?: ScheduleAuditLogScalarWhereInput | ScheduleAuditLogScalarWhereInput[]
    id?: StringFilter<"ScheduleAuditLog"> | string
    scheduleId?: StringNullableFilter<"ScheduleAuditLog"> | string | null
    organizationId?: StringFilter<"ScheduleAuditLog"> | string
    action?: StringFilter<"ScheduleAuditLog"> | string
    resource?: StringFilter<"ScheduleAuditLog"> | string
    userId?: StringFilter<"ScheduleAuditLog"> | string
    userEmail?: StringNullableFilter<"ScheduleAuditLog"> | string | null
    ipAddress?: StringNullableFilter<"ScheduleAuditLog"> | string | null
    userAgent?: StringNullableFilter<"ScheduleAuditLog"> | string | null
    requestId?: StringNullableFilter<"ScheduleAuditLog"> | string | null
    previousValue?: JsonNullableFilter<"ScheduleAuditLog">
    newValue?: JsonNullableFilter<"ScheduleAuditLog">
    changedFields?: StringNullableListFilter<"ScheduleAuditLog">
    status?: StringFilter<"ScheduleAuditLog"> | string
    errorMessage?: StringNullableFilter<"ScheduleAuditLog"> | string | null
    errorCode?: StringNullableFilter<"ScheduleAuditLog"> | string | null
    durationMs?: IntNullableFilter<"ScheduleAuditLog"> | number | null
    metadata?: JsonNullableFilter<"ScheduleAuditLog">
    timestamp?: DateTimeFilter<"ScheduleAuditLog"> | Date | string
    retainUntil?: DateTimeFilter<"ScheduleAuditLog"> | Date | string
  }

  export type ScheduleCreateWithoutExecutionsInput = {
    id?: string
    organizationId: string
    name: string
    description?: string | null
    cronExpression: string
    timezone?: string
    enabled?: boolean
    nextExecutionTime?: Date | string | null
    lastExecutionTime?: Date | string | null
    lastExecutionStatus?: string | null
    eventBridgeRuleArn?: string | null
    eventBridgeRuleName?: string | null
    executionWindow?: NullableJsonNullValueInput | InputJsonValue
    maxConcurrentRuns?: number
    retryPolicy?: NullableJsonNullValueInput | InputJsonValue
    dependencies?: NullableJsonNullValueInput | InputJsonValue
    notificationConfig?: NullableJsonNullValueInput | InputJsonValue
    tags?: ScheduleCreatetagsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    updatedBy?: string | null
    deletedAt?: Date | string | null
    workflow: WorkflowCreateNestedOneWithoutSchedulesInput
    auditLogs?: ScheduleAuditLogCreateNestedManyWithoutScheduleInput
  }

  export type ScheduleUncheckedCreateWithoutExecutionsInput = {
    id?: string
    organizationId: string
    workflowId: string
    name: string
    description?: string | null
    cronExpression: string
    timezone?: string
    enabled?: boolean
    nextExecutionTime?: Date | string | null
    lastExecutionTime?: Date | string | null
    lastExecutionStatus?: string | null
    eventBridgeRuleArn?: string | null
    eventBridgeRuleName?: string | null
    executionWindow?: NullableJsonNullValueInput | InputJsonValue
    maxConcurrentRuns?: number
    retryPolicy?: NullableJsonNullValueInput | InputJsonValue
    dependencies?: NullableJsonNullValueInput | InputJsonValue
    notificationConfig?: NullableJsonNullValueInput | InputJsonValue
    tags?: ScheduleCreatetagsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    updatedBy?: string | null
    deletedAt?: Date | string | null
    auditLogs?: ScheduleAuditLogUncheckedCreateNestedManyWithoutScheduleInput
  }

  export type ScheduleCreateOrConnectWithoutExecutionsInput = {
    where: ScheduleWhereUniqueInput
    create: XOR<ScheduleCreateWithoutExecutionsInput, ScheduleUncheckedCreateWithoutExecutionsInput>
  }

  export type JobCreateWithoutScheduleExecutionInput = {
    id?: string
    userId: string
    priority?: number
    status?: $Enums.JobStatus
    currentStep?: number
    totalSteps: number
    progressPercent?: number
    estimatedTimeRemaining?: number | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    failedAt?: Date | string | null
    errorCode?: string | null
    errorMessage?: string | null
    isRecoverable?: boolean
    retryCount?: number
    maxRetries?: number
    lastRetryAt?: Date | string | null
    result?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    workflow: WorkflowCreateNestedOneWithoutJobsInput
    executionLogs?: ExecutionLogCreateNestedManyWithoutJobInput
    screenshots?: ExecutionScreenshotCreateNestedManyWithoutJobInput
  }

  export type JobUncheckedCreateWithoutScheduleExecutionInput = {
    id?: string
    workflowId: string
    userId: string
    priority?: number
    status?: $Enums.JobStatus
    currentStep?: number
    totalSteps: number
    progressPercent?: number
    estimatedTimeRemaining?: number | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    failedAt?: Date | string | null
    errorCode?: string | null
    errorMessage?: string | null
    isRecoverable?: boolean
    retryCount?: number
    maxRetries?: number
    lastRetryAt?: Date | string | null
    result?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    executionLogs?: ExecutionLogUncheckedCreateNestedManyWithoutJobInput
    screenshots?: ExecutionScreenshotUncheckedCreateNestedManyWithoutJobInput
  }

  export type JobCreateOrConnectWithoutScheduleExecutionInput = {
    where: JobWhereUniqueInput
    create: XOR<JobCreateWithoutScheduleExecutionInput, JobUncheckedCreateWithoutScheduleExecutionInput>
  }

  export type ScheduleUpsertWithoutExecutionsInput = {
    update: XOR<ScheduleUpdateWithoutExecutionsInput, ScheduleUncheckedUpdateWithoutExecutionsInput>
    create: XOR<ScheduleCreateWithoutExecutionsInput, ScheduleUncheckedCreateWithoutExecutionsInput>
    where?: ScheduleWhereInput
  }

  export type ScheduleUpdateToOneWithWhereWithoutExecutionsInput = {
    where?: ScheduleWhereInput
    data: XOR<ScheduleUpdateWithoutExecutionsInput, ScheduleUncheckedUpdateWithoutExecutionsInput>
  }

  export type ScheduleUpdateWithoutExecutionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    cronExpression?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    nextExecutionTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastExecutionTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastExecutionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    eventBridgeRuleArn?: NullableStringFieldUpdateOperationsInput | string | null
    eventBridgeRuleName?: NullableStringFieldUpdateOperationsInput | string | null
    executionWindow?: NullableJsonNullValueInput | InputJsonValue
    maxConcurrentRuns?: IntFieldUpdateOperationsInput | number
    retryPolicy?: NullableJsonNullValueInput | InputJsonValue
    dependencies?: NullableJsonNullValueInput | InputJsonValue
    notificationConfig?: NullableJsonNullValueInput | InputJsonValue
    tags?: ScheduleUpdatetagsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    workflow?: WorkflowUpdateOneRequiredWithoutSchedulesNestedInput
    auditLogs?: ScheduleAuditLogUpdateManyWithoutScheduleNestedInput
  }

  export type ScheduleUncheckedUpdateWithoutExecutionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    workflowId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    cronExpression?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    nextExecutionTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastExecutionTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastExecutionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    eventBridgeRuleArn?: NullableStringFieldUpdateOperationsInput | string | null
    eventBridgeRuleName?: NullableStringFieldUpdateOperationsInput | string | null
    executionWindow?: NullableJsonNullValueInput | InputJsonValue
    maxConcurrentRuns?: IntFieldUpdateOperationsInput | number
    retryPolicy?: NullableJsonNullValueInput | InputJsonValue
    dependencies?: NullableJsonNullValueInput | InputJsonValue
    notificationConfig?: NullableJsonNullValueInput | InputJsonValue
    tags?: ScheduleUpdatetagsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    auditLogs?: ScheduleAuditLogUncheckedUpdateManyWithoutScheduleNestedInput
  }

  export type JobUpsertWithoutScheduleExecutionInput = {
    update: XOR<JobUpdateWithoutScheduleExecutionInput, JobUncheckedUpdateWithoutScheduleExecutionInput>
    create: XOR<JobCreateWithoutScheduleExecutionInput, JobUncheckedCreateWithoutScheduleExecutionInput>
    where?: JobWhereInput
  }

  export type JobUpdateToOneWithWhereWithoutScheduleExecutionInput = {
    where?: JobWhereInput
    data: XOR<JobUpdateWithoutScheduleExecutionInput, JobUncheckedUpdateWithoutScheduleExecutionInput>
  }

  export type JobUpdateWithoutScheduleExecutionInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
    status?: EnumJobStatusFieldUpdateOperationsInput | $Enums.JobStatus
    currentStep?: IntFieldUpdateOperationsInput | number
    totalSteps?: IntFieldUpdateOperationsInput | number
    progressPercent?: FloatFieldUpdateOperationsInput | number
    estimatedTimeRemaining?: NullableIntFieldUpdateOperationsInput | number | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorCode?: NullableStringFieldUpdateOperationsInput | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    isRecoverable?: BoolFieldUpdateOperationsInput | boolean
    retryCount?: IntFieldUpdateOperationsInput | number
    maxRetries?: IntFieldUpdateOperationsInput | number
    lastRetryAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    result?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    workflow?: WorkflowUpdateOneRequiredWithoutJobsNestedInput
    executionLogs?: ExecutionLogUpdateManyWithoutJobNestedInput
    screenshots?: ExecutionScreenshotUpdateManyWithoutJobNestedInput
  }

  export type JobUncheckedUpdateWithoutScheduleExecutionInput = {
    id?: StringFieldUpdateOperationsInput | string
    workflowId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
    status?: EnumJobStatusFieldUpdateOperationsInput | $Enums.JobStatus
    currentStep?: IntFieldUpdateOperationsInput | number
    totalSteps?: IntFieldUpdateOperationsInput | number
    progressPercent?: FloatFieldUpdateOperationsInput | number
    estimatedTimeRemaining?: NullableIntFieldUpdateOperationsInput | number | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorCode?: NullableStringFieldUpdateOperationsInput | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    isRecoverable?: BoolFieldUpdateOperationsInput | boolean
    retryCount?: IntFieldUpdateOperationsInput | number
    maxRetries?: IntFieldUpdateOperationsInput | number
    lastRetryAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    result?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    executionLogs?: ExecutionLogUncheckedUpdateManyWithoutJobNestedInput
    screenshots?: ExecutionScreenshotUncheckedUpdateManyWithoutJobNestedInput
  }

  export type ScheduleCreateWithoutAuditLogsInput = {
    id?: string
    organizationId: string
    name: string
    description?: string | null
    cronExpression: string
    timezone?: string
    enabled?: boolean
    nextExecutionTime?: Date | string | null
    lastExecutionTime?: Date | string | null
    lastExecutionStatus?: string | null
    eventBridgeRuleArn?: string | null
    eventBridgeRuleName?: string | null
    executionWindow?: NullableJsonNullValueInput | InputJsonValue
    maxConcurrentRuns?: number
    retryPolicy?: NullableJsonNullValueInput | InputJsonValue
    dependencies?: NullableJsonNullValueInput | InputJsonValue
    notificationConfig?: NullableJsonNullValueInput | InputJsonValue
    tags?: ScheduleCreatetagsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    updatedBy?: string | null
    deletedAt?: Date | string | null
    workflow: WorkflowCreateNestedOneWithoutSchedulesInput
    executions?: ScheduleExecutionCreateNestedManyWithoutScheduleInput
  }

  export type ScheduleUncheckedCreateWithoutAuditLogsInput = {
    id?: string
    organizationId: string
    workflowId: string
    name: string
    description?: string | null
    cronExpression: string
    timezone?: string
    enabled?: boolean
    nextExecutionTime?: Date | string | null
    lastExecutionTime?: Date | string | null
    lastExecutionStatus?: string | null
    eventBridgeRuleArn?: string | null
    eventBridgeRuleName?: string | null
    executionWindow?: NullableJsonNullValueInput | InputJsonValue
    maxConcurrentRuns?: number
    retryPolicy?: NullableJsonNullValueInput | InputJsonValue
    dependencies?: NullableJsonNullValueInput | InputJsonValue
    notificationConfig?: NullableJsonNullValueInput | InputJsonValue
    tags?: ScheduleCreatetagsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    updatedBy?: string | null
    deletedAt?: Date | string | null
    executions?: ScheduleExecutionUncheckedCreateNestedManyWithoutScheduleInput
  }

  export type ScheduleCreateOrConnectWithoutAuditLogsInput = {
    where: ScheduleWhereUniqueInput
    create: XOR<ScheduleCreateWithoutAuditLogsInput, ScheduleUncheckedCreateWithoutAuditLogsInput>
  }

  export type ScheduleUpsertWithoutAuditLogsInput = {
    update: XOR<ScheduleUpdateWithoutAuditLogsInput, ScheduleUncheckedUpdateWithoutAuditLogsInput>
    create: XOR<ScheduleCreateWithoutAuditLogsInput, ScheduleUncheckedCreateWithoutAuditLogsInput>
    where?: ScheduleWhereInput
  }

  export type ScheduleUpdateToOneWithWhereWithoutAuditLogsInput = {
    where?: ScheduleWhereInput
    data: XOR<ScheduleUpdateWithoutAuditLogsInput, ScheduleUncheckedUpdateWithoutAuditLogsInput>
  }

  export type ScheduleUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    cronExpression?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    nextExecutionTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastExecutionTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastExecutionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    eventBridgeRuleArn?: NullableStringFieldUpdateOperationsInput | string | null
    eventBridgeRuleName?: NullableStringFieldUpdateOperationsInput | string | null
    executionWindow?: NullableJsonNullValueInput | InputJsonValue
    maxConcurrentRuns?: IntFieldUpdateOperationsInput | number
    retryPolicy?: NullableJsonNullValueInput | InputJsonValue
    dependencies?: NullableJsonNullValueInput | InputJsonValue
    notificationConfig?: NullableJsonNullValueInput | InputJsonValue
    tags?: ScheduleUpdatetagsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    workflow?: WorkflowUpdateOneRequiredWithoutSchedulesNestedInput
    executions?: ScheduleExecutionUpdateManyWithoutScheduleNestedInput
  }

  export type ScheduleUncheckedUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    workflowId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    cronExpression?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    nextExecutionTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastExecutionTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastExecutionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    eventBridgeRuleArn?: NullableStringFieldUpdateOperationsInput | string | null
    eventBridgeRuleName?: NullableStringFieldUpdateOperationsInput | string | null
    executionWindow?: NullableJsonNullValueInput | InputJsonValue
    maxConcurrentRuns?: IntFieldUpdateOperationsInput | number
    retryPolicy?: NullableJsonNullValueInput | InputJsonValue
    dependencies?: NullableJsonNullValueInput | InputJsonValue
    notificationConfig?: NullableJsonNullValueInput | InputJsonValue
    tags?: ScheduleUpdatetagsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    executions?: ScheduleExecutionUncheckedUpdateManyWithoutScheduleNestedInput
  }

  export type JobCreateManyWorkflowInput = {
    id?: string
    userId: string
    priority?: number
    status?: $Enums.JobStatus
    currentStep?: number
    totalSteps: number
    progressPercent?: number
    estimatedTimeRemaining?: number | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    failedAt?: Date | string | null
    errorCode?: string | null
    errorMessage?: string | null
    isRecoverable?: boolean
    retryCount?: number
    maxRetries?: number
    lastRetryAt?: Date | string | null
    result?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type ScheduleCreateManyWorkflowInput = {
    id?: string
    organizationId: string
    name: string
    description?: string | null
    cronExpression: string
    timezone?: string
    enabled?: boolean
    nextExecutionTime?: Date | string | null
    lastExecutionTime?: Date | string | null
    lastExecutionStatus?: string | null
    eventBridgeRuleArn?: string | null
    eventBridgeRuleName?: string | null
    executionWindow?: NullableJsonNullValueInput | InputJsonValue
    maxConcurrentRuns?: number
    retryPolicy?: NullableJsonNullValueInput | InputJsonValue
    dependencies?: NullableJsonNullValueInput | InputJsonValue
    notificationConfig?: NullableJsonNullValueInput | InputJsonValue
    tags?: ScheduleCreatetagsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    updatedBy?: string | null
    deletedAt?: Date | string | null
  }

  export type JobUpdateWithoutWorkflowInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
    status?: EnumJobStatusFieldUpdateOperationsInput | $Enums.JobStatus
    currentStep?: IntFieldUpdateOperationsInput | number
    totalSteps?: IntFieldUpdateOperationsInput | number
    progressPercent?: FloatFieldUpdateOperationsInput | number
    estimatedTimeRemaining?: NullableIntFieldUpdateOperationsInput | number | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorCode?: NullableStringFieldUpdateOperationsInput | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    isRecoverable?: BoolFieldUpdateOperationsInput | boolean
    retryCount?: IntFieldUpdateOperationsInput | number
    maxRetries?: IntFieldUpdateOperationsInput | number
    lastRetryAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    result?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    executionLogs?: ExecutionLogUpdateManyWithoutJobNestedInput
    screenshots?: ExecutionScreenshotUpdateManyWithoutJobNestedInput
    scheduleExecution?: ScheduleExecutionUpdateOneWithoutJobNestedInput
  }

  export type JobUncheckedUpdateWithoutWorkflowInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
    status?: EnumJobStatusFieldUpdateOperationsInput | $Enums.JobStatus
    currentStep?: IntFieldUpdateOperationsInput | number
    totalSteps?: IntFieldUpdateOperationsInput | number
    progressPercent?: FloatFieldUpdateOperationsInput | number
    estimatedTimeRemaining?: NullableIntFieldUpdateOperationsInput | number | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorCode?: NullableStringFieldUpdateOperationsInput | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    isRecoverable?: BoolFieldUpdateOperationsInput | boolean
    retryCount?: IntFieldUpdateOperationsInput | number
    maxRetries?: IntFieldUpdateOperationsInput | number
    lastRetryAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    result?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    executionLogs?: ExecutionLogUncheckedUpdateManyWithoutJobNestedInput
    screenshots?: ExecutionScreenshotUncheckedUpdateManyWithoutJobNestedInput
    scheduleExecution?: ScheduleExecutionUncheckedUpdateOneWithoutJobNestedInput
  }

  export type JobUncheckedUpdateManyWithoutWorkflowInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
    status?: EnumJobStatusFieldUpdateOperationsInput | $Enums.JobStatus
    currentStep?: IntFieldUpdateOperationsInput | number
    totalSteps?: IntFieldUpdateOperationsInput | number
    progressPercent?: FloatFieldUpdateOperationsInput | number
    estimatedTimeRemaining?: NullableIntFieldUpdateOperationsInput | number | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorCode?: NullableStringFieldUpdateOperationsInput | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    isRecoverable?: BoolFieldUpdateOperationsInput | boolean
    retryCount?: IntFieldUpdateOperationsInput | number
    maxRetries?: IntFieldUpdateOperationsInput | number
    lastRetryAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    result?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ScheduleUpdateWithoutWorkflowInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    cronExpression?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    nextExecutionTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastExecutionTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastExecutionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    eventBridgeRuleArn?: NullableStringFieldUpdateOperationsInput | string | null
    eventBridgeRuleName?: NullableStringFieldUpdateOperationsInput | string | null
    executionWindow?: NullableJsonNullValueInput | InputJsonValue
    maxConcurrentRuns?: IntFieldUpdateOperationsInput | number
    retryPolicy?: NullableJsonNullValueInput | InputJsonValue
    dependencies?: NullableJsonNullValueInput | InputJsonValue
    notificationConfig?: NullableJsonNullValueInput | InputJsonValue
    tags?: ScheduleUpdatetagsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    executions?: ScheduleExecutionUpdateManyWithoutScheduleNestedInput
    auditLogs?: ScheduleAuditLogUpdateManyWithoutScheduleNestedInput
  }

  export type ScheduleUncheckedUpdateWithoutWorkflowInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    cronExpression?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    nextExecutionTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastExecutionTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastExecutionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    eventBridgeRuleArn?: NullableStringFieldUpdateOperationsInput | string | null
    eventBridgeRuleName?: NullableStringFieldUpdateOperationsInput | string | null
    executionWindow?: NullableJsonNullValueInput | InputJsonValue
    maxConcurrentRuns?: IntFieldUpdateOperationsInput | number
    retryPolicy?: NullableJsonNullValueInput | InputJsonValue
    dependencies?: NullableJsonNullValueInput | InputJsonValue
    notificationConfig?: NullableJsonNullValueInput | InputJsonValue
    tags?: ScheduleUpdatetagsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    executions?: ScheduleExecutionUncheckedUpdateManyWithoutScheduleNestedInput
    auditLogs?: ScheduleAuditLogUncheckedUpdateManyWithoutScheduleNestedInput
  }

  export type ScheduleUncheckedUpdateManyWithoutWorkflowInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    cronExpression?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    nextExecutionTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastExecutionTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastExecutionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    eventBridgeRuleArn?: NullableStringFieldUpdateOperationsInput | string | null
    eventBridgeRuleName?: NullableStringFieldUpdateOperationsInput | string | null
    executionWindow?: NullableJsonNullValueInput | InputJsonValue
    maxConcurrentRuns?: IntFieldUpdateOperationsInput | number
    retryPolicy?: NullableJsonNullValueInput | InputJsonValue
    dependencies?: NullableJsonNullValueInput | InputJsonValue
    notificationConfig?: NullableJsonNullValueInput | InputJsonValue
    tags?: ScheduleUpdatetagsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ExecutionLogCreateManyJobInput = {
    id?: string
    stepIndex: number
    stepName?: string | null
    level: $Enums.LogLevel
    message: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: Date | string
    duration?: number | null
  }

  export type ExecutionScreenshotCreateManyJobInput = {
    id?: string
    stepIndex: number
    stepName?: string | null
    screenshotType: $Enums.ScreenshotType
    blobUrl: string
    signedUrl?: string | null
    size: number
    width: number
    height: number
    format: string
    isCompressed?: boolean
    originalSize?: number | null
    compressionRatio?: number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    capturedAt?: Date | string
    expiresAt?: Date | string | null
  }

  export type ExecutionLogUpdateWithoutJobInput = {
    id?: StringFieldUpdateOperationsInput | string
    stepIndex?: IntFieldUpdateOperationsInput | number
    stepName?: NullableStringFieldUpdateOperationsInput | string | null
    level?: EnumLogLevelFieldUpdateOperationsInput | $Enums.LogLevel
    message?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ExecutionLogUncheckedUpdateWithoutJobInput = {
    id?: StringFieldUpdateOperationsInput | string
    stepIndex?: IntFieldUpdateOperationsInput | number
    stepName?: NullableStringFieldUpdateOperationsInput | string | null
    level?: EnumLogLevelFieldUpdateOperationsInput | $Enums.LogLevel
    message?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ExecutionLogUncheckedUpdateManyWithoutJobInput = {
    id?: StringFieldUpdateOperationsInput | string
    stepIndex?: IntFieldUpdateOperationsInput | number
    stepName?: NullableStringFieldUpdateOperationsInput | string | null
    level?: EnumLogLevelFieldUpdateOperationsInput | $Enums.LogLevel
    message?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ExecutionScreenshotUpdateWithoutJobInput = {
    id?: StringFieldUpdateOperationsInput | string
    stepIndex?: IntFieldUpdateOperationsInput | number
    stepName?: NullableStringFieldUpdateOperationsInput | string | null
    screenshotType?: EnumScreenshotTypeFieldUpdateOperationsInput | $Enums.ScreenshotType
    blobUrl?: StringFieldUpdateOperationsInput | string
    signedUrl?: NullableStringFieldUpdateOperationsInput | string | null
    size?: IntFieldUpdateOperationsInput | number
    width?: IntFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    format?: StringFieldUpdateOperationsInput | string
    isCompressed?: BoolFieldUpdateOperationsInput | boolean
    originalSize?: NullableIntFieldUpdateOperationsInput | number | null
    compressionRatio?: NullableFloatFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    capturedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ExecutionScreenshotUncheckedUpdateWithoutJobInput = {
    id?: StringFieldUpdateOperationsInput | string
    stepIndex?: IntFieldUpdateOperationsInput | number
    stepName?: NullableStringFieldUpdateOperationsInput | string | null
    screenshotType?: EnumScreenshotTypeFieldUpdateOperationsInput | $Enums.ScreenshotType
    blobUrl?: StringFieldUpdateOperationsInput | string
    signedUrl?: NullableStringFieldUpdateOperationsInput | string | null
    size?: IntFieldUpdateOperationsInput | number
    width?: IntFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    format?: StringFieldUpdateOperationsInput | string
    isCompressed?: BoolFieldUpdateOperationsInput | boolean
    originalSize?: NullableIntFieldUpdateOperationsInput | number | null
    compressionRatio?: NullableFloatFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    capturedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ExecutionScreenshotUncheckedUpdateManyWithoutJobInput = {
    id?: StringFieldUpdateOperationsInput | string
    stepIndex?: IntFieldUpdateOperationsInput | number
    stepName?: NullableStringFieldUpdateOperationsInput | string | null
    screenshotType?: EnumScreenshotTypeFieldUpdateOperationsInput | $Enums.ScreenshotType
    blobUrl?: StringFieldUpdateOperationsInput | string
    signedUrl?: NullableStringFieldUpdateOperationsInput | string | null
    size?: IntFieldUpdateOperationsInput | number
    width?: IntFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    format?: StringFieldUpdateOperationsInput | string
    isCompressed?: BoolFieldUpdateOperationsInput | boolean
    originalSize?: NullableIntFieldUpdateOperationsInput | number | null
    compressionRatio?: NullableFloatFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    capturedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CredentialAuditLogCreateManyCredentialInput = {
    id?: string
    action: $Enums.CredentialAction
    userId?: string | null
    jobId?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    success: boolean
    errorMessage?: string | null
    timestamp?: Date | string
  }

  export type CredentialAuditLogUpdateWithoutCredentialInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: EnumCredentialActionFieldUpdateOperationsInput | $Enums.CredentialAction
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    jobId?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    success?: BoolFieldUpdateOperationsInput | boolean
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CredentialAuditLogUncheckedUpdateWithoutCredentialInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: EnumCredentialActionFieldUpdateOperationsInput | $Enums.CredentialAction
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    jobId?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    success?: BoolFieldUpdateOperationsInput | boolean
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CredentialAuditLogUncheckedUpdateManyWithoutCredentialInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: EnumCredentialActionFieldUpdateOperationsInput | $Enums.CredentialAction
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    jobId?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    success?: BoolFieldUpdateOperationsInput | boolean
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WebhookDeliveryCreateManyWebhookInput = {
    id?: string
    event: string
    payload: JsonNullValueInput | InputJsonValue
    attempt?: number
    statusCode?: number | null
    responseBody?: string | null
    responseTime?: number | null
    success: boolean
    errorMessage?: string | null
    deliveredAt?: Date | string
    nextRetryAt?: Date | string | null
  }

  export type WebhookDeliveryUpdateWithoutWebhookInput = {
    id?: StringFieldUpdateOperationsInput | string
    event?: StringFieldUpdateOperationsInput | string
    payload?: JsonNullValueInput | InputJsonValue
    attempt?: IntFieldUpdateOperationsInput | number
    statusCode?: NullableIntFieldUpdateOperationsInput | number | null
    responseBody?: NullableStringFieldUpdateOperationsInput | string | null
    responseTime?: NullableIntFieldUpdateOperationsInput | number | null
    success?: BoolFieldUpdateOperationsInput | boolean
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    deliveredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nextRetryAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WebhookDeliveryUncheckedUpdateWithoutWebhookInput = {
    id?: StringFieldUpdateOperationsInput | string
    event?: StringFieldUpdateOperationsInput | string
    payload?: JsonNullValueInput | InputJsonValue
    attempt?: IntFieldUpdateOperationsInput | number
    statusCode?: NullableIntFieldUpdateOperationsInput | number | null
    responseBody?: NullableStringFieldUpdateOperationsInput | string | null
    responseTime?: NullableIntFieldUpdateOperationsInput | number | null
    success?: BoolFieldUpdateOperationsInput | boolean
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    deliveredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nextRetryAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WebhookDeliveryUncheckedUpdateManyWithoutWebhookInput = {
    id?: StringFieldUpdateOperationsInput | string
    event?: StringFieldUpdateOperationsInput | string
    payload?: JsonNullValueInput | InputJsonValue
    attempt?: IntFieldUpdateOperationsInput | number
    statusCode?: NullableIntFieldUpdateOperationsInput | number | null
    responseBody?: NullableStringFieldUpdateOperationsInput | string | null
    responseTime?: NullableIntFieldUpdateOperationsInput | number | null
    success?: BoolFieldUpdateOperationsInput | boolean
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    deliveredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nextRetryAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ScheduleExecutionCreateManyScheduleInput = {
    id?: string
    organizationId: string
    jobId?: string | null
    scheduledTime: Date | string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    duration?: number | null
    status: string
    trigger: string
    errorMessage?: string | null
    errorStack?: string | null
    errorCode?: string | null
    attemptNumber?: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ScheduleAuditLogCreateManyScheduleInput = {
    id?: string
    organizationId: string
    action: string
    resource: string
    userId: string
    userEmail?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    requestId?: string | null
    previousValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    changedFields?: ScheduleAuditLogCreatechangedFieldsInput | string[]
    status: string
    errorMessage?: string | null
    errorCode?: string | null
    durationMs?: number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: Date | string
    retainUntil: Date | string
  }

  export type ScheduleExecutionUpdateWithoutScheduleInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    scheduledTime?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    trigger?: StringFieldUpdateOperationsInput | string
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    errorStack?: NullableStringFieldUpdateOperationsInput | string | null
    errorCode?: NullableStringFieldUpdateOperationsInput | string | null
    attemptNumber?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    job?: JobUpdateOneWithoutScheduleExecutionNestedInput
  }

  export type ScheduleExecutionUncheckedUpdateWithoutScheduleInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    jobId?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledTime?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    trigger?: StringFieldUpdateOperationsInput | string
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    errorStack?: NullableStringFieldUpdateOperationsInput | string | null
    errorCode?: NullableStringFieldUpdateOperationsInput | string | null
    attemptNumber?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScheduleExecutionUncheckedUpdateManyWithoutScheduleInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    jobId?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledTime?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    trigger?: StringFieldUpdateOperationsInput | string
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    errorStack?: NullableStringFieldUpdateOperationsInput | string | null
    errorCode?: NullableStringFieldUpdateOperationsInput | string | null
    attemptNumber?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScheduleAuditLogUpdateWithoutScheduleInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    resource?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    userEmail?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    requestId?: NullableStringFieldUpdateOperationsInput | string | null
    previousValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    changedFields?: ScheduleAuditLogUpdatechangedFieldsInput | string[]
    status?: StringFieldUpdateOperationsInput | string
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    errorCode?: NullableStringFieldUpdateOperationsInput | string | null
    durationMs?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    retainUntil?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScheduleAuditLogUncheckedUpdateWithoutScheduleInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    resource?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    userEmail?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    requestId?: NullableStringFieldUpdateOperationsInput | string | null
    previousValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    changedFields?: ScheduleAuditLogUpdatechangedFieldsInput | string[]
    status?: StringFieldUpdateOperationsInput | string
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    errorCode?: NullableStringFieldUpdateOperationsInput | string | null
    durationMs?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    retainUntil?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScheduleAuditLogUncheckedUpdateManyWithoutScheduleInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    resource?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    userEmail?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    requestId?: NullableStringFieldUpdateOperationsInput | string | null
    previousValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    changedFields?: ScheduleAuditLogUpdatechangedFieldsInput | string[]
    status?: StringFieldUpdateOperationsInput | string
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    errorCode?: NullableStringFieldUpdateOperationsInput | string | null
    durationMs?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    retainUntil?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}